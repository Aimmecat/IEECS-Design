1
00:00:00,000 --> 00:00:00,040

2
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

3
00:00:02,460 --> 00:00:03,870
Commons license.

4
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

5
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

6
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

7
00:00:13,460 --> 00:00:17,390
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:17,390 --> 00:00:18,640
ocw.mit.edu.

9
00:00:18,640 --> 00:00:26,080

10
00:00:26,080 --> 00:00:27,330
PROFESSOR: Hello, and welcome.

11
00:00:27,330 --> 00:00:31,870

12
00:00:31,870 --> 00:00:34,920
Last week we started to think
about programming.

13
00:00:34,920 --> 00:00:38,550
Programming was the first
module in this class.

14
00:00:38,550 --> 00:00:40,900
And it was important for
two different reasons.

15
00:00:40,900 --> 00:00:44,410
First, we're going to use
programming throughout the

16
00:00:44,410 --> 00:00:49,660
term in the study of all the
different things that we do.

17
00:00:49,660 --> 00:00:52,540
So it's important that you learn
to program now, just so

18
00:00:52,540 --> 00:00:56,400
you can use that tool.

19
00:00:56,400 --> 00:01:00,360
More importantly perhaps, we
didn't just learn how to

20
00:01:00,360 --> 00:01:05,370
program, we focused on how to
program in a fashion that

21
00:01:05,370 --> 00:01:08,310
would let us construct
complicated systems out of a

22
00:01:08,310 --> 00:01:09,420
simpler systems.

23
00:01:09,420 --> 00:01:12,570
This is the way that we
can manage complexity.

24
00:01:12,570 --> 00:01:15,340
This is the only possible
way that we can

25
00:01:15,340 --> 00:01:18,440
make complicated systems.

26
00:01:18,440 --> 00:01:21,380
So that was the more important
intellectual theme from the

27
00:01:21,380 --> 00:01:26,040
first part, where we introduced
our mantra, PCAP --

28
00:01:26,040 --> 00:01:29,650
primitives, means of
combination, abstraction and

29
00:01:29,650 --> 00:01:31,760
identifying patterns.

30
00:01:31,760 --> 00:01:36,090
That's the key to this
modular approach to

31
00:01:36,090 --> 00:01:37,740
hierarchical kind of design.

32
00:01:37,740 --> 00:01:40,430

33
00:01:40,430 --> 00:01:43,610
Today what I want to do is start
the second major theme.

34
00:01:43,610 --> 00:01:46,770
First theme was the design of
complex systems, we saw that

35
00:01:46,770 --> 00:01:49,110
by reference to programming.

36
00:01:49,110 --> 00:01:51,470
Today we're going to start
thinking about modeling and

37
00:01:51,470 --> 00:01:52,975
controlling physical systems.

38
00:01:52,975 --> 00:01:55,890

39
00:01:55,890 --> 00:02:01,080
The idea here is not so much
how you construct systems--

40
00:02:01,080 --> 00:02:04,430
but we will get back to that.

41
00:02:04,430 --> 00:02:07,740
The idea is to characterize
the systems that you've

42
00:02:07,740 --> 00:02:11,280
constructed and say something
about their metrics as being

43
00:02:11,280 --> 00:02:13,360
positive or negative.

44
00:02:13,360 --> 00:02:16,205
So what we want to do is, in
fact, focus on behavior.

45
00:02:16,205 --> 00:02:19,680

46
00:02:19,680 --> 00:02:23,920
So to illustrate that, I'll
start with an example.

47
00:02:23,920 --> 00:02:26,760
This is an example that you did
in design lab last week,

48
00:02:26,760 --> 00:02:29,260
or for some of you, yesterday.

49
00:02:29,260 --> 00:02:34,260
The idea was to program the
robot so that it could sense

50
00:02:34,260 --> 00:02:36,000
the distance to a wall.

51
00:02:36,000 --> 00:02:39,435
Represented two ways here,
sort of the view that you

52
00:02:39,435 --> 00:02:43,050
would get from Soar, and a more
schematic representation

53
00:02:43,050 --> 00:02:45,820
showing the position of a robot,
the position of a wall.

54
00:02:45,820 --> 00:02:48,930
The idea is that you can sense
the position to the wall using

55
00:02:48,930 --> 00:02:50,704
the sonars.

56
00:02:50,704 --> 00:02:52,940
You know where you would
like to be, because

57
00:02:52,940 --> 00:02:54,050
some user told you.

58
00:02:54,050 --> 00:02:57,100
You'd like to be say, half a
meter away from the wall.

59
00:02:57,100 --> 00:03:01,130
And your job was to write a
program that moves the robot

60
00:03:01,130 --> 00:03:03,210
from where it is to where
you'd like it to be.

61
00:03:03,210 --> 00:03:06,200

62
00:03:06,200 --> 00:03:08,835
So here's the kind of behavior
we might have liked--

63
00:03:08,835 --> 00:03:11,860

64
00:03:11,860 --> 00:03:13,050
so I'll do that again.

65
00:03:13,050 --> 00:03:17,180
So we might have liked that if
you started here, you have a

66
00:03:17,180 --> 00:03:21,080
nice smooth progression up to
where you'd like to be.

67
00:03:21,080 --> 00:03:24,890
Very graceful, ballet type, and
you just sort of smoothly

68
00:03:24,890 --> 00:03:27,090
glide into the position
that you'd like.

69
00:03:27,090 --> 00:03:29,700
Some of you probably achieved
that behavior, and some of you

70
00:03:29,700 --> 00:03:32,850
probably did other things.

71
00:03:32,850 --> 00:03:36,580
So that might be the
intended behavior.

72
00:03:36,580 --> 00:03:40,980
One way to achieve the intended
behavior is to use

73
00:03:40,980 --> 00:03:42,520
what we call a proportional
controller.

74
00:03:42,520 --> 00:03:45,410

75
00:03:45,410 --> 00:03:50,100
In a proportional controller,
you make the command be, in

76
00:03:50,100 --> 00:03:55,160
some way, proportionate to
the intended response.

77
00:03:55,160 --> 00:04:00,070
So imagine this code, which
might establish a class for

78
00:04:00,070 --> 00:04:03,170
finding the wall.

79
00:04:03,170 --> 00:04:06,800
So the important thing-- as we
saw, for all state machines,

80
00:04:06,800 --> 00:04:10,480
the important thing is to define
a start state and a

81
00:04:10,480 --> 00:04:13,880
getNextValues routine.

82
00:04:13,880 --> 00:04:17,100
What this getNextValues routine
does is it establishes

83
00:04:17,100 --> 00:04:21,480
the desired distance to
be a half a meter.

84
00:04:21,480 --> 00:04:23,900
It figures out the current
distance to the wall by

85
00:04:23,900 --> 00:04:29,040
reading the sonars, and then
it specifies an action.

86
00:04:29,040 --> 00:04:33,300
So the first question is what
would you like fvel to be in

87
00:04:33,300 --> 00:04:37,260
order to make a proportional
controller?

88
00:04:37,260 --> 00:04:41,020
Which of those expressions
makes sense?

89
00:04:41,020 --> 00:04:44,130
Take 30 seconds, talk to your
neighbor, figure out some

90
00:04:44,130 --> 00:04:45,500
answer between (1) and (5).

91
00:04:45,500 --> 00:04:47,850
I will ask you in 30 seconds to
raise your hand with that

92
00:04:47,850 --> 00:04:48,530
number of fingers.

93
00:04:48,530 --> 00:04:49,780
AUDIENCE: [INAUDIBLE]

94
00:04:49,780 --> 00:05:58,970

95
00:05:58,970 --> 00:06:01,270
PROFESSOR: So what's the right
kind of expression if we

96
00:06:01,270 --> 00:06:03,030
wanted the controller
to be proportionate?

97
00:06:03,030 --> 00:06:04,130
Everybody raise your
hand, show me

98
00:06:04,130 --> 00:06:05,380
some number of fingers.

99
00:06:05,380 --> 00:06:07,570

100
00:06:07,570 --> 00:06:11,110
OK, the vast majority
is saying (2).

101
00:06:11,110 --> 00:06:14,690
Everybody likes the idea of
current minus desired.

102
00:06:14,690 --> 00:06:16,430
Why is that the right answer?

103
00:06:16,430 --> 00:06:17,960
That is the right answer.

104
00:06:17,960 --> 00:06:19,840
Why is that the right answer?

105
00:06:19,840 --> 00:06:22,252
How do you prove that
to somebody?

106
00:06:22,252 --> 00:06:25,138
AUDIENCE: Well, in current
divided desired, once you meet

107
00:06:25,138 --> 00:06:27,543
your desired distance, you're
still going to have to

108
00:06:27,543 --> 00:06:29,467
[UNINTELLIGIBLE] velocity
[UNINTELLIGIBLE], which really

109
00:06:29,467 --> 00:06:30,440
doesn't make sense
at this point.

110
00:06:30,440 --> 00:06:31,570
PROFESSOR: Exactly.

111
00:06:31,570 --> 00:06:35,450
So that method, we might
call extreme cases.

112
00:06:35,450 --> 00:06:39,120
Think of the simplifying cases
that give you some insight

113
00:06:39,120 --> 00:06:39,810
into the problem.

114
00:06:39,810 --> 00:06:43,390
So one simple case is
what if desired and

115
00:06:43,390 --> 00:06:44,960
current were the same?

116
00:06:44,960 --> 00:06:47,215
You'd better stop.

117
00:06:47,215 --> 00:06:49,510
OK, that's a simple case.

118
00:06:49,510 --> 00:06:52,820
So the simple case says that you
better have one of these--

119
00:06:52,820 --> 00:06:54,600
whatever the right answer is,
it better have the property

120
00:06:54,600 --> 00:06:57,610
that when current equals
desired, fvel is 0.

121
00:06:57,610 --> 00:06:58,890
Otherwise it's not
going to work.

122
00:06:58,890 --> 00:07:01,530
And in fact, using just that
one simple case, you can

123
00:07:01,530 --> 00:07:04,310
eliminate all the
ones except (2).

124
00:07:04,310 --> 00:07:06,080
There are some other simple
cases, what are some other

125
00:07:06,080 --> 00:07:07,330
simple cases?

126
00:07:07,330 --> 00:07:10,137

127
00:07:10,137 --> 00:07:10,850
Simple cases.

128
00:07:10,850 --> 00:07:11,811
Yeah.

129
00:07:11,811 --> 00:07:14,170
AUDIENCE: currentDistance
greater than desiredDistance?

130
00:07:14,170 --> 00:07:15,765
PROFESSOR: Current bigger
than desired.

131
00:07:15,765 --> 00:07:18,010
So if current were bigger, that
would mean that you were

132
00:07:18,010 --> 00:07:21,590
starting out way over
here someplace.

133
00:07:21,590 --> 00:07:24,050
So if you were way over there
someplace, you'd want the

134
00:07:24,050 --> 00:07:26,230
velocity to be positive.

135
00:07:26,230 --> 00:07:28,590
The forward velocity
should be positive.

136
00:07:28,590 --> 00:07:32,200
That's how you would
disambiguate the sign.

137
00:07:32,200 --> 00:07:35,670
Similarly, if the current were
shorter than desired, if you

138
00:07:35,670 --> 00:07:37,610
were too close to the wall,
you'd like the forward

139
00:07:37,610 --> 00:07:39,770
velocity to be negative.

140
00:07:39,770 --> 00:07:41,020
OK.

141
00:07:41,020 --> 00:07:44,130
So that's the proportional
controller that we'd like.

142
00:07:44,130 --> 00:07:47,770
So we might fill in our wall
finder class this way.

143
00:07:47,770 --> 00:07:50,430

144
00:07:50,430 --> 00:07:54,450
And then when we built it, if
things went really well, we

145
00:07:54,450 --> 00:07:56,920
would get exactly the
behavior we wanted.

146
00:07:56,920 --> 00:08:00,430
But if things went more
naturally, it wouldn't quite

147
00:08:00,430 --> 00:08:02,040
work that way, and
you might get a

148
00:08:02,040 --> 00:08:03,290
different kind of behavior.

149
00:08:03,290 --> 00:08:07,130

150
00:08:07,130 --> 00:08:07,930
Let's do that again.

151
00:08:07,930 --> 00:08:11,030
So here is the resulting
behavior for that simple

152
00:08:11,030 --> 00:08:12,280
controller that I just showed.

153
00:08:12,280 --> 00:08:16,310

154
00:08:16,310 --> 00:08:21,590
So in some sense, that's
not as good behavior.

155
00:08:21,590 --> 00:08:23,360
And the way we want to think
about behaviors--

156
00:08:23,360 --> 00:08:25,120
the way we're going to develop
today, is to think about

157
00:08:25,120 --> 00:08:29,010
behaviors in terms of signals.

158
00:08:29,010 --> 00:08:31,130
Plots.

159
00:08:31,130 --> 00:08:34,679
So the first question is, what
plot best represents the

160
00:08:34,679 --> 00:08:36,180
behavior that I saw here?

161
00:08:36,180 --> 00:08:43,070

162
00:08:43,070 --> 00:08:45,330
So which of those plots best
represents that behavior?

163
00:08:45,330 --> 00:08:47,260
Take 30 seconds, talk to your
neighbor, figure out what's

164
00:08:47,260 --> 00:08:47,800
the right answer?

165
00:08:47,800 --> 00:08:49,050
AUDIENCE: [INAUDIBLE]

166
00:08:49,050 --> 00:09:46,250

167
00:09:46,250 --> 00:09:49,850
PROFESSOR: OK, so which behavior
best represents the

168
00:09:49,850 --> 00:09:52,650
illustrated cartoon that
I showed previously?

169
00:09:52,650 --> 00:09:55,573
Raise your hand, show some
number fingers so that I can

170
00:09:55,573 --> 00:09:57,680
see if you're with it.

171
00:09:57,680 --> 00:10:02,050
Not all correct, but more
than 90% correct.

172
00:10:02,050 --> 00:10:04,510
The more than 90% answer
is number (2).

173
00:10:04,510 --> 00:10:07,200
What's good about number (2)
that's not good about numbers

174
00:10:07,200 --> 00:10:08,525
(1), (3), and (4)?

175
00:10:08,525 --> 00:10:12,846

176
00:10:12,846 --> 00:10:14,337
AUDIENCE: The initial
value is different

177
00:10:14,337 --> 00:10:15,331
than the final value.

178
00:10:15,331 --> 00:10:16,822
PROFESSOR: Initial
is different.

179
00:10:16,822 --> 00:10:19,930
So here, I try initial and final
being roughly the same.

180
00:10:19,930 --> 00:10:22,390
So what's showed here,
is a plot.

181
00:10:22,390 --> 00:10:24,490
Current distance on
the y-axis, step

182
00:10:24,490 --> 00:10:26,820
number on the x-axis.

183
00:10:26,820 --> 00:10:29,270
And so we can see from here--
and the implication of the

184
00:10:29,270 --> 00:10:31,500
axes, by the way, is 0.

185
00:10:31,500 --> 00:10:34,970
So the implication of the
vertical axis is it intersects

186
00:10:34,970 --> 00:10:38,400
this at 0, unless I label
it otherwise.

187
00:10:38,400 --> 00:10:41,060
And similarly, this horizontal
line intersects the vertical

188
00:10:41,060 --> 00:10:43,100
at 0 unless I label
it otherwise.

189
00:10:43,100 --> 00:10:44,830
So that's the point (0, 0).

190
00:10:44,830 --> 00:10:47,870
So the implication here is that
the initial and the final

191
00:10:47,870 --> 00:10:51,470
values are the same,
as they are here.

192
00:10:51,470 --> 00:10:55,467
Here they're not, what makes
(2) better than (1).

193
00:10:55,467 --> 00:10:56,717
AUDIENCE: [INAUDIBLE]

194
00:10:56,717 --> 00:11:00,457

195
00:11:00,457 --> 00:11:03,950
the current distance is
decreasing [UNINTELLIGIBLE].

196
00:11:03,950 --> 00:11:06,350
PROFESSOR: The current distance
starts out bigger

197
00:11:06,350 --> 00:11:07,710
than it ultimately is.

198
00:11:07,710 --> 00:11:10,430
So we start out bigger than
the final value, the final

199
00:11:10,430 --> 00:11:13,510
value is presumably
half a meter.

200
00:11:13,510 --> 00:11:16,120
We start out roughly
twice that far, and

201
00:11:16,120 --> 00:11:17,630
then we see some approach.

202
00:11:17,630 --> 00:11:20,360
The approach is not monotonic.

203
00:11:20,360 --> 00:11:23,560
So the answer is (2).

204
00:11:23,560 --> 00:11:27,760
Why do you think
it under-shot?

205
00:11:27,760 --> 00:11:30,820
So on the way to going from
one to one-half, it

206
00:11:30,820 --> 00:11:32,180
transiently went through
something

207
00:11:32,180 --> 00:11:33,030
smaller than one-half.

208
00:11:33,030 --> 00:11:34,730
Why do you think it did that?

209
00:11:34,730 --> 00:11:35,710
Yeah.

210
00:11:35,710 --> 00:11:37,180
AUDIENCE: Because [INAUDIBLE]

211
00:11:37,180 --> 00:11:39,956
this way, there's a small--
there's a small interval of

212
00:11:39,956 --> 00:11:41,100
time when its moving at the
velocity where it couldn't

213
00:11:41,100 --> 00:11:43,060
[INAUDIBLE].

214
00:11:43,060 --> 00:11:46,060
PROFESSOR: So it's a small
interval of time between when

215
00:11:46,060 --> 00:11:48,960
it does one thing, and it
does something else.

216
00:11:48,960 --> 00:11:51,620
When it senses and moves,
for example.

217
00:11:51,620 --> 00:11:54,100
So there could be a time delay,
in the system and in

218
00:11:54,100 --> 00:11:56,640
fact, that's true, there
is a time delay.

219
00:11:56,640 --> 00:12:00,190
So it takes some amount of
time for the sonars to

220
00:12:00,190 --> 00:12:02,390
register the distance.

221
00:12:02,390 --> 00:12:05,070
Then it takes some amount of
time for the computer inside

222
00:12:05,070 --> 00:12:07,640
the robot to register that
the sonar has told

223
00:12:07,640 --> 00:12:09,060
it something different.

224
00:12:09,060 --> 00:12:11,800
Than it takes some time from the
time the computer commands

225
00:12:11,800 --> 00:12:14,630
the wheels until the robot
starts moving.

226
00:12:14,630 --> 00:12:17,900
All of those cumulative effects
mean that you have the

227
00:12:17,900 --> 00:12:21,910
potential to overshoot where
you're going, because there's

228
00:12:21,910 --> 00:12:25,660
delay in the system, there's
inertia in the robot.

229
00:12:25,660 --> 00:12:28,140
All of those reasons can
lead to overshoot.

230
00:12:28,140 --> 00:12:32,850
And the point of today is to
figure out some way of

231
00:12:32,850 --> 00:12:37,460
predicting and correcting
for those kinds

232
00:12:37,460 --> 00:12:40,970
of unintended behaviors.

233
00:12:40,970 --> 00:12:45,960
So what we will do then, is
develop an approach focused on

234
00:12:45,960 --> 00:12:50,390
signals, not systems.

235
00:12:50,390 --> 00:12:51,850
So, so far, we've been thinking
about how do you

236
00:12:51,850 --> 00:12:52,470
build the system?

237
00:12:52,470 --> 00:12:53,720
Now we're going to think
about behavior.

238
00:12:53,720 --> 00:12:56,550
We're going to think about
analyzing that behavior.

239
00:12:56,550 --> 00:12:59,890
And the focus is going to be
on what was the input, what

240
00:12:59,890 --> 00:13:02,300
was desired?

241
00:13:02,300 --> 00:13:05,680
What was the output,
what was achieved?

242
00:13:05,680 --> 00:13:09,260
So we're going to be looking
at those output signals in

243
00:13:09,260 --> 00:13:12,330
order to figure out how
good the behavior was.

244
00:13:12,330 --> 00:13:16,770
That approach is called the
signals and systems approach.

245
00:13:16,770 --> 00:13:20,870
The idea is characterize your
system-- whatever that system

246
00:13:20,870 --> 00:13:23,550
is, a physical system, a
mathematical system, a

247
00:13:23,550 --> 00:13:27,740
computational system, whatever
it is, think about it by the

248
00:13:27,740 --> 00:13:33,330
way it transforms an input
signal into an output signal.

249
00:13:33,330 --> 00:13:36,350
That's kind of a bizarre way
to think about systems.

250
00:13:36,350 --> 00:13:39,270
So let me just illustrate that
by way of a system that you've

251
00:13:39,270 --> 00:13:40,590
all seen before.

252
00:13:40,590 --> 00:13:41,960
OK, here's a simple
system, right?

253
00:13:41,960 --> 00:13:43,920
You've all seen this, right?

254
00:13:43,920 --> 00:13:48,420
Anything like 8.01
ring any bells?

255
00:13:48,420 --> 00:13:51,070
OK, so that's a simple system,
you all know how to solve it.

256
00:13:51,070 --> 00:13:52,970
There's a gazillion ways
you could solve

257
00:13:52,970 --> 00:13:54,740
this system, right?

258
00:13:54,740 --> 00:13:58,220
Free body diagrams, kinetic
energy, potential energy,

259
00:13:58,220 --> 00:14:00,090
there's a gazillion ways
you could do it.

260
00:14:00,090 --> 00:14:02,900
You all know how to do it,
that's not the point.

261
00:14:02,900 --> 00:14:04,490
The point is, that we're going
to learn a different

262
00:14:04,490 --> 00:14:07,790
way to solve it.

263
00:14:07,790 --> 00:14:11,090
We're going to think about the
mass and spring system--

264
00:14:11,090 --> 00:14:14,340
not like potential energy and
kinetic energy, not like free

265
00:14:14,340 --> 00:14:17,200
body diagrams, we're going to
think about it as transforming

266
00:14:17,200 --> 00:14:20,440
an input signal into
an output signal.

267
00:14:20,440 --> 00:14:22,740
So the input signal--

268
00:14:22,740 --> 00:14:26,510
it's kind of arbitrary what I
use besides the output, but

269
00:14:26,510 --> 00:14:31,260
clearly the thing I have control
over is my hand.

270
00:14:31,260 --> 00:14:34,340
So it seems natural to associate
a variable with the

271
00:14:34,340 --> 00:14:37,920
position of my hand,
that would be x.

272
00:14:37,920 --> 00:14:41,110
Also it seems natural to
associate a variable with the

273
00:14:41,110 --> 00:14:44,270
position of the mass, that
could be the output y.

274
00:14:44,270 --> 00:14:46,580
That's not unique.

275
00:14:46,580 --> 00:14:50,340
Every time we try to solve a
problem we ask ourselves,

276
00:14:50,340 --> 00:14:53,630
what's the meaningful input,
what's the meaningful output?

277
00:14:53,630 --> 00:14:55,880
The meaningful output
could have been the

278
00:14:55,880 --> 00:14:57,130
force on the spring.

279
00:14:57,130 --> 00:15:00,030

280
00:15:00,030 --> 00:15:02,840
I'm just sort of arbitrarily
saying for the purpose of my

281
00:15:02,840 --> 00:15:06,000
analysis, I'm going to consider
the input to be the

282
00:15:06,000 --> 00:15:08,140
position of the hand,
the output to be the

283
00:15:08,140 --> 00:15:09,270
position of the mass.

284
00:15:09,270 --> 00:15:11,700
And I'm going to think about the
mass and spring system as

285
00:15:11,700 --> 00:15:14,860
a box that transforms
x into y.

286
00:15:14,860 --> 00:15:17,200
So rather than thinking about
it in terms of free body

287
00:15:17,200 --> 00:15:19,575
diagrams, and kinetic energy,
and potential energy, I'm

288
00:15:19,575 --> 00:15:21,960
going to think there's some
input signal x, and there's

289
00:15:21,960 --> 00:15:24,120
some output signal y.

290
00:15:24,120 --> 00:15:27,500
And what I'd like to do is
given x, calculate y.

291
00:15:27,500 --> 00:15:30,670

292
00:15:30,670 --> 00:15:32,830
OK, bizarre, why would
I do that?

293
00:15:32,830 --> 00:15:35,040
One of the reasons I want to
do that is that it's a very

294
00:15:35,040 --> 00:15:37,180
general way of thinking
about behaviors.

295
00:15:37,180 --> 00:15:39,980

296
00:15:39,980 --> 00:15:42,170
It works for the mass and spring
system, it works for

297
00:15:42,170 --> 00:15:43,980
water tanks.

298
00:15:43,980 --> 00:15:45,700
What happens if I have
water flowing into

299
00:15:45,700 --> 00:15:47,103
a tank that's leaky?

300
00:15:47,103 --> 00:15:49,870
Well, it leaks into another tank
which is leaky, and that

301
00:15:49,870 --> 00:15:52,110
leaks more.

302
00:15:52,110 --> 00:15:55,100
Completely different physics.

303
00:15:55,100 --> 00:15:58,370
Probably wasn't covered
in 8.01.

304
00:15:58,370 --> 00:16:02,050
Probably is something you
could figure out.

305
00:16:02,050 --> 00:16:04,820
The point is that from the
signals and systems point of

306
00:16:04,820 --> 00:16:08,330
view, I'm going to map this
physics, whatever it is, into

307
00:16:08,330 --> 00:16:11,000
this structure.

308
00:16:11,000 --> 00:16:14,490
Think about the tank system as
the system that transforms

309
00:16:14,490 --> 00:16:16,450
some input.

310
00:16:16,450 --> 00:16:20,550
The input is that there's water
spurting for some small

311
00:16:20,550 --> 00:16:22,950
interval of time.

312
00:16:22,950 --> 00:16:26,520
The output is that there's
water coming out.

313
00:16:26,520 --> 00:16:29,180
And the idea is that I'm going
to characterize the system--

314
00:16:29,180 --> 00:16:33,080
whatever it is, as the rule
that transforms the input

315
00:16:33,080 --> 00:16:34,500
signal into the output signal.

316
00:16:34,500 --> 00:16:37,070

317
00:16:37,070 --> 00:16:38,690
Here's a third example.

318
00:16:38,690 --> 00:16:42,100
I could think of a cell
phone system.

319
00:16:42,100 --> 00:16:44,170
Here again, there are very
complicated ways we could

320
00:16:44,170 --> 00:16:45,960
think about the system, but
I'm going to take the

321
00:16:45,960 --> 00:16:49,810
particularly simple approach
called signals and systems.

322
00:16:49,810 --> 00:16:52,300
Then I'm going to characterize
the phone system by the way it

323
00:16:52,300 --> 00:16:58,580
transforms some input sound
into some output sound.

324
00:16:58,580 --> 00:17:00,810
And as you can imagine, there's
a way of thinking

325
00:17:00,810 --> 00:17:03,490
about performance in terms
of that transformation.

326
00:17:03,490 --> 00:17:08,349
Ideally, we would like this to
bear some resemblance to that.

327
00:17:08,349 --> 00:17:10,050
So the point then,
is that we're

328
00:17:10,050 --> 00:17:11,810
going to focus on behaviors.

329
00:17:11,810 --> 00:17:14,440
And to do so, we're going to
think about the signals and

330
00:17:14,440 --> 00:17:16,089
systems approach.

331
00:17:16,089 --> 00:17:19,060
Represent a system, whatever
it is, by the way it

332
00:17:19,060 --> 00:17:22,569
transforms inputs
into outputs.

333
00:17:22,569 --> 00:17:24,730
One of the reasons we
like the approach is

334
00:17:24,730 --> 00:17:25,980
that it's so general.

335
00:17:25,980 --> 00:17:28,420

336
00:17:28,420 --> 00:17:32,860
So you can use it for virtually
any kind of a system

337
00:17:32,860 --> 00:17:37,040
for which you can develop a
mathematical underpinning.

338
00:17:37,040 --> 00:17:39,330
You can use it to analyze
electrical systems, mechanical

339
00:17:39,330 --> 00:17:41,340
systems, optical systems,
acoustic systems, biological

340
00:17:41,340 --> 00:17:44,280
systems, financial systems if
you're on the dark side.

341
00:17:44,280 --> 00:17:51,340
So there's lots of different
kinds of systems that are

342
00:17:51,340 --> 00:17:52,790
amenable to this kind
of approach.

343
00:17:52,790 --> 00:17:55,390

344
00:17:55,390 --> 00:17:59,435
Also, this approach has
a nice modularity.

345
00:17:59,435 --> 00:18:02,720

346
00:18:02,720 --> 00:18:08,020
Having represented a cellphone
by transformation from sound

347
00:18:08,020 --> 00:18:11,220
in to electromagnetic field out,
as illustrated by this

348
00:18:11,220 --> 00:18:14,560
cartoon depicting sound going
in and having a radio wave

349
00:18:14,560 --> 00:18:17,430
transmitting to a tower.

350
00:18:17,430 --> 00:18:20,480
Then we represent tower to tower
communication some way,

351
00:18:20,480 --> 00:18:25,210
maybe via an optical fiber,
maybe via a satellite.

352
00:18:25,210 --> 00:18:28,160
Then tower to cell by the same
kind of reverse transformation

353
00:18:28,160 --> 00:18:30,440
that we used in the first one.

354
00:18:30,440 --> 00:18:33,520
We can piece those all together,
we can treat them as

355
00:18:33,520 --> 00:18:38,100
modules, because each box takes
an input signal and

356
00:18:38,100 --> 00:18:41,260
makes an output signal.

357
00:18:41,260 --> 00:18:45,510
The method is oblivious to
the underlying physics.

358
00:18:45,510 --> 00:18:49,030
That affords us a certain
amount of power.

359
00:18:49,030 --> 00:18:51,540
And in particular, it's
very modular.

360
00:18:51,540 --> 00:18:55,860
You can put together modules
that represent very different

361
00:18:55,860 --> 00:18:57,440
physical substrates.

362
00:18:57,440 --> 00:19:00,210

363
00:19:00,210 --> 00:19:04,670
That allows us to
go back to PCAP.

364
00:19:04,670 --> 00:19:06,860
If the underlying
representations for the

365
00:19:06,860 --> 00:19:11,370
different physical substrates
are the same, we will be able

366
00:19:11,370 --> 00:19:14,670
to-- and we will over the next
three weeks, develop a bunch

367
00:19:14,670 --> 00:19:20,450
of techniques for combining
multiple modules into one.

368
00:19:20,450 --> 00:19:23,780
That provides the same kind of
abstraction and modularity

369
00:19:23,780 --> 00:19:29,020
that we saw in programming
for the last two weeks.

370
00:19:29,020 --> 00:19:30,380
So that's the idea.

371
00:19:30,380 --> 00:19:33,740
What we want to do is represent
a system by the way

372
00:19:33,740 --> 00:19:38,600
it transforms an input signal
to an output signal.

373
00:19:38,600 --> 00:19:43,050
There are many different kinds
of inputs and outputs, but a

374
00:19:43,050 --> 00:19:46,450
fundamental distinction that we
are going to have to make

375
00:19:46,450 --> 00:19:51,140
is continuous time,
and discrete time.

376
00:19:51,140 --> 00:19:53,810
This system works in what
we will refer to

377
00:19:53,810 --> 00:19:55,220
as continuous time.

378
00:19:55,220 --> 00:19:58,950
Because my position of my hand
is a continuous function of

379
00:19:58,950 --> 00:20:00,380
the continuous variable, time.

380
00:20:00,380 --> 00:20:03,850

381
00:20:03,850 --> 00:20:07,120
The robots, by contrast, work
with what we will call,

382
00:20:07,120 --> 00:20:08,710
discrete time.

383
00:20:08,710 --> 00:20:10,870
Steps.

384
00:20:10,870 --> 00:20:13,550
It turns out the math for those
two different approaches

385
00:20:13,550 --> 00:20:15,280
are very different.

386
00:20:15,280 --> 00:20:18,450
And we will focus entirely in
this class on discrete time,

387
00:20:18,450 --> 00:20:21,370
because our area of application
is the robot.

388
00:20:21,370 --> 00:20:24,450
It's not that continuous is
deeper, or harder, or anything

389
00:20:24,450 --> 00:20:26,420
like that, it's different.

390
00:20:26,420 --> 00:20:30,110
So we'll focus on
discrete time.

391
00:20:30,110 --> 00:20:32,290
And the point of today then,
is to develop some

392
00:20:32,290 --> 00:20:38,290
representations for signals and
systems of this free time

393
00:20:38,290 --> 00:20:43,800
nature, that will let us analyze
and predict behaviors

394
00:20:43,800 --> 00:20:45,890
of systems like the
robot system.

395
00:20:45,890 --> 00:20:48,480

396
00:20:48,480 --> 00:20:53,320
The first class of methods for
representing such systems is

397
00:20:53,320 --> 00:20:54,260
difference equations.

398
00:20:54,260 --> 00:20:57,610
Difference equations are a lot
like differential equations,

399
00:20:57,610 --> 00:20:59,110
except there's no differentials,
there's

400
00:20:59,110 --> 00:21:00,690
differences.

401
00:21:00,690 --> 00:21:06,050
Difference equations are the
discrete time analog of

402
00:21:06,050 --> 00:21:10,110
differential equations for
continuous time systems.

403
00:21:10,110 --> 00:21:12,670
Simplest possible
example here.

404
00:21:12,670 --> 00:21:17,410
Say I have an output y, that for
reasons that I don't care

405
00:21:17,410 --> 00:21:21,090
about, I know can be represented
as the difference

406
00:21:21,090 --> 00:21:23,790
between two values
of the input --

407
00:21:23,790 --> 00:21:26,250
x at time n, and x at
time n minus 1.

408
00:21:26,250 --> 00:21:29,220

409
00:21:29,220 --> 00:21:33,280
That's a way to represent the
behavior of a system, a

410
00:21:33,280 --> 00:21:37,710
discrete time system, by using
a difference equation.

411
00:21:37,710 --> 00:21:39,660
That's in fact, almost
a complete

412
00:21:39,660 --> 00:21:40,910
description of the system.

413
00:21:40,910 --> 00:21:43,990

414
00:21:43,990 --> 00:21:46,540
So let me just explain the
way you would use that.

415
00:21:46,540 --> 00:21:47,870
It's almost-- because
I didn't tell you

416
00:21:47,870 --> 00:21:49,120
anything about the input.

417
00:21:49,120 --> 00:21:52,620

418
00:21:52,620 --> 00:21:55,190
I'll tell you something about
the input for the purpose of

419
00:21:55,190 --> 00:21:57,840
example, where I'll
use the simplest

420
00:21:57,840 --> 00:21:59,850
possible input I can imagine.

421
00:21:59,850 --> 00:22:03,990
Something that we'll call
a delta function.

422
00:22:03,990 --> 00:22:05,460
A delta function is a signal.

423
00:22:05,460 --> 00:22:08,660

424
00:22:08,660 --> 00:22:10,910
It's a discrete time signal.

425
00:22:10,910 --> 00:22:14,660
It has the value 1 if the time
index is 0, and has the value

426
00:22:14,660 --> 00:22:17,330
0 everywhere else.

427
00:22:17,330 --> 00:22:20,170
It's, in some sense, the
simplest possible signal that

428
00:22:20,170 --> 00:22:22,600
we could imagine.

429
00:22:22,600 --> 00:22:24,490
So it's natural to
start there.

430
00:22:24,490 --> 00:22:26,930
So what I want to do now is
think about if this were a

431
00:22:26,930 --> 00:22:29,430
characterization of the system,
and if this were the

432
00:22:29,430 --> 00:22:30,530
input to that system?

433
00:22:30,530 --> 00:22:31,790
What would the output be?

434
00:22:31,790 --> 00:22:32,980
That's after all--

435
00:22:32,980 --> 00:22:35,830
that was the question that
I posed at the beginning.

436
00:22:35,830 --> 00:22:39,380
We would like to build a
representation for a system so

437
00:22:39,380 --> 00:22:43,080
that we can predict the output,
given the input.

438
00:22:43,080 --> 00:22:45,940
So how does that work?

439
00:22:45,940 --> 00:22:51,120
So given the difference
equation, all we need to do is

440
00:22:51,120 --> 00:22:52,380
step through it.

441
00:22:52,380 --> 00:22:53,600
OK, it's trivial.

442
00:22:53,600 --> 00:22:57,980
We call that analyzing
by step by step.

443
00:22:57,980 --> 00:23:03,170
So given the difference
equation, given the input

444
00:23:03,170 --> 00:23:08,080
signal, all we need to do is
sequentially go through the

445
00:23:08,080 --> 00:23:11,070
different values of n, and think
about the implication of

446
00:23:11,070 --> 00:23:13,000
the system on that input.

447
00:23:13,000 --> 00:23:19,300
So if I were to use the value
of n, being minus 1, this

448
00:23:19,300 --> 00:23:22,240
general form of the difference
equation tells me that the

449
00:23:22,240 --> 00:23:27,550
minus 1 value of n for the
output is related by this

450
00:23:27,550 --> 00:23:29,030
difference, with the input.

451
00:23:29,030 --> 00:23:31,300
So y of minus 1 is x of minus
1 minus x of minus 2.

452
00:23:31,300 --> 00:23:33,870

453
00:23:33,870 --> 00:23:39,423
Since both of those are 0, it
says that the output at time

454
00:23:39,423 --> 00:23:41,700
minus 1 is 0.

455
00:23:41,700 --> 00:23:43,310
Trivial, right?

456
00:23:43,310 --> 00:23:44,730
Trivial.

457
00:23:44,730 --> 00:23:47,200
And similarly, we can just
iterate through the solution

458
00:23:47,200 --> 00:23:48,860
to the whole signal.

459
00:23:48,860 --> 00:23:53,640
So y of 0 is x of 0 minus
x of minus 1.

460
00:23:53,640 --> 00:23:57,000
x of 0 is that special
one, that is 1.

461
00:23:57,000 --> 00:24:01,630
So now we get 1 minus
0, which is 1.

462
00:24:01,630 --> 00:24:05,280
y of 1 is x of 1 minus x of 0.

463
00:24:05,280 --> 00:24:08,640
Now the special one is on the
other side of the minus sign,

464
00:24:08,640 --> 00:24:09,890
so the answer is minus 1.

465
00:24:09,890 --> 00:24:13,390

466
00:24:13,390 --> 00:24:16,120
y of 2 is x of 2
minus x of 1 --

467
00:24:16,120 --> 00:24:17,470
they're both 0.

468
00:24:17,470 --> 00:24:21,400
And in fact, all the answers
from now on are going to be 0.

469
00:24:21,400 --> 00:24:25,910
So what I just did is a
trivial example of --

470
00:24:25,910 --> 00:24:30,380
I use a difference equation to
represent a system, and I

471
00:24:30,380 --> 00:24:33,275
figured out the output signal
from the input signal.

472
00:24:33,275 --> 00:24:36,290

473
00:24:36,290 --> 00:24:38,840
That's the method
that we call--

474
00:24:38,840 --> 00:24:41,680
that's the representation for
discrete time systems that we

475
00:24:41,680 --> 00:24:43,220
refer to as difference
equations.

476
00:24:43,220 --> 00:24:46,180
Difference equations
are very powerful.

477
00:24:46,180 --> 00:24:49,570
As we will see, of all the
representations we look at,

478
00:24:49,570 --> 00:24:52,140
difference equations is the most
compact representation.

479
00:24:52,140 --> 00:24:54,650

480
00:24:54,650 --> 00:24:57,120
But there are features of other
kinds of representations

481
00:24:57,120 --> 00:24:58,980
that are also valuable.

482
00:24:58,980 --> 00:25:00,560
So the next representation
I want to look

483
00:25:00,560 --> 00:25:01,810
at is a block diagram.

484
00:25:01,810 --> 00:25:04,280

485
00:25:04,280 --> 00:25:09,130
What I'm trying to show here is
a picture, a diagram, that

486
00:25:09,130 --> 00:25:11,900
represents the same system that
we just analyzed with

487
00:25:11,900 --> 00:25:15,100
difference equations.

488
00:25:15,100 --> 00:25:17,380
Here though, I'm thinking
about it as

489
00:25:17,380 --> 00:25:20,350
a signal flow path.

490
00:25:20,350 --> 00:25:23,620
I'm thinking about what's the
cascade of operations that you

491
00:25:23,620 --> 00:25:29,540
need to do on each sample in
order to get from the input to

492
00:25:29,540 --> 00:25:31,860
the output?

493
00:25:31,860 --> 00:25:34,520
So the difference equation said
every value of the output

494
00:25:34,520 --> 00:25:36,200
should be equal to the
corresponding value of the

495
00:25:36,200 --> 00:25:40,950
input less the value
before that.

496
00:25:40,950 --> 00:25:44,110
I represent that in a block
diagram by saying there's a

497
00:25:44,110 --> 00:25:46,660
straight through path, y of
n is equal to x of n.

498
00:25:46,660 --> 00:25:51,060
The plus just adds the signals
on these two paths.

499
00:25:51,060 --> 00:25:53,360
So y of n is equal to x of n.

500
00:25:53,360 --> 00:25:56,770
Subtract out, because I'm
multiplying by minus 1.

501
00:25:56,770 --> 00:26:00,880
Delay, so I'm getting
the one from before.

502
00:26:00,880 --> 00:26:03,660
So this block diagram just is
a symbolic representation of

503
00:26:03,660 --> 00:26:04,910
that difference equation.

504
00:26:04,910 --> 00:26:07,300

505
00:26:07,300 --> 00:26:08,770
The value of the
block diagram--

506
00:26:08,770 --> 00:26:11,490
we'll see several of them,
but one of them is focus

507
00:26:11,490 --> 00:26:13,180
on signal flow path.

508
00:26:13,180 --> 00:26:17,640
If you want to visualize the
transformation from input to

509
00:26:17,640 --> 00:26:23,990
output, the block diagram can
provide visual insight into

510
00:26:23,990 --> 00:26:27,350
what that transformation
is like.

511
00:26:27,350 --> 00:26:30,950
So as before, if I gave you
this representation rather

512
00:26:30,950 --> 00:26:33,720
than the difference equation,
you could still step by step

513
00:26:33,720 --> 00:26:35,280
and figure out the
way it worked.

514
00:26:35,280 --> 00:26:36,880
It's still easy.

515
00:26:36,880 --> 00:26:39,040
There's one new caveat here.

516
00:26:39,040 --> 00:26:44,130
We have to start the
system in a state.

517
00:26:44,130 --> 00:26:47,130
The state that we will usually
talk about is what we will

518
00:26:47,130 --> 00:26:48,880
call, at rest.

519
00:26:48,880 --> 00:26:54,560
At rest just means all the
outputs of all the delays are

520
00:26:54,560 --> 00:26:55,810
initially 0.

521
00:26:55,810 --> 00:26:58,290

522
00:26:58,290 --> 00:27:01,130
So that specifies the state of
the system at the time the

523
00:27:01,130 --> 00:27:04,280
signal was turned on.

524
00:27:04,280 --> 00:27:07,000
So the system is at rest,
which means that all the

525
00:27:07,000 --> 00:27:10,440
delays start out with
output equal to 0.

526
00:27:10,440 --> 00:27:16,530
So at rest means this delay
has an output of 0.

527
00:27:16,530 --> 00:27:20,390
Well, if I tell you the output
is 0 times 0 for this delay,

528
00:27:20,390 --> 00:27:23,210
then it's a simple matter of
stepping through what is the

529
00:27:23,210 --> 00:27:25,710
output for each corresponding
input?

530
00:27:25,710 --> 00:27:27,420
So if I--

531
00:27:27,420 --> 00:27:29,930
the special value of the delta
function is that it's

532
00:27:29,930 --> 00:27:31,910
1 at the time 0.

533
00:27:31,910 --> 00:27:35,190
So at the time 0, there's
1 coming in.

534
00:27:35,190 --> 00:27:38,700
That 1 makes it through
the adder, adds to 0.

535
00:27:38,700 --> 00:27:42,210
Well, this is 0 because
it was at rest.

536
00:27:42,210 --> 00:27:44,775
So the 1 adds to 0 and
the output becomes 1.

537
00:27:44,775 --> 00:27:47,950

538
00:27:47,950 --> 00:27:50,750
Notice that the 1 also goes
down this path, and goes

539
00:27:50,750 --> 00:27:54,442
through the gain of minus
1 to give me minus 1.

540
00:27:54,442 --> 00:27:57,520
But I'm in step 0.

541
00:27:57,520 --> 00:28:03,730
So at step 0, the output of the
delay is 0, not minus 1.

542
00:28:03,730 --> 00:28:08,880
So the output then, for time
equals 0, is y equals 1.

543
00:28:08,880 --> 00:28:10,450
Just like we solved for the
difference equation--

544
00:28:10,450 --> 00:28:13,250
after all, I'm hypothesizing
that those two systems are the

545
00:28:13,250 --> 00:28:15,940
same, they better give
me the same answer.

546
00:28:15,940 --> 00:28:23,000
So then at the next instant, as
the time index goes from 0

547
00:28:23,000 --> 00:28:26,310
to 1, two things happen.

548
00:28:26,310 --> 00:28:31,130
The input goes from
1 to 0, and the

549
00:28:31,130 --> 00:28:32,820
delay box gets updated.

550
00:28:32,820 --> 00:28:36,470
The delay is now reporting
to me the value

551
00:28:36,470 --> 00:28:38,780
that was at its input.

552
00:28:38,780 --> 00:28:42,180
So the output of the delay,
which had been 0 because it

553
00:28:42,180 --> 00:28:44,170
was at rest, becomes minus 1.

554
00:28:44,170 --> 00:28:48,690

555
00:28:48,690 --> 00:28:50,940
So then what happens?

556
00:28:50,940 --> 00:28:56,300
The 1 goes to 0, the 0 goes to
minus 1, the 0 adds to minus

557
00:28:56,300 --> 00:29:00,130
1, and we get an answer
which is minus 1.

558
00:29:00,130 --> 00:29:05,010

559
00:29:05,010 --> 00:29:09,390
Then the input becomes 0.

560
00:29:09,390 --> 00:29:12,120
That 0 comes down here,
the minus 1 goes to 0.

561
00:29:12,120 --> 00:29:15,290
We end up with 0 being added to
0, and the next answer is

562
00:29:15,290 --> 00:29:18,360
0, et cetera.

563
00:29:18,360 --> 00:29:21,620
So the idea then, is that you
can step through the block

564
00:29:21,620 --> 00:29:23,610
diagram representation, just
like you would a difference

565
00:29:23,610 --> 00:29:26,230
equation, it's just that now
we're thinking about these

566
00:29:26,230 --> 00:29:31,270
blocks characterizing the
system, rather than thinking

567
00:29:31,270 --> 00:29:34,745
of math as characterizing
the system.

568
00:29:34,745 --> 00:29:37,690

569
00:29:37,690 --> 00:29:41,080
Why on earth would
you do that?

570
00:29:41,080 --> 00:29:42,720
What's good and bad?

571
00:29:42,720 --> 00:29:46,350
What's the relative merits of
difference equations verses

572
00:29:46,350 --> 00:29:48,230
block diagrams?

573
00:29:48,230 --> 00:29:50,830
Take 30 seconds, talk to your
neighbor, figure out some good

574
00:29:50,830 --> 00:29:51,790
feature of each.

575
00:29:51,790 --> 00:29:53,040
AUDIENCE: [INAUDIBLE]

576
00:29:53,040 --> 00:31:16,200

577
00:31:16,200 --> 00:31:18,060
PROFESSOR: OK, we'll start
with the easy one.

578
00:31:18,060 --> 00:31:20,340
What's a feature, what's a
property of the difference

579
00:31:20,340 --> 00:31:22,421
equation that makes
it very good.

580
00:31:22,421 --> 00:31:25,367
I already said it, so.

581
00:31:25,367 --> 00:31:26,840
What's good about the
difference equation?

582
00:31:26,840 --> 00:31:27,822
Yeah.

583
00:31:27,822 --> 00:31:30,280
AUDIENCE: They can be solved
mathematically.

584
00:31:30,280 --> 00:31:33,780
PROFESSOR: They can be solved
mathematically.

585
00:31:33,780 --> 00:31:36,300
The block diagram could
be solved, maybe not

586
00:31:36,300 --> 00:31:38,350
mathematically, but kind of.

587
00:31:38,350 --> 00:31:40,250
Could you refine that
a little more?

588
00:31:40,250 --> 00:31:42,730
What's special about difference
equations that's

589
00:31:42,730 --> 00:31:44,045
different from block diagrams?

590
00:31:44,045 --> 00:31:47,698

591
00:31:47,698 --> 00:31:51,020
Oh come on, I said it.

592
00:31:51,020 --> 00:31:51,680
AUDIENCE: Use math?

593
00:31:51,680 --> 00:31:54,013
PROFESSOR: They use
math, yes yes.

594
00:31:54,013 --> 00:31:57,380
They're concise, a
little, right?

595
00:31:57,380 --> 00:32:00,410
It's a very simple expression
to say that.

596
00:32:00,410 --> 00:32:03,710
It's by contrast, a bit more
complicated to draw this

597
00:32:03,710 --> 00:32:04,290
picture, right?

598
00:32:04,290 --> 00:32:06,450
It's mathematically
concise, right?

599
00:32:06,450 --> 00:32:08,500
It's completely accurate,

600
00:32:08,500 --> 00:32:14,070
self-contained, concise, small.

601
00:32:14,070 --> 00:32:17,370
It's a very concise
representation of a system.

602
00:32:17,370 --> 00:32:19,210
So why would we want to
use block diagrams?

603
00:32:19,210 --> 00:32:21,630
Can anybody think of any good
reason for block diagrams

604
00:32:21,630 --> 00:32:24,965
other than Freeman's up front
saying, do block diagrams?

605
00:32:24,965 --> 00:32:26,360
AUDIENCE: Electrical
engineering?

606
00:32:26,360 --> 00:32:28,685
PROFESSOR: Electrical
engineering.

607
00:32:28,685 --> 00:32:31,980
There should be a deeper
reason, I would hope.

608
00:32:31,980 --> 00:32:33,300
I don't disagree with
that reason.

609
00:32:33,300 --> 00:32:36,270

610
00:32:36,270 --> 00:32:39,200
Why do electrical engineers
like this?

611
00:32:39,200 --> 00:32:40,120
Yes.

612
00:32:40,120 --> 00:32:42,880
AUDIENCE: It's a more physical
representation of this.

613
00:32:42,880 --> 00:32:44,980
PROFESSOR: It's more physical?

614
00:32:44,980 --> 00:32:47,207
Is there anything that
you can see that you

615
00:32:47,207 --> 00:32:48,457
can't see in math?

616
00:32:48,457 --> 00:32:52,900

617
00:32:52,900 --> 00:32:54,385
Yes.

618
00:32:54,385 --> 00:32:56,035
AUDIENCE: In the way that you're
actually going to be

619
00:32:56,035 --> 00:32:56,365
programming it.

620
00:32:56,365 --> 00:32:59,335
Like, you're gonna make the
delay machine, you're gonna

621
00:32:59,335 --> 00:33:01,810
make the state machine that
multiplies them by negative 1

622
00:33:01,810 --> 00:33:03,790
and you're gonna see how
to connect them.

623
00:33:03,790 --> 00:33:05,275
PROFESSOR: That's a
really good point.

624
00:33:05,275 --> 00:33:10,770
It's kind of isomorphic
to the implementation.

625
00:33:10,770 --> 00:33:12,630
Everybody get that?

626
00:33:12,630 --> 00:33:14,850
It's kind of a picture
of the way you

627
00:33:14,850 --> 00:33:18,100
would build the system.

628
00:33:18,100 --> 00:33:21,130
Along those lines, there's
some bit of information--

629
00:33:21,130 --> 00:33:23,140
there's actually more
information in this one, than

630
00:33:23,140 --> 00:33:25,346
there is in that one.

631
00:33:25,346 --> 00:33:31,690
There is exactly one bit more
information in the block

632
00:33:31,690 --> 00:33:32,940
diagram, what's that bit?

633
00:33:32,940 --> 00:33:38,520

634
00:33:38,520 --> 00:33:39,876
AUDIENCE: Delay?

635
00:33:39,876 --> 00:33:41,870
PROFESSOR: Delay?

636
00:33:41,870 --> 00:33:44,960
There's kind of delay
by the n minus 1.

637
00:33:44,960 --> 00:33:46,274
Yeah.

638
00:33:46,274 --> 00:33:47,524
AUDIENCE: [UNINTELLIGIBLE]

639
00:33:47,524 --> 00:33:49,648

640
00:33:49,648 --> 00:33:52,540
PROFESSOR: The input and
output are explicit.

641
00:33:52,540 --> 00:33:53,986
Yes.

642
00:33:53,986 --> 00:33:58,980
The arrows are the
big difference.

643
00:33:58,980 --> 00:34:01,920
You can't tell from the
difference equation, what's

644
00:34:01,920 --> 00:34:05,470
the input and the output?

645
00:34:05,470 --> 00:34:08,020
You can tell from the block
diagram, what is the input and

646
00:34:08,020 --> 00:34:12,080
the output by the direction
of the arrows.

647
00:34:12,080 --> 00:34:14,205
So there's more information
in the block diagram.

648
00:34:14,205 --> 00:34:17,870

649
00:34:17,870 --> 00:34:19,949
There's another way of thinking
about it, and this is

650
00:34:19,949 --> 00:34:21,929
kind of a summary of several
comments that

651
00:34:21,929 --> 00:34:23,540
came from the audience.

652
00:34:23,540 --> 00:34:25,860
The difference equation
is declarative.

653
00:34:25,860 --> 00:34:29,555
It tells you a true statement
about what the system will do.

654
00:34:29,555 --> 00:34:32,820

655
00:34:32,820 --> 00:34:35,790
The block diagram
is imperative.

656
00:34:35,790 --> 00:34:39,909
It tells you what to do now.

657
00:34:39,909 --> 00:34:41,630
Take the input, put
into an adder.

658
00:34:41,630 --> 00:34:43,370
Take the input, multiply
by minus 1.

659
00:34:43,370 --> 00:34:44,239
Put it into a delay.

660
00:34:44,239 --> 00:34:46,530
Take the delay output,
put it into an adder.

661
00:34:46,530 --> 00:34:52,120
The representation with a block
diagram is imperative.

662
00:34:52,120 --> 00:34:54,889
It tells you what to do.

663
00:34:54,889 --> 00:34:58,400
So there's extra information,
but it comes at a cost.

664
00:34:58,400 --> 00:35:00,250
It's a more complicated
representation.

665
00:35:00,250 --> 00:35:06,820
It's a whole picture instead
of just an equation.

666
00:35:06,820 --> 00:35:09,260
What we'd like to do, and what
I'm going to do now, is

667
00:35:09,260 --> 00:35:11,980
develop a different mathematical
approach where

668
00:35:11,980 --> 00:35:18,050
you get a difference equation
that has the same properties

669
00:35:18,050 --> 00:35:24,880
of concision, the same
conciseness, but also contains

670
00:35:24,880 --> 00:35:28,860
all of the information that
was in the block diagram.

671
00:35:28,860 --> 00:35:32,390
And the way to do that is
to change our focus.

672
00:35:32,390 --> 00:35:34,960

673
00:35:34,960 --> 00:35:38,940
And this is the big abstraction
of the day.

674
00:35:38,940 --> 00:35:43,370
Change our focus from thinking
about samples, to thinking

675
00:35:43,370 --> 00:35:45,430
about signals.

676
00:35:45,430 --> 00:35:50,340
Stop thinking about x of n,
start thinking about the

677
00:35:50,340 --> 00:35:53,310
input signal x.

678
00:35:53,310 --> 00:35:58,360
This is the same kind of
lumping that was key to

679
00:35:58,360 --> 00:36:01,770
abstraction in Python.

680
00:36:01,770 --> 00:36:04,390
Put all the interesting data
together into a list, put all

681
00:36:04,390 --> 00:36:07,620
the interesting operations
together into a definition.

682
00:36:07,620 --> 00:36:10,520
Here put all of the interesting
samples together

683
00:36:10,520 --> 00:36:13,890
into one signal.

684
00:36:13,890 --> 00:36:17,980
So what we want to do, is
develop a math by which we can

685
00:36:17,980 --> 00:36:22,570
operate on signals instead
of samples.

686
00:36:22,570 --> 00:36:26,500
So what I'm going to do is
replace the representation x

687
00:36:26,500 --> 00:36:31,180
of n, little x of n, with cap-X.
Cap-X means, all of the

688
00:36:31,180 --> 00:36:36,830
n's, it's the signal X. Cap-Y
means the signal Y. And I'm

689
00:36:36,830 --> 00:36:38,300
going to reinterpret
all the boxes.

690
00:36:38,300 --> 00:36:41,860

691
00:36:41,860 --> 00:36:46,370
This box means, take this
signal, the whole thing, all n

692
00:36:46,370 --> 00:36:51,660
values on it, multiply it sample
by sample, by minus 1.

693
00:36:51,660 --> 00:36:55,710
Flip the whole signal
upside down.

694
00:36:55,710 --> 00:36:58,240
So I'm going to reinterpret all
of the operations on the

695
00:36:58,240 --> 00:37:02,220
block diagram in terms of
signals, rather than samples.

696
00:37:02,220 --> 00:37:05,700

697
00:37:05,700 --> 00:37:07,910
To do that, I need a
representation--

698
00:37:07,910 --> 00:37:12,610
a mathematical representation,
for the delay box.

699
00:37:12,610 --> 00:37:17,730
And I'm going to call that R,
the right shift operator.

700
00:37:17,730 --> 00:37:22,700
If you apply the right shift
operator to a single X, it

701
00:37:22,700 --> 00:37:27,040
takes the whole signal X and
shifts it to the right one.

702
00:37:27,040 --> 00:37:29,830
That's all it does.

703
00:37:29,830 --> 00:37:35,220
So I'm going to say Y equals
R applied to X, or more

704
00:37:35,220 --> 00:37:37,970
abbreviated, RX.

705
00:37:37,970 --> 00:37:42,760
Simply says, let Y represent the
signal that is the same as

706
00:37:42,760 --> 00:37:45,190
X, except every sample was
shifted to the right.

707
00:37:45,190 --> 00:37:48,890
The entire signal was shifted
to the right.

708
00:37:48,890 --> 00:37:50,990
That's going to let me
represent this block

709
00:37:50,990 --> 00:37:54,680
diagram this way.

710
00:37:54,680 --> 00:37:56,570
Y--

711
00:37:56,570 --> 00:38:01,690
the whole signal Y, is the sum
of the whole signal X,

712
00:38:01,690 --> 00:38:10,970
subtract out R applied to X.
Or, even more concisely,

713
00:38:10,970 --> 00:38:20,140
calculate Y by applying to
X the operator 1 minus R.

714
00:38:20,140 --> 00:38:21,950
So I'm thinking now
of an operator.

715
00:38:21,950 --> 00:38:26,760
An operator is not something
that works on a number.

716
00:38:26,760 --> 00:38:31,730
Operations work on numbers,
operators operate on signals.

717
00:38:31,730 --> 00:38:33,880
So I'm thinking about
operator expression.

718
00:38:33,880 --> 00:38:37,730
I'm going to try to formulate
the transformation from the

719
00:38:37,730 --> 00:38:42,150
input to the output in
terms of operators.

720
00:38:42,150 --> 00:38:46,300
The way I take X, which is the
input, and turn it into Y, is

721
00:38:46,300 --> 00:38:53,480
to operate on it with the
operator 1 minus R.

722
00:38:53,480 --> 00:38:57,110
OK, just to see that you're with
me, connecting signals

723
00:38:57,110 --> 00:39:00,770
and samples, assume the
Y is RX, which of the

724
00:39:00,770 --> 00:39:03,700
following is also true?

725
00:39:03,700 --> 00:39:05,020
Take 30 seconds, talk
to your neighbor.

726
00:39:05,020 --> 00:39:06,755
Figure out some number
-- (1) through (5).

727
00:39:06,755 --> 00:39:08,005
AUDIENCE: [INAUDIBLE]

728
00:39:08,005 --> 00:39:39,022

729
00:39:39,022 --> 00:41:33,350

730
00:41:33,350 --> 00:41:36,980
PROFESSOR: OK, so which
representation works best?

731
00:41:36,980 --> 00:41:39,882
(1), (2), (3), (4), or
none of the above?

732
00:41:39,882 --> 00:41:41,754
Everybody raise a hand,
tell me some number.

733
00:41:41,754 --> 00:41:45,030

734
00:41:45,030 --> 00:41:47,150
OK, virtually 100% correct.

735
00:41:47,150 --> 00:41:51,750
The answer was (2), why
is the answer (2)?

736
00:41:51,750 --> 00:41:53,225
Can somebody explain
that concisely?

737
00:41:53,225 --> 00:41:57,636

738
00:41:57,636 --> 00:41:58,480
No no,no.

739
00:41:58,480 --> 00:42:00,170
I asked that wrong, of
course everybody

740
00:42:00,170 --> 00:42:01,410
can explain it concisely.

741
00:42:01,410 --> 00:42:03,730
Do I have a volunteer to
explain it concisely?

742
00:42:03,730 --> 00:42:08,326

743
00:42:08,326 --> 00:42:09,254
Yes.

744
00:42:09,254 --> 00:42:12,760
AUDIENCE: The R operator just
shifts all of the values in X

745
00:42:12,760 --> 00:42:14,072
of n to the right.

746
00:42:14,072 --> 00:42:17,030
So you just add 1 to each
of these basically?

747
00:42:17,030 --> 00:42:19,000
PROFESSOR: So you think about
it-- so a good way to think

748
00:42:19,000 --> 00:42:22,070
about this is to think
about simple cases.

749
00:42:22,070 --> 00:42:22,450
Right?

750
00:42:22,450 --> 00:42:24,870
That's the same thing I
talked about earlier.

751
00:42:24,870 --> 00:42:26,000
What's a simple case?

752
00:42:26,000 --> 00:42:28,030
Well what if X--

753
00:42:28,030 --> 00:42:32,220
let's imagine that
X is simple.

754
00:42:32,220 --> 00:42:36,720
So let's say that X
looks like that.

755
00:42:36,720 --> 00:42:40,340
So X is delta.

756
00:42:40,340 --> 00:42:43,510
What would happen, what
is the signal RX?

757
00:42:43,510 --> 00:42:48,250

758
00:42:48,250 --> 00:42:49,845
It's a right shift operator.

759
00:42:49,845 --> 00:42:51,888
So what does the signal
RX look like?

760
00:42:51,888 --> 00:42:55,030

761
00:42:55,030 --> 00:42:57,090
Shifted to the right, right?

762
00:42:57,090 --> 00:42:58,600
That's the whole point.

763
00:42:58,600 --> 00:43:04,660
So the right shift operator
gives you that signal, and

764
00:43:04,660 --> 00:43:13,250
we've said that that's Y. So is
it true that Y of n is X of

765
00:43:13,250 --> 00:43:16,330
n, for all n?

766
00:43:16,330 --> 00:43:17,790
No.

767
00:43:17,790 --> 00:43:20,440
Is it true that Y of (n
plus 1) is equal to X

768
00:43:20,440 --> 00:43:22,560
of n for all n?

769
00:43:22,560 --> 00:43:24,075
Well, is it true
for n equals 0?

770
00:43:24,075 --> 00:43:32,940

771
00:43:32,940 --> 00:43:41,170
So if we did n equals 0 we get Y
of 1, which happens to be 1.

772
00:43:41,170 --> 00:43:43,645
And X of 0, which also
happens to be 1.

773
00:43:43,645 --> 00:43:46,380

774
00:43:46,380 --> 00:43:50,890
And if we choose any other
n, we would get two 0's.

775
00:43:50,890 --> 00:43:54,100
So at least for this simple
case, and it seems to be true,

776
00:43:54,100 --> 00:43:58,510
and if you think about building
upon this simple

777
00:43:58,510 --> 00:44:00,480
case, you can convince yourself
that number (2) is

778
00:44:00,480 --> 00:44:01,450
always true.

779
00:44:01,450 --> 00:44:04,970
And in fact, the general rule
is going to be that the left

780
00:44:04,970 --> 00:44:07,910
hand side has to have a number
that's bigger than

781
00:44:07,910 --> 00:44:10,680
the right hand side.

782
00:44:10,680 --> 00:44:12,270
Which is only true
for number (2).

783
00:44:12,270 --> 00:44:15,670

784
00:44:15,670 --> 00:44:20,420
So the idea then, is that by
changing our focus, by looking

785
00:44:20,420 --> 00:44:24,020
not at samples, but looking
instead at signals, we can

786
00:44:24,020 --> 00:44:29,520
generate an algebra that looks
for all the world like

787
00:44:29,520 --> 00:44:31,410
difference equations.

788
00:44:31,410 --> 00:44:35,940
Except it knows the direction
from the input to the output.

789
00:44:35,940 --> 00:44:39,210
So it's more powerful.

790
00:44:39,210 --> 00:44:42,890
And in fact, this new algebra
is going to obey some very

791
00:44:42,890 --> 00:44:47,920
simple properties which we
can get a hint at here.

792
00:44:47,920 --> 00:44:51,180
If we were to cascade two
systems, imagine this system

793
00:44:51,180 --> 00:44:53,930
which looks just like the system
we've been looking at,

794
00:44:53,930 --> 00:44:57,610
but it's cascaded
with a clone.

795
00:44:57,610 --> 00:44:59,845
The question is, what would be
the behavior of that cascade?

796
00:44:59,845 --> 00:45:02,350

797
00:45:02,350 --> 00:45:06,250
Well, according to our operator
representation, this

798
00:45:06,250 --> 00:45:15,600
Y1 signal is just the 1 minus
R operator applied to X.

799
00:45:15,600 --> 00:45:20,990
Analogously, the Y2 signal
should be a similar 1 minus R

800
00:45:20,990 --> 00:45:26,540
operator applied to the Y1
signal, which gives us a very

801
00:45:26,540 --> 00:45:29,065
concise representation
for the cascade.

802
00:45:29,065 --> 00:45:31,800

803
00:45:31,800 --> 00:45:34,880
The point of the slide is that
the operator representation

804
00:45:34,880 --> 00:45:38,280
gives us a representation that
is just as compact as

805
00:45:38,280 --> 00:45:39,530
difference equations.

806
00:45:39,530 --> 00:45:41,970

807
00:45:41,970 --> 00:45:46,050
It has other features, that it
can be manipulated just like

808
00:45:46,050 --> 00:45:48,910
difference equations.

809
00:45:48,910 --> 00:45:52,070
So if we continue with this same
example and try to think

810
00:45:52,070 --> 00:45:57,850
of the transformation on a
sample level, we could say

811
00:45:57,850 --> 00:46:05,585
that Y2 is Y1, the straight
path, minus Y1 delayed.

812
00:46:05,585 --> 00:46:08,160

813
00:46:08,160 --> 00:46:12,510
But then we could substitute for
Y1 of n, that Y1 of n is X

814
00:46:12,510 --> 00:46:19,980
of n, this path, subtract
X of (n minus 1).

815
00:46:19,980 --> 00:46:24,370
Similarly, collapse, and we
get a simple expression.

816
00:46:24,370 --> 00:46:27,340

817
00:46:27,340 --> 00:46:29,640
Now if we think about that same
sequence of operations in

818
00:46:29,640 --> 00:46:36,090
operator notation, we get a
much simpler expression.

819
00:46:36,090 --> 00:46:42,080
Throw away the index arithmetic,
it's just R. So

820
00:46:42,080 --> 00:46:47,970
the Y2 operator is 1 minus R
applied to the Y1 signal.

821
00:46:47,970 --> 00:46:51,870
The Y1 signal is 1 minus R
applied to the X signal.

822
00:46:51,870 --> 00:46:57,180
The total is 1 minus R the
operator squared, which by

823
00:46:57,180 --> 00:47:02,320
polynomial math is just 1 minus
2R plus R squared, the

824
00:47:02,320 --> 00:47:04,870
same thing we got there.

825
00:47:04,870 --> 00:47:08,560
The point is, the operator
notation is just as compact as

826
00:47:08,560 --> 00:47:10,515
the difference equation
representation.

827
00:47:10,515 --> 00:47:13,400

828
00:47:13,400 --> 00:47:14,835
And it contains all
the information

829
00:47:14,835 --> 00:47:18,110
that's in block diagrams.

830
00:47:18,110 --> 00:47:23,410
And it's just as easy to
manipulate as a polynomial.

831
00:47:23,410 --> 00:47:27,630
So it's got lots of features
that make it superior to

832
00:47:27,630 --> 00:47:30,450
difference equations.

833
00:47:30,450 --> 00:47:34,550
The most important of which,
is you will be able to

834
00:47:34,550 --> 00:47:39,670
understand all systems that we
represent using the R operator

835
00:47:39,670 --> 00:47:41,970
using polynomial arithmetic,
something you

836
00:47:41,970 --> 00:47:44,870
learned in high school.

837
00:47:44,870 --> 00:47:47,300
There's nothing new here.

838
00:47:47,300 --> 00:47:48,290
That's what we like.

839
00:47:48,290 --> 00:47:53,160
Representations that simplify
the task of finding an answer.

840
00:47:53,160 --> 00:47:56,500
We'll be able to find the
answer to these operator

841
00:47:56,500 --> 00:47:58,640
expressions by treating
them as polynomials.

842
00:47:58,640 --> 00:48:04,010

843
00:48:04,010 --> 00:48:06,560
So you can get a feeling for the
way that works by looking

844
00:48:06,560 --> 00:48:07,650
here, the power of this.

845
00:48:07,650 --> 00:48:10,580
So the power here is that, among
other things, you'll be

846
00:48:10,580 --> 00:48:15,530
able to use the operator
representation to prove

847
00:48:15,530 --> 00:48:18,050
equivalences.

848
00:48:18,050 --> 00:48:21,010
The idea is that here's a
system that we looked at

849
00:48:21,010 --> 00:48:26,750
before, that was the cascade of
two simple delay systems.

850
00:48:26,750 --> 00:48:31,980
Here's a somewhat more
complicated, somewhat simpler,

851
00:48:31,980 --> 00:48:34,890
representation.

852
00:48:34,890 --> 00:48:38,520
The point is, it's different.

853
00:48:38,520 --> 00:48:41,490
And if we compare the operator
representations for the two,

854
00:48:41,490 --> 00:48:44,660
we see that they are the same.

855
00:48:44,660 --> 00:48:47,530
And what I'm about to prove,
is that when the operator

856
00:48:47,530 --> 00:48:51,120
representations are the same,
the systems represent the same

857
00:48:51,120 --> 00:48:51,940
transformations--

858
00:48:51,940 --> 00:48:54,910
provided they all
start at rest.

859
00:48:54,910 --> 00:48:57,100
The provided is important.

860
00:48:57,100 --> 00:49:01,160
Obviously since they have
different delays in them, if

861
00:49:01,160 --> 00:49:06,090
the delays didn't all start out
at 0, the differences in

862
00:49:06,090 --> 00:49:08,890
the delays could propagate
into the output.

863
00:49:08,890 --> 00:49:11,880
So all of the statements that
I'm making are premised on the

864
00:49:11,880 --> 00:49:13,455
idea of initial rest.

865
00:49:13,455 --> 00:49:16,580

866
00:49:16,580 --> 00:49:19,680
The other important thing to
remember about operators is

867
00:49:19,680 --> 00:49:24,510
that it's a higher level
of abstraction.

868
00:49:24,510 --> 00:49:28,450
We can think about the operator
as composing things,

869
00:49:28,450 --> 00:49:30,950
but the things that are composed
are whole signals,

870
00:49:30,950 --> 00:49:32,220
not samples.

871
00:49:32,220 --> 00:49:34,200
And here's an illustration of
how to think about that

872
00:49:34,200 --> 00:49:36,150
previous example.

873
00:49:36,150 --> 00:49:38,740
How do you think about this
transformation, 1 minus 2R

874
00:49:38,740 --> 00:49:40,710
plus R squared.

875
00:49:40,710 --> 00:49:43,730
What happens when you apply
that operator to an

876
00:49:43,730 --> 00:49:45,830
input signal X?

877
00:49:45,830 --> 00:49:50,020
Well let's say that X was
our unit sample signal.

878
00:49:50,020 --> 00:49:53,570
In order to apply this operator
1 minus 2R plus R

879
00:49:53,570 --> 00:49:56,960
squared, all we need to do is
think about each component.

880
00:49:56,960 --> 00:50:03,120
1 times X is X. Minus 2R applied
to X is minus 2RX.

881
00:50:03,120 --> 00:50:07,790
Plus R squared X is just plus
R squared X. So we start out

882
00:50:07,790 --> 00:50:12,170
with X, which is a unit sample,
minus 2RX means shift

883
00:50:12,170 --> 00:50:16,540
it to the right and multiply
by minus 2.

884
00:50:16,540 --> 00:50:21,390
Shift it to the right,
multiply by minus 2.

885
00:50:21,390 --> 00:50:26,050
Plus R squared X means shift
it twice to the right.

886
00:50:26,050 --> 00:50:30,430
So the result, this operator
1 minus 2R plus R squared

887
00:50:30,430 --> 00:50:33,230
applied to X is just the
sum of these things.

888
00:50:33,230 --> 00:50:36,410
So you can think about the
operator expression, it's just

889
00:50:36,410 --> 00:50:40,680
like algebra, except that
the elements are

890
00:50:40,680 --> 00:50:42,110
signals, not samples.

891
00:50:42,110 --> 00:50:46,200

892
00:50:46,200 --> 00:50:49,220
And as I alluded previously,
you can make powerful

893
00:50:49,220 --> 00:50:52,680
statements about the way these
operators work which map

894
00:50:52,680 --> 00:50:57,100
isomorphically onto
polynomial math.

895
00:50:57,100 --> 00:51:01,160
So for example, it's easy to
prove that if you were to

896
00:51:01,160 --> 00:51:10,130
cascade the 1 minus R operator
with R. So start with X, apply

897
00:51:10,130 --> 00:51:20,580
1 minus R. Start with X, apply
1 minus R. Then apply R.

898
00:51:20,580 --> 00:51:24,210
That's going to result in the
same signal, assuming initial

899
00:51:24,210 --> 00:51:29,390
rest, as if you were to
flip those operators.

900
00:51:29,390 --> 00:51:34,540
The way I can see that is by
thinking about signal flow.

901
00:51:34,540 --> 00:51:36,780
You'll remember that I said,
one of the features, one of

902
00:51:36,780 --> 00:51:39,610
the powers of the block diagram
representation is that

903
00:51:39,610 --> 00:51:42,100
we can look at signal
flow paths.

904
00:51:42,100 --> 00:51:45,920
We can use that as a way
of proving things.

905
00:51:45,920 --> 00:51:48,750
This system has two signal flow
paths, the one that goes

906
00:51:48,750 --> 00:51:52,010
straight through that way, and
the one that goes down this

907
00:51:52,010 --> 00:51:53,260
way and up that way.

908
00:51:53,260 --> 00:51:56,240

909
00:51:56,240 --> 00:51:59,370
Because of the addition, all it
does-- the adder just adds

910
00:51:59,370 --> 00:52:01,390
the result of those
two flow paths.

911
00:52:01,390 --> 00:52:04,960
So the first flow path
introduces one delay, the

912
00:52:04,960 --> 00:52:09,620
second flow path inverts
and puts in two delays.

913
00:52:09,620 --> 00:52:13,910
So there are two ways to get
from the input to the output.

914
00:52:13,910 --> 00:52:16,420
Similarly here, there are two
ways to get from the input to

915
00:52:16,420 --> 00:52:17,100
the output.

916
00:52:17,100 --> 00:52:19,450
One of them goes through a delay
and then goes through

917
00:52:19,450 --> 00:52:21,480
the adder, the other
goes through two

918
00:52:21,480 --> 00:52:23,840
delays at a minus 1.

919
00:52:23,840 --> 00:52:26,480
But that's the same two
signal paths that

920
00:52:26,480 --> 00:52:28,130
were in the top one.

921
00:52:28,130 --> 00:52:31,150
So that's a way of using the
block diagram to prove a

922
00:52:31,150 --> 00:52:33,890
relationship about
the operator.

923
00:52:33,890 --> 00:52:38,040
What I've just showed, is
that the operators obey

924
00:52:38,040 --> 00:52:40,180
commutativity.

925
00:52:40,180 --> 00:52:42,780
So what I was able to show is
that I can commute these two

926
00:52:42,780 --> 00:52:43,940
operators--

927
00:52:43,940 --> 00:52:46,105
doing a general proof is
slightly more complicated, I

928
00:52:46,105 --> 00:52:48,140
proved it in a special case.

929
00:52:48,140 --> 00:52:49,890
But the general case
works too.

930
00:52:49,890 --> 00:52:52,930

931
00:52:52,930 --> 00:52:57,600
Just like polynomials,
operators commute.

932
00:52:57,600 --> 00:53:01,640
And I indicated why you should
think that's true by thinking

933
00:53:01,640 --> 00:53:04,630
about signal flow paths.

934
00:53:04,630 --> 00:53:07,220
Multiplication distributes
over addition.

935
00:53:07,220 --> 00:53:10,910
I apologize, the diagram
in your notes is wrong.

936
00:53:10,910 --> 00:53:12,770
This is right.

937
00:53:12,770 --> 00:53:14,420
I will always post the notes--

938
00:53:14,420 --> 00:53:17,910
I get up in the morning, I
make coffee, I read the

939
00:53:17,910 --> 00:53:20,090
lecture notes, and I say,
oh my goodness,

940
00:53:20,090 --> 00:53:22,150
there's a wrong figure.

941
00:53:22,150 --> 00:53:24,310
In this particular case, one of
the staff members wrote me

942
00:53:24,310 --> 00:53:26,180
an email and said, Hey
Freeman, your slides,

943
00:53:26,180 --> 00:53:27,590
something or other, is wrong.

944
00:53:27,590 --> 00:53:29,560
He was right.

945
00:53:29,560 --> 00:53:32,110
So this is the right diagram.

946
00:53:32,110 --> 00:53:36,380
So the idea is that if
multiplication distributes

947
00:53:36,380 --> 00:53:39,840
over addition, we should expect
that R applied to 1

948
00:53:39,840 --> 00:53:43,640
minus R, would give
R minus R squared.

949
00:53:43,640 --> 00:53:46,730
And we can again get a feeling
for why that ought to be true

950
00:53:46,730 --> 00:53:49,170
by thinking about the
signal flow paths.

951
00:53:49,170 --> 00:53:52,090
The two signals flow paths that
represent-- so the signal

952
00:53:52,090 --> 00:53:54,740
flow path that represents here,
this says take the 1

953
00:53:54,740 --> 00:53:58,850
minus R operator and apply it
to X, then apply R to the 1

954
00:53:58,850 --> 00:54:02,000
minus R operator, result.

955
00:54:02,000 --> 00:54:06,550
As opposed to this one says,
apply the R operator to X,

956
00:54:06,550 --> 00:54:08,890
then apply the R squared
operator to the X

957
00:54:08,890 --> 00:54:10,270
and subtract them.

958
00:54:10,270 --> 00:54:12,720
If you think about the signal
flow paths through those two

959
00:54:12,720 --> 00:54:15,520
systems, they're also the same
two signal flow paths.

960
00:54:15,520 --> 00:54:18,380

961
00:54:18,380 --> 00:54:21,270
And here's a more complicated
example that shows

962
00:54:21,270 --> 00:54:22,520
associativity.

963
00:54:22,520 --> 00:54:24,300

964
00:54:24,300 --> 00:54:28,940
You can think through
that, same idea.

965
00:54:28,940 --> 00:54:31,080
The reason that the idea--

966
00:54:31,080 --> 00:54:34,540
the big important point is,
difference equations are a

967
00:54:34,540 --> 00:54:36,960
good representation for
discrete time systems.

968
00:54:36,960 --> 00:54:38,240
They're mathematically
compact.

969
00:54:38,240 --> 00:54:40,750
Block diagrams are a good
representation, but they have

970
00:54:40,750 --> 00:54:42,210
more information.

971
00:54:42,210 --> 00:54:44,150
They tell you what is the input,
what is the output, and

972
00:54:44,150 --> 00:54:48,010
what are all the different flow
paths through the system?

973
00:54:48,010 --> 00:54:53,200
Operators kind of combine the
best features of both.

974
00:54:53,200 --> 00:54:55,460
It's mathematically concise,
it tells you which is the

975
00:54:55,460 --> 00:54:58,470
input and which is the output.

976
00:54:58,470 --> 00:55:01,050
And you can visualize all the
flow paths by thinking about

977
00:55:01,050 --> 00:55:06,110
all the ads in the operator
expression.

978
00:55:06,110 --> 00:55:08,470
OK, to make sure that
everybody's up with me, how

979
00:55:08,470 --> 00:55:12,240
many of the following systems
are equivalent?

980
00:55:12,240 --> 00:55:13,350
You have 30 seconds.

981
00:55:13,350 --> 00:55:14,600
AUDIENCE: [INAUDIBLE]

982
00:55:14,600 --> 00:57:04,520

983
00:57:04,520 --> 00:57:06,380
PROFESSOR: OK, so how many
of those are equivalent?

984
00:57:06,380 --> 00:57:11,440

985
00:57:11,440 --> 00:57:13,630
More hands, more hands.

986
00:57:13,630 --> 00:57:15,600
Not necessarily more fingers,
but more hands.

987
00:57:15,600 --> 00:57:21,480

988
00:57:21,480 --> 00:57:28,410
OK, about 75% correct,
roughly speaking.

989
00:57:28,410 --> 00:57:33,840
OK, how many distinct signal
flow paths are going through

990
00:57:33,840 --> 00:57:35,090
the first system?

991
00:57:35,090 --> 00:57:37,812

992
00:57:37,812 --> 00:57:41,291
How many distinct signal
flow paths can you see?

993
00:57:41,291 --> 00:57:44,780

994
00:57:44,780 --> 00:57:46,030
Well, here's one.

995
00:57:46,030 --> 00:57:48,744

996
00:57:48,744 --> 00:57:51,630
How many more are there?

997
00:57:51,630 --> 00:57:53,073
AUDIENCE: Three.

998
00:57:53,073 --> 00:57:54,035
PROFESSOR: Three more.

999
00:57:54,035 --> 00:58:03,822
So here's one, here's one,
here's one, and here's one.

1000
00:58:03,822 --> 00:58:06,870
All you need to do to think
about this system, is think

1001
00:58:06,870 --> 00:58:12,430
about all of the signal flow
paths through all of them,

1002
00:58:12,430 --> 00:58:18,440
make a sum, and see how many
of them have the same sum.

1003
00:58:18,440 --> 00:58:23,220
So the path with the greatest
delay through this path is two

1004
00:58:23,220 --> 00:58:24,910
times two delay delay.

1005
00:58:24,910 --> 00:58:29,390
Two delays with a
multiply by 4.

1006
00:58:29,390 --> 00:58:31,010
What's the path with
the biggest delay

1007
00:58:31,010 --> 00:58:34,140
through this one?

1008
00:58:34,140 --> 00:58:37,160
Also straight through.

1009
00:58:37,160 --> 00:58:39,835
Also delay of two, also
a coefficient of 4.

1010
00:58:39,835 --> 00:58:43,160

1011
00:58:43,160 --> 00:58:44,840
How about this one?

1012
00:58:44,840 --> 00:58:46,090
So that's this way.

1013
00:58:46,090 --> 00:58:49,020

1014
00:58:49,020 --> 00:58:52,640
So they all have the same paths
with maximum delay.

1015
00:58:52,640 --> 00:58:57,190
The delay is 2 and the
coefficient is 4.

1016
00:58:57,190 --> 00:58:59,840
This one has four possible
paths, this

1017
00:58:59,840 --> 00:59:03,210
one only has three.

1018
00:59:03,210 --> 00:59:05,230
So there's one straight
through this way.

1019
00:59:05,230 --> 00:59:08,900
There's one that has
one fewer delay.

1020
00:59:08,900 --> 00:59:11,880
And there's one that
only has--

1021
00:59:11,880 --> 00:59:14,930
so there's a straight through
one, there's a delay of 2, and

1022
00:59:14,930 --> 00:59:18,150
there's a delay of 1.

1023
00:59:18,150 --> 00:59:20,220
So let's do the straight
through one.

1024
00:59:20,220 --> 00:59:23,440
This one has a straight
through path.

1025
00:59:23,440 --> 00:59:30,820
No delay, coefficient is 1.

1026
00:59:30,820 --> 00:59:32,240
This one has a straight
through path,

1027
00:59:32,240 --> 00:59:33,540
coefficient is 1.

1028
00:59:33,540 --> 00:59:34,870
This one has a straight
through path,

1029
00:59:34,870 --> 00:59:38,200
coefficient is 1.

1030
00:59:38,200 --> 00:59:43,030
So all three systems have the
same maximum delay path, they

1031
00:59:43,030 --> 00:59:46,130
all have the same minimum delay
path, we only have one

1032
00:59:46,130 --> 00:59:47,400
in the middle yet.

1033
00:59:47,400 --> 00:59:50,990
This one has two ways
to get a delay of 1.

1034
00:59:50,990 --> 00:59:56,370
2 delay, 2R, or 2R.

1035
00:59:56,370 --> 00:59:58,770
Since they're both 2R, they
sum, so that's 4R.

1036
00:59:58,770 --> 01:00:01,990

1037
01:00:01,990 --> 01:00:06,640
This one only has one way that
we can get 1 delay, and that

1038
01:00:06,640 --> 01:00:09,180
is to come this way and then
go that way, that's 4R.

1039
01:00:09,180 --> 01:00:12,180

1040
01:00:12,180 --> 01:00:14,310
This one, to get 1 delay,
I take the center

1041
01:00:14,310 --> 01:00:16,490
path, and that's 4R.

1042
01:00:16,490 --> 01:00:21,440
Each path has the same ways to
get through the system with

1043
01:00:21,440 --> 01:00:24,290
zero delay, 1 delay,
and 2 delays.

1044
01:00:24,290 --> 01:00:27,550
They're equivalent in the sense
that if you started them

1045
01:00:27,550 --> 01:00:34,240
with initial rest, they would
all generate the same output

1046
01:00:34,240 --> 01:00:36,060
given the same input.

1047
01:00:36,060 --> 01:00:38,870
So the answer's (3).

1048
01:00:38,870 --> 01:00:40,120
OK?

1049
01:00:40,120 --> 01:00:42,570

1050
01:00:42,570 --> 01:00:45,680
So far I've only worked with
systems that propagate the

1051
01:00:45,680 --> 01:00:49,710
inputs systematically through
to the outputs.

1052
01:00:49,710 --> 01:00:51,100
We call such systems
feedforward.

1053
01:00:51,100 --> 01:01:02,470

1054
01:01:02,470 --> 01:01:04,420
Things are a little
bit different

1055
01:01:04,420 --> 01:01:07,270
when you have cycles.

1056
01:01:07,270 --> 01:01:09,023
We call such systems feedback.

1057
01:01:09,023 --> 01:01:14,950

1058
01:01:14,950 --> 01:01:19,150
So what I want to think about
now is how do you think about

1059
01:01:19,150 --> 01:01:21,276
a system that has a feedback
loop in it?

1060
01:01:21,276 --> 01:01:24,420

1061
01:01:24,420 --> 01:01:26,180
The interesting thing that
happens when you have a

1062
01:01:26,180 --> 01:01:33,670
feedback loop is that the
operator expression no longer

1063
01:01:33,670 --> 01:01:38,610
represents a simple sum
of input signals.

1064
01:01:38,610 --> 01:01:40,760
Let's look at what
happens here.

1065
01:01:40,760 --> 01:01:45,690
So Y is apparently the
sum of two things.

1066
01:01:45,690 --> 01:01:51,630
It's the signal RY, which
comes around that way.

1067
01:01:51,630 --> 01:01:54,000
Does everybody see that?

1068
01:01:54,000 --> 01:01:56,650
So if I think about labeling
this input as X, labeling this

1069
01:01:56,650 --> 01:02:01,270
output as Y, then the correct
label for this point is--

1070
01:02:01,270 --> 01:02:04,876

1071
01:02:04,876 --> 01:02:08,700
don't everybody shout at once.

1072
01:02:08,700 --> 01:02:12,350
If this can be labeled as the
point Y, what is the correct

1073
01:02:12,350 --> 01:02:13,530
label to a label at this point?

1074
01:02:13,530 --> 01:02:16,410
RY.

1075
01:02:16,410 --> 01:02:25,730
So the signal Y must be, RY
plus X. What that says, is

1076
01:02:25,730 --> 01:02:32,000
that if I apply the 1 minus R
operator to Y, I should get X.

1077
01:02:32,000 --> 01:02:36,740
OK, that's a fine operator
expression, except that it's

1078
01:02:36,740 --> 01:02:41,780
not a formulaic operator
applied to the input.

1079
01:02:41,780 --> 01:02:47,390
The operator is applied
to the output.

1080
01:02:47,390 --> 01:02:52,880
OK, the difference here is
the difference between an

1081
01:02:52,880 --> 01:03:00,110
imperative system, like we
talked about block diagrams

1082
01:03:00,110 --> 01:03:01,780
when we were thinking
about samples.

1083
01:03:01,780 --> 01:03:07,970
The block diagram tells you
what to do step by step.

1084
01:03:07,970 --> 01:03:10,210
Regardless of whether you have
feedback, the block diagram

1085
01:03:10,210 --> 01:03:15,350
always tells you take X of n,
add it to Y of n, whatever.

1086
01:03:15,350 --> 01:03:19,880
There's an imperative
rule, do this.

1087
01:03:19,880 --> 01:03:22,450
We took the block diagrams and
we turned them into operators,

1088
01:03:22,450 --> 01:03:25,085
and we ended up with something
that is not imperative.

1089
01:03:25,085 --> 01:03:28,140

1090
01:03:28,140 --> 01:03:31,140
This is much more the kind of
statement we got when we did

1091
01:03:31,140 --> 01:03:33,370
difference equations.

1092
01:03:33,370 --> 01:03:37,930
This is a statement of truth,
it's declarative.

1093
01:03:37,930 --> 01:03:43,760
If you tell me the signal X,
it must be true that the

1094
01:03:43,760 --> 01:03:49,350
resulting signal Y when operated
upon by 1 minus R, is

1095
01:03:49,350 --> 01:03:56,190
X. So the idea is that it's
a declaration, it's not an

1096
01:03:56,190 --> 01:03:58,860
imperative rule.

1097
01:03:58,860 --> 01:04:00,110
Does everybody get that?

1098
01:04:00,110 --> 01:04:02,420

1099
01:04:02,420 --> 01:04:07,750
So this statement up here told
me a rule, start with X, apply

1100
01:04:07,750 --> 01:04:12,780
the 1 minus R operator and
you will get Y. That's an

1101
01:04:12,780 --> 01:04:15,340
imperative operation, do this.

1102
01:04:15,340 --> 01:04:18,070

1103
01:04:18,070 --> 01:04:21,540
This is a declaration.

1104
01:04:21,540 --> 01:04:26,350
If you tell me X, Y must be the
signal that when operated

1105
01:04:26,350 --> 01:04:31,270
on by 1 minus R, gives you X.
But it doesn't tell me a way

1106
01:04:31,270 --> 01:04:34,010
to find it.

1107
01:04:34,010 --> 01:04:37,060
It tells me a truth, but it
doesn't tell me how to find

1108
01:04:37,060 --> 01:04:39,350
that truth.

1109
01:04:39,350 --> 01:04:41,090
So let's go back,
let's back up.

1110
01:04:41,090 --> 01:04:43,550
OK, we got a representation,
we like the representation.

1111
01:04:43,550 --> 01:04:46,270
It's concise, it has many
of the features of block

1112
01:04:46,270 --> 01:04:49,695
diagrams, it doesn't seem
to be imperative.

1113
01:04:49,695 --> 01:04:51,500
Well, that's a problem.

1114
01:04:51,500 --> 01:04:54,930
So let's back up, think about
how this same system that ran

1115
01:04:54,930 --> 01:04:57,760
into a problem with the
operator, think about what

1116
01:04:57,760 --> 01:04:59,010
must the answer be.

1117
01:04:59,010 --> 01:05:02,330

1118
01:05:02,330 --> 01:05:06,990
Well the answer we can figure
out by doing step by step.

1119
01:05:06,990 --> 01:05:09,760
Imagine that it starts
at rest, so the

1120
01:05:09,760 --> 01:05:12,660
output starts at 0.

1121
01:05:12,660 --> 01:05:14,675
And now I just tick through
the samples.

1122
01:05:14,675 --> 01:05:17,470

1123
01:05:17,470 --> 01:05:20,980
So when the first sample comes
in, X is equal to 1, I'm

1124
01:05:20,980 --> 01:05:23,840
thinking about the unit
sample response.

1125
01:05:23,840 --> 01:05:28,510
We call the delta function
the unit sample.

1126
01:05:28,510 --> 01:05:31,840
When the unit sample at time n
equals 0 comes in, it has a

1127
01:05:31,840 --> 01:05:33,180
value of 1.

1128
01:05:33,180 --> 01:05:36,010
The 1 adds to the initial
condition, which is

1129
01:05:36,010 --> 01:05:37,760
0, to give me 1.

1130
01:05:37,760 --> 01:05:42,537

1131
01:05:42,537 --> 01:05:47,410
Then, this output is 1, so
when the clock ticks, the

1132
01:05:47,410 --> 01:05:51,690
input goes from 1 to 0, but the
output of the delay goes

1133
01:05:51,690 --> 01:05:52,940
from 0 to 1.

1134
01:05:52,940 --> 01:05:55,980

1135
01:05:55,980 --> 01:05:58,650
So when the clock ticks,
I get another 1.

1136
01:05:58,650 --> 01:06:01,190

1137
01:06:01,190 --> 01:06:04,190
And that persists.

1138
01:06:04,190 --> 01:06:06,450
Does everybody see
what's going on?

1139
01:06:06,450 --> 01:06:10,870
So I initially had a 0 coming
out of the delay.

1140
01:06:10,870 --> 01:06:16,430
The unit sample made the first
output be one, but then that 1

1141
01:06:16,430 --> 01:06:19,180
fed back in to make this be 1.

1142
01:06:19,180 --> 01:06:23,250
Which combined with the next 0
to give me the same 1, and

1143
01:06:23,250 --> 01:06:25,790
that state persisted.

1144
01:06:25,790 --> 01:06:34,540
What's different, is that the
output signal persists long

1145
01:06:34,540 --> 01:06:36,050
after the input went away.

1146
01:06:36,050 --> 01:06:38,900

1147
01:06:38,900 --> 01:06:43,720
In fact, there is a prescriptive
way to figure out

1148
01:06:43,720 --> 01:06:46,670
the relationship between the
input and the output.

1149
01:06:46,670 --> 01:06:51,030
It's just that it takes an
infinite number of delays.

1150
01:06:51,030 --> 01:06:54,840
Here's an alternative system
that would generate the same

1151
01:06:54,840 --> 01:06:59,990
response to a unit sample signal
as was generated by the

1152
01:06:59,990 --> 01:07:03,140
simple feedback system.

1153
01:07:03,140 --> 01:07:07,450
It needs to generate the
answer 1, 1, 1, 1, 1 --

1154
01:07:07,450 --> 01:07:11,090
when the input is just 1.

1155
01:07:11,090 --> 01:07:15,540
Well, the output at 0 happens
through this path.

1156
01:07:15,540 --> 01:07:18,260

1157
01:07:18,260 --> 01:07:21,830
The output at 1 happens
through this path.

1158
01:07:21,830 --> 01:07:24,510
The output at 2 happens
through this path.

1159
01:07:24,510 --> 01:07:25,170
3--

1160
01:07:25,170 --> 01:07:26,065
et cetera.

1161
01:07:26,065 --> 01:07:30,950
There's a separate path for
every one of those separate

1162
01:07:30,950 --> 01:07:32,930
components of the output.

1163
01:07:32,930 --> 01:07:35,350
That's how we can think about
this construction.

1164
01:07:35,350 --> 01:07:41,360
The input had a single non-zero
entry, the output has

1165
01:07:41,360 --> 01:07:43,550
an infinite number.

1166
01:07:43,550 --> 01:07:46,830
We can think about that as
resulting from an infinite

1167
01:07:46,830 --> 01:07:51,390
number of paths, or something
similar, about the simple

1168
01:07:51,390 --> 01:07:54,540
feedback system, which can be
represented by that operator

1169
01:07:54,540 --> 01:08:02,990
representation, and the infinite
feedforward system.

1170
01:08:02,990 --> 01:08:06,400
This is a simple feedback
system.

1171
01:08:06,400 --> 01:08:09,000
This is an infinite feedforward
system.

1172
01:08:09,000 --> 01:08:11,100
There's something the same
about those two.

1173
01:08:11,100 --> 01:08:13,900

1174
01:08:13,900 --> 01:08:17,899
In fact, they're equivalent in
the sense that if all the

1175
01:08:17,899 --> 01:08:21,710
delays start out with initial
conditions of 0, they will

1176
01:08:21,710 --> 01:08:27,819
generate the same response to
all possible input signals.

1177
01:08:27,819 --> 01:08:29,450
Those two signals are
equivalent, and

1178
01:08:29,450 --> 01:08:32,210
that's proved here.

1179
01:08:32,210 --> 01:08:43,319
All you do is you say, OK, Y2
depends on X2 this way.

1180
01:08:43,319 --> 01:08:47,220
If X2 is the same as X1,
I can substitute it.

1181
01:08:47,220 --> 01:08:52,950
But X1, according to this rule,
looks like 1 minus RY1.

1182
01:08:52,950 --> 01:08:55,455
When you multiply out this
mess, you get Y1.

1183
01:08:55,455 --> 01:08:58,040

1184
01:08:58,040 --> 01:09:07,359
What I just showed is that if X1
is equal to X2, then Y1 is

1185
01:09:07,359 --> 01:09:08,490
equal to Y2.

1186
01:09:08,490 --> 01:09:11,979
Those two systems
are the same.

1187
01:09:11,979 --> 01:09:14,899
Well that's weird.

1188
01:09:14,899 --> 01:09:17,640
So there's something
the same about that

1189
01:09:17,640 --> 01:09:20,060
operator and that operator.

1190
01:09:20,060 --> 01:09:22,439
We write that this way.

1191
01:09:22,439 --> 01:09:26,000
So here's the feedback system,
we think about that as

1192
01:09:26,000 --> 01:09:32,740
representing the operator Y over
X, 1 over (1 minus R).

1193
01:09:32,740 --> 01:09:38,450
So in order to calculate X,
cross multiply by X. Y is the

1194
01:09:38,450 --> 01:09:43,410
operator, 1 minus
R applied to X.

1195
01:09:43,410 --> 01:09:51,319
So we want to say Y is the
operator 1 minus R applied to

1196
01:09:51,319 --> 01:09:56,775
X. What is the operator
1 over (1 minus R)?

1197
01:09:56,775 --> 01:10:00,040

1198
01:10:00,040 --> 01:10:06,330
Well, if you didn't know
anything but polynomial math,

1199
01:10:06,330 --> 01:10:08,495
you might have expanded
this in a series.

1200
01:10:08,495 --> 01:10:11,350

1201
01:10:11,350 --> 01:10:15,390
And in fact, that gives you
exactly the right answer if

1202
01:10:15,390 --> 01:10:19,250
you were to expand 1
over R in a series.

1203
01:10:19,250 --> 01:10:22,270
So, for example, evaluate it
using synthetic division,

1204
01:10:22,270 --> 01:10:24,290
evaluate it with a Taylor
series, however

1205
01:10:24,290 --> 01:10:25,890
you want to do it.

1206
01:10:25,890 --> 01:10:28,240
Think about R as though it were
a number, just like you

1207
01:10:28,240 --> 01:10:31,300
would if it were a polynomial.

1208
01:10:31,300 --> 01:10:35,710
Expanded just like you would
if it were a polynomial.

1209
01:10:35,710 --> 01:10:38,640
And what you see, is that
there's a representation for

1210
01:10:38,640 --> 01:10:42,950
this operator 1 over (1 minus
R) that is equivalent.

1211
01:10:42,950 --> 01:10:46,920
That's exactly the same as if I
applied the operator 1 plus

1212
01:10:46,920 --> 01:10:54,850
R plus R squared plus R cubed to
X. Those two are equivalent

1213
01:10:54,850 --> 01:10:59,740
in the sense that if both
systems start out at rest, and

1214
01:10:59,740 --> 01:11:03,150
if they are both applied to
the same input, they both

1215
01:11:03,150 --> 01:11:06,230
generate the same output.

1216
01:11:06,230 --> 01:11:12,590
So that gives us that way of
thinking about operators that

1217
01:11:12,590 --> 01:11:14,723
have numerators and
denominators.

1218
01:11:14,723 --> 01:11:19,220

1219
01:11:19,220 --> 01:11:24,370
So, to make sure you're up to
speed, a system is described

1220
01:11:24,370 --> 01:11:27,120
by the following operator
expression.

1221
01:11:27,120 --> 01:11:29,190
Determine the output of the
system when the input is a

1222
01:11:29,190 --> 01:11:29,850
unit sample.

1223
01:11:29,850 --> 01:11:31,100
AUDIENCE: [INAUDIBLE]

1224
01:11:31,100 --> 01:13:13,430

1225
01:13:13,430 --> 01:13:14,890
PROFESSOR: What's the first
thing I should do?

1226
01:13:14,890 --> 01:13:21,228

1227
01:13:21,228 --> 01:13:23,770
OK, this is one of those
systems that has the R

1228
01:13:23,770 --> 01:13:26,800
polynomial in the bottom.

1229
01:13:26,800 --> 01:13:31,450
So it says that X must be
the same signal by cross

1230
01:13:31,450 --> 01:13:32,250
multiplying--

1231
01:13:32,250 --> 01:13:36,140
X must be the same signal as
the (1 plus 2R) operator on

1232
01:13:36,140 --> 01:13:38,080
the Y. OK, that's backwards.

1233
01:13:38,080 --> 01:13:40,300
That's not the way I want
to think about it.

1234
01:13:40,300 --> 01:13:44,320
How do I make that into a
forward statement that tells

1235
01:13:44,320 --> 01:13:46,405
me what operator gets
applied to X?

1236
01:13:46,405 --> 01:13:49,180

1237
01:13:49,180 --> 01:13:50,430
The answer is that.

1238
01:13:50,430 --> 01:13:53,030

1239
01:13:53,030 --> 01:13:54,280
So what do I do?

1240
01:13:54,280 --> 01:14:00,350

1241
01:14:00,350 --> 01:14:03,640
Multiply by--

1242
01:14:03,640 --> 01:14:07,280
actually you could
cross multiply.

1243
01:14:07,280 --> 01:14:12,280
How do I convert this into an
operator that looks like just

1244
01:14:12,280 --> 01:14:16,388
the numerator times X. Yeah.

1245
01:14:16,388 --> 01:14:19,600
AUDIENCE: 1 minus 2R
plus 4R squared.

1246
01:14:19,600 --> 01:14:21,270
PROFESSOR: Exactly.

1247
01:14:21,270 --> 01:14:25,490
What I want to do is convert
it by synthetic division,

1248
01:14:25,490 --> 01:14:27,600
Taylor series, whatever
method.

1249
01:14:27,600 --> 01:14:31,510
I want to think about
what would 1 over (1

1250
01:14:31,510 --> 01:14:32,710
plus 2R) look like?

1251
01:14:32,710 --> 01:14:37,140
What's the reciprocal
of 1 plus 2R?

1252
01:14:37,140 --> 01:14:40,710
That is 1 minus 2R plus
4R squared, et cetera.

1253
01:14:40,710 --> 01:14:44,290
So now I have this, which
I apply to X,

1254
01:14:44,290 --> 01:14:47,440
which is a unit sample.

1255
01:14:47,440 --> 01:14:50,530
So now I want to think about
applying this operator to the

1256
01:14:50,530 --> 01:14:52,420
unit sample signal.

1257
01:14:52,420 --> 01:14:54,530
But that's easy.

1258
01:14:54,530 --> 01:14:59,550
The first term just
brings out delta.

1259
01:14:59,550 --> 01:15:06,230
Minus 2R applied to delta
shifts the delta by 1.

1260
01:15:06,230 --> 01:15:10,005
Gives me delta of n minus 1,
and multiplies by minus 2.

1261
01:15:10,005 --> 01:15:13,280

1262
01:15:13,280 --> 01:15:16,780
And that whole mess then
just says that my

1263
01:15:16,780 --> 01:15:19,310
output looks like this.

1264
01:15:19,310 --> 01:15:23,990
If the input was X, which was
a unit sample signal, my

1265
01:15:23,990 --> 01:15:28,570
output has an infinite
number of terms.

1266
01:15:28,570 --> 01:15:34,050
Each one is a delayed version
of the predecessor, and the

1267
01:15:34,050 --> 01:15:39,460
weights go 1, minus 2, plus 4,
minus 8, plus 16, and diverge.

1268
01:15:39,460 --> 01:15:42,910

1269
01:15:42,910 --> 01:15:45,530
So what we just did was
pretty complicated.

1270
01:15:45,530 --> 01:15:49,120
We just solved a block diagram,
but we did it with

1271
01:15:49,120 --> 01:15:50,230
polynomial math.

1272
01:15:50,230 --> 01:15:52,420
We did it with math that you
learned in high school.

1273
01:15:52,420 --> 01:15:54,600
That's the point.

1274
01:15:54,600 --> 01:16:00,610
In fact, the point of today is
that any system that's built

1275
01:16:00,610 --> 01:16:01,870
out of simple parts--

1276
01:16:01,870 --> 01:16:04,920
delays, adders, scalers,
that sort of thing--

1277
01:16:04,920 --> 01:16:07,300
can be represented by a
difference equation.

1278
01:16:07,300 --> 01:16:11,750
Fine, that's good, difference
equations are wonderful.

1279
01:16:11,750 --> 01:16:13,480
They can equivalently
be represented

1280
01:16:13,480 --> 01:16:16,930
by an operator equation.

1281
01:16:16,930 --> 01:16:23,100
The operator equation has
more information in it.

1282
01:16:23,100 --> 01:16:26,090
It knows how to get from the
input to the output.

1283
01:16:26,090 --> 01:16:28,220
It's imperative.

1284
01:16:28,220 --> 01:16:30,560
It's easy to manipulate.

1285
01:16:30,560 --> 01:16:33,940
You use the same rules that
you use for polynomials.

1286
01:16:33,940 --> 01:16:37,140
So all in all, this is a
more powerful kind of

1287
01:16:37,140 --> 01:16:38,010
representation.

1288
01:16:38,010 --> 01:16:40,880
And any system that can be
represented by a difference

1289
01:16:40,880 --> 01:16:43,140
equation can similarly
be represented

1290
01:16:43,140 --> 01:16:45,340
by an operator equation.

1291
01:16:45,340 --> 01:16:47,920
That's why we're focusing
on operators.

1292
01:16:47,920 --> 01:16:50,470
So final question.

1293
01:16:50,470 --> 01:16:52,560
Think about--

1294
01:16:52,560 --> 01:16:55,770
do everything backwards now.

1295
01:16:55,770 --> 01:17:00,530
Here's a block diagram,
find the

1296
01:17:00,530 --> 01:17:02,065
associated difference equation.

1297
01:17:02,065 --> 01:17:05,040

1298
01:17:05,040 --> 01:17:07,980
And the idea is to take
advantage of operators.

1299
01:17:07,980 --> 01:17:11,110

1300
01:17:11,110 --> 01:17:15,250
In the interest of time,
let me just do it.

1301
01:17:15,250 --> 01:17:16,560
If we wanted to--

1302
01:17:16,560 --> 01:17:18,810
because I'm running
out of time.

1303
01:17:18,810 --> 01:17:21,180
So I could start with the block
diagram, I could stay in

1304
01:17:21,180 --> 01:17:23,660
block diagram domain.

1305
01:17:23,660 --> 01:17:26,270
Presumably that will
work, that's hard.

1306
01:17:26,270 --> 01:17:28,580
I want to do the easy way.

1307
01:17:28,580 --> 01:17:30,020
So convert it to operators.

1308
01:17:30,020 --> 01:17:33,350
How do you convert a block
diagram to operators?

1309
01:17:33,350 --> 01:17:38,050
Replace the delays by R,
label all the signals.

1310
01:17:38,050 --> 01:17:41,240
x becomes X, y becomes Y. I
don't have a name for this, so

1311
01:17:41,240 --> 01:17:44,290
I'll call it E, error.

1312
01:17:44,290 --> 01:17:46,860
I don't have a name for this, so
I'll call it W, who knows.

1313
01:17:46,860 --> 01:17:49,400

1314
01:17:49,400 --> 01:17:54,480
And then I'll express each of
the relationships imposed by

1315
01:17:54,480 --> 01:17:57,760
the plus sign, this
R or this R, by a

1316
01:17:57,760 --> 01:18:01,000
line of operator reasoning.

1317
01:18:01,000 --> 01:18:07,330
The plus says that the E signal
is X plus W. The R says

1318
01:18:07,330 --> 01:18:12,490
that the Y signal is R applied
to E. This box says that the W

1319
01:18:12,490 --> 01:18:15,280
signal is R applied to Y.

1320
01:18:15,280 --> 01:18:23,320
I get three equations in R. I
just solve algebraically.

1321
01:18:23,320 --> 01:18:25,660
None of this difference stuff,
none of the square brackets

1322
01:18:25,660 --> 01:18:26,920
with n's in them.

1323
01:18:26,920 --> 01:18:28,170
I just use algebra.

1324
01:18:28,170 --> 01:18:30,640

1325
01:18:30,640 --> 01:18:34,210
So I solve it algebraically
and I get this.

1326
01:18:34,210 --> 01:18:37,640
And that translates into a
corresponding difference

1327
01:18:37,640 --> 01:18:39,360
equation, showed here.

1328
01:18:39,360 --> 01:18:43,390

1329
01:18:43,390 --> 01:18:44,350
The point.

1330
01:18:44,350 --> 01:18:46,550
The point is three different
representations.

1331
01:18:46,550 --> 01:18:49,330
Difference equations, block
diagrams, operators.

1332
01:18:49,330 --> 01:18:51,960

1333
01:18:51,960 --> 01:18:54,940
Operators are easiest.

1334
01:18:54,940 --> 01:18:57,990
Even when I was asked to solve
a problem that has no

1335
01:18:57,990 --> 01:19:01,150
operators in it, it's easier
to cast it into an operator

1336
01:19:01,150 --> 01:19:05,610
expression, solve it in the
operator domain, and then turn

1337
01:19:05,610 --> 01:19:08,890
it back into a difference
equation.

1338
01:19:08,890 --> 01:19:12,220
Starting next week, we will
figure out much more powerful

1339
01:19:12,220 --> 01:19:13,650
things that we can do
with operators.

1340
01:19:13,650 --> 01:19:16,040
This is just the beginning.

1341
01:19:16,040 --> 01:19:20,370
So with that, let me just
summarize that we looked at

1342
01:19:20,370 --> 01:19:26,500
three representations, and the
point of the labs for the week

1343
01:19:26,500 --> 01:19:30,160
are going to be to exercise
this, to get some experience

1344
01:19:30,160 --> 01:19:32,980
with representing signals
in Python.

1345
01:19:32,980 --> 01:19:42,933