1
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

2
00:00:02,460 --> 00:00:03,870
Commons license.

3
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

4
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

5
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

6
00:00:13,460 --> 00:00:17,390
hundreds of MIT courses, visit
MIT OpenCourseWare at

7
00:00:17,390 --> 00:00:18,640
ocw.mit.edu.

8
00:00:26,080 --> 00:00:27,330
PROFESSOR: Hello, and welcome.

9
00:00:31,870 --> 00:00:34,920
Last week we started to think
about programming.

10
00:00:34,920 --> 00:00:38,550
Programming was the first
module in this class.

11
00:00:38,550 --> 00:00:40,900
And it was important for
two different reasons.

12
00:00:40,900 --> 00:00:44,410
First, we're going to use
programming throughout the

13
00:00:44,410 --> 00:00:49,660
term in the study of all the
different things that we do.

14
00:00:49,660 --> 00:00:52,540
So it's important that you learn
to program now, just so

15
00:00:52,540 --> 00:00:56,400
you can use that tool.

16
00:00:56,400 --> 00:01:00,360
More importantly perhaps, we
didn't just learn how to

17
00:01:00,360 --> 00:01:05,370
program, we focused on how to
program in a fashion that

18
00:01:05,370 --> 00:01:08,310
would let us construct
complicated systems out of a

19
00:01:08,310 --> 00:01:09,420
simpler systems.

20
00:01:09,420 --> 00:01:12,570
This is the way that we
can manage complexity.

21
00:01:12,570 --> 00:01:15,340
This is the only possible
way that we can

22
00:01:15,340 --> 00:01:18,440
make complicated systems.

23
00:01:18,440 --> 00:01:21,380
So that was the more important
intellectual theme from the

24
00:01:21,380 --> 00:01:26,040
first part, where we introduced
our mantra, PCAP --

25
00:01:26,040 --> 00:01:29,650
primitives, means of
combination, abstraction and

26
00:01:29,650 --> 00:01:31,760
identifying patterns.

27
00:01:31,760 --> 00:01:36,090
That's the key to this
modular approach to

28
00:01:36,090 --> 00:01:37,740
hierarchical kind of design.

29
00:01:40,430 --> 00:01:43,610
Today what I want to do is start
the second major theme.

30
00:01:43,610 --> 00:01:46,770
First theme was the design of
complex systems, we saw that

31
00:01:46,770 --> 00:01:49,110
by reference to programming.

32
00:01:49,110 --> 00:01:51,470
Today we're going to start
thinking about modeling and

33
00:01:51,470 --> 00:01:52,975
controlling physical systems.

34
00:01:55,890 --> 00:02:01,080
The idea here is not so much
how you construct systems--

35
00:02:01,080 --> 00:02:04,430
but we will get back to that.

36
00:02:04,430 --> 00:02:07,740
The idea is to characterize
the systems that you've

37
00:02:07,740 --> 00:02:11,280
constructed and say something
about their metrics as being

38
00:02:11,280 --> 00:02:13,360
positive or negative.

39
00:02:13,360 --> 00:02:16,205
So what we want to do is, in
fact, focus on behavior.

40
00:02:19,680 --> 00:02:23,920
So to illustrate that, I'll
start with an example.

41
00:02:23,920 --> 00:02:26,760
This is an example that you did
in design lab last week,

42
00:02:26,760 --> 00:02:29,260
or for some of you, yesterday.

43
00:02:29,260 --> 00:02:34,260
The idea was to program the
robot so that it could sense

44
00:02:34,260 --> 00:02:36,000
the distance to a wall.

45
00:02:36,000 --> 00:02:39,435
Represented two ways here,
sort of the view that you

46
00:02:39,435 --> 00:02:43,050
would get from Soar, and a more
schematic representation

47
00:02:43,050 --> 00:02:45,820
showing the position of a robot,
the position of a wall.

48
00:02:45,820 --> 00:02:48,930
The idea is that you can sense
the position to the wall using

49
00:02:48,930 --> 00:02:50,704
the sonars.

50
00:02:50,704 --> 00:02:52,940
You know where you would
like to be, because

51
00:02:52,940 --> 00:02:54,050
some user told you.

52
00:02:54,050 --> 00:02:57,100
You'd like to be say, half a
meter away from the wall.

53
00:02:57,100 --> 00:03:01,130
And your job was to write a
program that moves the robot

54
00:03:01,130 --> 00:03:03,210
from where it is to where
you'd like it to be.

55
00:03:06,200 --> 00:03:08,835
So here's the kind of behavior
we might have liked--

56
00:03:11,860 --> 00:03:13,050
so I'll do that again.

57
00:03:13,050 --> 00:03:17,180
So we might have liked that if
you started here, you have a

58
00:03:17,180 --> 00:03:21,080
nice smooth progression up to
where you'd like to be.

59
00:03:21,080 --> 00:03:24,890
Very graceful, ballet type, and
you just sort of smoothly

60
00:03:24,890 --> 00:03:27,090
glide into the position
that you'd like.

61
00:03:27,090 --> 00:03:29,700
Some of you probably achieved
that behavior, and some of you

62
00:03:29,700 --> 00:03:32,850
probably did other things.

63
00:03:32,850 --> 00:03:36,580
So that might be the
intended behavior.

64
00:03:36,580 --> 00:03:40,980
One way to achieve the intended
behavior is to use

65
00:03:40,980 --> 00:03:42,520
what we call a proportional
controller.

66
00:03:45,410 --> 00:03:50,100
In a proportional controller,
you make the command be, in

67
00:03:50,100 --> 00:03:55,160
some way, proportionate to
the intended response.

68
00:03:55,160 --> 00:04:00,070
So imagine this code, which
might establish a class for

69
00:04:00,070 --> 00:04:03,170
finding the wall.

70
00:04:03,170 --> 00:04:06,800
So the important thing-- as we
saw, for all state machines,

71
00:04:06,800 --> 00:04:10,480
the important thing is to define
a start state and a

72
00:04:10,480 --> 00:04:13,880
getNextValues routine.

73
00:04:13,880 --> 00:04:17,100
What this getNextValues routine
does is it establishes

74
00:04:17,100 --> 00:04:21,480
the desired distance to
be a half a meter.

75
00:04:21,480 --> 00:04:23,900
It figures out the current
distance to the wall by

76
00:04:23,900 --> 00:04:29,040
reading the sonars, and then
it specifies an action.

77
00:04:29,040 --> 00:04:33,300
So the first question is what
would you like fvel to be in

78
00:04:33,300 --> 00:04:37,260
order to make a proportional
controller?

79
00:04:37,260 --> 00:04:41,020
Which of those expressions
makes sense?

80
00:04:41,020 --> 00:04:44,130
Take 30 seconds, talk to your
neighbor, figure out some

81
00:04:44,130 --> 00:04:45,500
answer between (1) and (5).

82
00:04:45,500 --> 00:04:47,850
I will ask you in 30 seconds to
raise your hand with that

83
00:04:47,850 --> 00:04:48,530
number of fingers.

84
00:04:48,530 --> 00:04:49,780
AUDIENCE: [INAUDIBLE]

85
00:05:58,970 --> 00:06:01,270
PROFESSOR: So what's the right
kind of expression if we

86
00:06:01,270 --> 00:06:03,030
wanted the controller
to be proportionate?

87
00:06:03,030 --> 00:06:04,130
Everybody raise your
hand, show me

88
00:06:04,130 --> 00:06:05,380
some number of fingers.

89
00:06:07,570 --> 00:06:11,110
OK, the vast majority
is saying (2).

90
00:06:11,110 --> 00:06:14,690
Everybody likes the idea of
current minus desired.

91
00:06:14,690 --> 00:06:16,430
Why is that the right answer?

92
00:06:16,430 --> 00:06:17,960
That is the right answer.

93
00:06:17,960 --> 00:06:19,840
Why is that the right answer?

94
00:06:19,840 --> 00:06:22,252
How do you prove that
to somebody?

95
00:06:22,252 --> 00:06:25,138
AUDIENCE: Well, in current
divided desired, once you meet

96
00:06:25,138 --> 00:06:27,543
your desired distance, you're
still going to have to

97
00:06:27,543 --> 00:06:29,467
[UNINTELLIGIBLE] velocity
[UNINTELLIGIBLE], which really

98
00:06:29,467 --> 00:06:30,440
doesn't make sense
at this point.

99
00:06:30,440 --> 00:06:31,570
PROFESSOR: Exactly.

100
00:06:31,570 --> 00:06:35,450
So that method, we might
call extreme cases.

101
00:06:35,450 --> 00:06:39,120
Think of the simplifying cases
that give you some insight

102
00:06:39,120 --> 00:06:39,810
into the problem.

103
00:06:39,810 --> 00:06:43,390
So one simple case is
what if desired and

104
00:06:43,390 --> 00:06:44,960
current were the same?

105
00:06:44,960 --> 00:06:47,215
You'd better stop.

106
00:06:47,215 --> 00:06:49,510
OK, that's a simple case.

107
00:06:49,510 --> 00:06:52,820
So the simple case says that you
better have one of these--

108
00:06:52,820 --> 00:06:54,600
whatever the right answer is,
it better have the property

109
00:06:54,600 --> 00:06:57,610
that when current equals
desired, fvel is 0.

110
00:06:57,610 --> 00:06:58,890
Otherwise it's not
going to work.

111
00:06:58,890 --> 00:07:01,530
And in fact, using just that
one simple case, you can

112
00:07:01,530 --> 00:07:04,310
eliminate all the
ones except (2).

113
00:07:04,310 --> 00:07:06,080
There are some other simple
cases, what are some other

114
00:07:06,080 --> 00:07:07,330
simple cases?

115
00:07:10,137 --> 00:07:10,850
Simple cases.

116
00:07:10,850 --> 00:07:11,811
Yeah.

117
00:07:11,811 --> 00:07:14,170
AUDIENCE: currentDistance
greater than desiredDistance?

118
00:07:14,170 --> 00:07:15,765
PROFESSOR: Current bigger
than desired.

119
00:07:15,765 --> 00:07:18,010
So if current were bigger, that
would mean that you were

120
00:07:18,010 --> 00:07:21,590
starting out way over
here someplace.

121
00:07:21,590 --> 00:07:24,050
So if you were way over there
someplace, you'd want the

122
00:07:24,050 --> 00:07:26,230
velocity to be positive.

123
00:07:26,230 --> 00:07:28,590
The forward velocity
should be positive.

124
00:07:28,590 --> 00:07:32,200
That's how you would
disambiguate the sign.

125
00:07:32,200 --> 00:07:35,670
Similarly, if the current were
shorter than desired, if you

126
00:07:35,670 --> 00:07:37,610
were too close to the wall,
you'd like the forward

127
00:07:37,610 --> 00:07:39,770
velocity to be negative.

128
00:07:39,770 --> 00:07:41,020
OK.

129
00:07:41,020 --> 00:07:44,130
So that's the proportional
controller that we'd like.

130
00:07:44,130 --> 00:07:47,770
So we might fill in our wall
finder class this way.

131
00:07:50,430 --> 00:07:54,450
And then when we built it, if
things went really well, we

132
00:07:54,450 --> 00:07:56,920
would get exactly the
behavior we wanted.

133
00:07:56,920 --> 00:08:00,430
But if things went more
naturally, it wouldn't quite

134
00:08:00,430 --> 00:08:02,040
work that way, and
you might get a

135
00:08:02,040 --> 00:08:03,290
different kind of behavior.

136
00:08:07,130 --> 00:08:07,930
Let's do that again.

137
00:08:07,930 --> 00:08:11,030
So here is the resulting
behavior for that simple

138
00:08:11,030 --> 00:08:12,280
controller that I just showed.

139
00:08:16,310 --> 00:08:21,590
So in some sense, that's
not as good behavior.

140
00:08:21,590 --> 00:08:23,360
And the way we want to think
about behaviors--

141
00:08:23,360 --> 00:08:25,120
the way we're going to develop
today, is to think about

142
00:08:25,120 --> 00:08:29,010
behaviors in terms of signals.

143
00:08:29,010 --> 00:08:31,130
Plots.

144
00:08:31,130 --> 00:08:34,679
So the first question is, what
plot best represents the

145
00:08:34,679 --> 00:08:36,180
behavior that I saw here?

146
00:08:43,070 --> 00:08:45,330
So which of those plots best
represents that behavior?

147
00:08:45,330 --> 00:08:47,260
Take 30 seconds, talk to your
neighbor, figure out what's

148
00:08:47,260 --> 00:08:47,800
the right answer?

149
00:08:47,800 --> 00:08:49,050
AUDIENCE: [INAUDIBLE]

150
00:09:46,250 --> 00:09:49,850
PROFESSOR: OK, so which behavior
best represents the

151
00:09:49,850 --> 00:09:52,650
illustrated cartoon that
I showed previously?

152
00:09:52,650 --> 00:09:55,573
Raise your hand, show some
number fingers so that I can

153
00:09:55,573 --> 00:09:57,680
see if you're with it.

154
00:09:57,680 --> 00:10:02,050
Not all correct, but more
than 90% correct.

155
00:10:02,050 --> 00:10:04,510
The more than 90% answer
is number (2).

156
00:10:04,510 --> 00:10:07,200
What's good about number (2)
that's not good about numbers

157
00:10:07,200 --> 00:10:08,525
(1), (3), and (4)?

158
00:10:12,846 --> 00:10:14,337
AUDIENCE: The initial
value is different

159
00:10:14,337 --> 00:10:15,331
than the final value.

160
00:10:15,331 --> 00:10:16,822
PROFESSOR: Initial
is different.

161
00:10:16,822 --> 00:10:19,930
So here, I try initial and final
being roughly the same.

162
00:10:19,930 --> 00:10:22,390
So what's showed here,
is a plot.

163
00:10:22,390 --> 00:10:24,490
Current distance on
the y-axis, step

164
00:10:24,490 --> 00:10:26,820
number on the x-axis.

165
00:10:26,820 --> 00:10:29,270
And so we can see from here--
and the implication of the

166
00:10:29,270 --> 00:10:31,500
axes, by the way, is 0.

167
00:10:31,500 --> 00:10:34,970
So the implication of the
vertical axis is it intersects

168
00:10:34,970 --> 00:10:38,400
this at 0, unless I label
it otherwise.

169
00:10:38,400 --> 00:10:41,060
And similarly, this horizontal
line intersects the vertical

170
00:10:41,060 --> 00:10:43,100
at 0 unless I label
it otherwise.

171
00:10:43,100 --> 00:10:44,830
So that's the point (0, 0).

172
00:10:44,830 --> 00:10:47,870
So the implication here is that
the initial and the final

173
00:10:47,870 --> 00:10:51,470
values are the same,
as they are here.

174
00:10:51,470 --> 00:10:55,467
Here they're not, what makes
(2) better than (1).

175
00:10:55,467 --> 00:10:56,717
AUDIENCE: [INAUDIBLE]

176
00:11:00,457 --> 00:11:03,950
the current distance is
decreasing [UNINTELLIGIBLE].

177
00:11:03,950 --> 00:11:06,350
PROFESSOR: The current distance
starts out bigger

178
00:11:06,350 --> 00:11:07,710
than it ultimately is.

179
00:11:07,710 --> 00:11:10,430
So we start out bigger than
the final value, the final

180
00:11:10,430 --> 00:11:13,510
value is presumably
half a meter.

181
00:11:13,510 --> 00:11:16,120
We start out roughly
twice that far, and

182
00:11:16,120 --> 00:11:17,630
then we see some approach.

183
00:11:17,630 --> 00:11:20,360
The approach is not monotonic.

184
00:11:20,360 --> 00:11:23,560
So the answer is (2).

185
00:11:23,560 --> 00:11:27,760
Why do you think
it under-shot?

186
00:11:27,760 --> 00:11:30,820
So on the way to going from
one to one-half, it

187
00:11:30,820 --> 00:11:32,180
transiently went through
something

188
00:11:32,180 --> 00:11:33,030
smaller than one-half.

189
00:11:33,030 --> 00:11:34,730
Why do you think it did that?

190
00:11:34,730 --> 00:11:35,710
Yeah.

191
00:11:35,710 --> 00:11:37,180
AUDIENCE: Because [INAUDIBLE]

192
00:11:37,180 --> 00:11:39,956
this way, there's a small--
there's a small interval of

193
00:11:39,956 --> 00:11:41,100
time when its moving at the
velocity where it couldn't

194
00:11:41,100 --> 00:11:43,060
[INAUDIBLE].

195
00:11:43,060 --> 00:11:46,060
PROFESSOR: So it's a small
interval of time between when

196
00:11:46,060 --> 00:11:48,960
it does one thing, and it
does something else.

197
00:11:48,960 --> 00:11:51,620
When it senses and moves,
for example.

198
00:11:51,620 --> 00:11:54,100
So there could be a time delay,
in the system and in

199
00:11:54,100 --> 00:11:56,640
fact, that's true, there
is a time delay.

200
00:11:56,640 --> 00:12:00,190
So it takes some amount of
time for the sonars to

201
00:12:00,190 --> 00:12:02,390
register the distance.

202
00:12:02,390 --> 00:12:05,070
Then it takes some amount of
time for the computer inside

203
00:12:05,070 --> 00:12:07,640
the robot to register that
the sonar has told

204
00:12:07,640 --> 00:12:09,060
it something different.

205
00:12:09,060 --> 00:12:11,800
Than it takes some time from the
time the computer commands

206
00:12:11,800 --> 00:12:14,630
the wheels until the robot
starts moving.

207
00:12:14,630 --> 00:12:17,900
All of those cumulative effects
mean that you have the

208
00:12:17,900 --> 00:12:21,910
potential to overshoot where
you're going, because there's

209
00:12:21,910 --> 00:12:25,660
delay in the system, there's
inertia in the robot.

210
00:12:25,660 --> 00:12:28,140
All of those reasons can
lead to overshoot.

211
00:12:28,140 --> 00:12:32,850
And the point of today is to
figure out some way of

212
00:12:32,850 --> 00:12:37,460
predicting and correcting
for those kinds

213
00:12:37,460 --> 00:12:40,970
of unintended behaviors.

214
00:12:40,970 --> 00:12:45,960
So what we will do then, is
develop an approach focused on

215
00:12:45,960 --> 00:12:50,390
signals, not systems.

216
00:12:50,390 --> 00:12:51,850
So, so far, we've been thinking
about how do you

217
00:12:51,850 --> 00:12:52,470
build the system?

218
00:12:52,470 --> 00:12:53,720
Now we're going to think
about behavior.

219
00:12:53,720 --> 00:12:56,550
We're going to think about
analyzing that behavior.

220
00:12:56,550 --> 00:12:59,890
And the focus is going to be
on what was the input, what

221
00:12:59,890 --> 00:13:02,300
was desired?

222
00:13:02,300 --> 00:13:05,680
What was the output,
what was achieved?

223
00:13:05,680 --> 00:13:09,260
So we're going to be looking
at those output signals in

224
00:13:09,260 --> 00:13:12,330
order to figure out how
good the behavior was.

225
00:13:12,330 --> 00:13:16,770
That approach is called the
signals and systems approach.

226
00:13:16,770 --> 00:13:20,870
The idea is characterize your
system-- whatever that system

227
00:13:20,870 --> 00:13:23,550
is, a physical system, a
mathematical system, a

228
00:13:23,550 --> 00:13:27,740
computational system, whatever
it is, think about it by the

229
00:13:27,740 --> 00:13:33,330
way it transforms an input
signal into an output signal.

230
00:13:33,330 --> 00:13:36,350
That's kind of a bizarre way
to think about systems.

231
00:13:36,350 --> 00:13:39,270
So let me just illustrate that
by way of a system that you've

232
00:13:39,270 --> 00:13:40,590
all seen before.

233
00:13:40,590 --> 00:13:41,960
OK, here's a simple
system, right?

234
00:13:41,960 --> 00:13:43,920
You've all seen this, right?

235
00:13:43,920 --> 00:13:48,420
Anything like 8.01
ring any bells?

236
00:13:48,420 --> 00:13:51,070
OK, so that's a simple system,
you all know how to solve it.

237
00:13:51,070 --> 00:13:52,970
There's a gazillion ways
you could solve

238
00:13:52,970 --> 00:13:54,740
this system, right?

239
00:13:54,740 --> 00:13:58,220
Free body diagrams, kinetic
energy, potential energy,

240
00:13:58,220 --> 00:14:00,090
there's a gazillion ways
you could do it.

241
00:14:00,090 --> 00:14:02,900
You all know how to do it,
that's not the point.

242
00:14:02,900 --> 00:14:04,490
The point is, that we're going
to learn a different

243
00:14:04,490 --> 00:14:07,790
way to solve it.

244
00:14:07,790 --> 00:14:11,090
We're going to think about the
mass and spring system--

245
00:14:11,090 --> 00:14:14,340
not like potential energy and
kinetic energy, not like free

246
00:14:14,340 --> 00:14:17,200
body diagrams, we're going to
think about it as transforming

247
00:14:17,200 --> 00:14:20,440
an input signal into
an output signal.

248
00:14:20,440 --> 00:14:22,740
So the input signal--

249
00:14:22,740 --> 00:14:26,510
it's kind of arbitrary what I
use besides the output, but

250
00:14:26,510 --> 00:14:31,260
clearly the thing I have control
over is my hand.

251
00:14:31,260 --> 00:14:34,340
So it seems natural to associate
a variable with the

252
00:14:34,340 --> 00:14:37,920
position of my hand,
that would be x.

253
00:14:37,920 --> 00:14:41,110
Also it seems natural to
associate a variable with the

254
00:14:41,110 --> 00:14:44,270
position of the mass, that
could be the output y.

255
00:14:44,270 --> 00:14:46,580
That's not unique.

256
00:14:46,580 --> 00:14:50,340
Every time we try to solve a
problem we ask ourselves,

257
00:14:50,340 --> 00:14:53,630
what's the meaningful input,
what's the meaningful output?

258
00:14:53,630 --> 00:14:55,880
The meaningful output
could have been the

259
00:14:55,880 --> 00:14:57,130
force on the spring.

260
00:15:00,030 --> 00:15:02,840
I'm just sort of arbitrarily
saying for the purpose of my

261
00:15:02,840 --> 00:15:06,000
analysis, I'm going to consider
the input to be the

262
00:15:06,000 --> 00:15:08,140
position of the hand,
the output to be the

263
00:15:08,140 --> 00:15:09,270
position of the mass.

264
00:15:09,270 --> 00:15:11,700
And I'm going to think about the
mass and spring system as

265
00:15:11,700 --> 00:15:14,860
a box that transforms
x into y.

266
00:15:14,860 --> 00:15:17,200
So rather than thinking about
it in terms of free body

267
00:15:17,200 --> 00:15:19,575
diagrams, and kinetic energy,
and potential energy, I'm

268
00:15:19,575 --> 00:15:21,960
going to think there's some
input signal x, and there's

269
00:15:21,960 --> 00:15:24,120
some output signal y.

270
00:15:24,120 --> 00:15:27,500
And what I'd like to do is
given x, calculate y.

271
00:15:30,670 --> 00:15:32,830
OK, bizarre, why would
I do that?

272
00:15:32,830 --> 00:15:35,040
One of the reasons I want to
do that is that it's a very

273
00:15:35,040 --> 00:15:37,180
general way of thinking
about behaviors.

274
00:15:39,980 --> 00:15:42,170
It works for the mass and spring
system, it works for

275
00:15:42,170 --> 00:15:43,980
water tanks.

276
00:15:43,980 --> 00:15:45,700
What happens if I have
water flowing into

277
00:15:45,700 --> 00:15:47,103
a tank that's leaky?

278
00:15:47,103 --> 00:15:49,870
Well, it leaks into another tank
which is leaky, and that

279
00:15:49,870 --> 00:15:52,110
leaks more.

280
00:15:52,110 --> 00:15:55,100
Completely different physics.

281
00:15:55,100 --> 00:15:58,370
Probably wasn't covered
in 8.01.

282
00:15:58,370 --> 00:16:02,050
Probably is something you
could figure out.

283
00:16:02,050 --> 00:16:04,820
The point is that from the
signals and systems point of

284
00:16:04,820 --> 00:16:08,330
view, I'm going to map this
physics, whatever it is, into

285
00:16:08,330 --> 00:16:11,000
this structure.

286
00:16:11,000 --> 00:16:14,490
Think about the tank system as
the system that transforms

287
00:16:14,490 --> 00:16:16,450
some input.

288
00:16:16,450 --> 00:16:20,550
The input is that there's water
spurting for some small

289
00:16:20,550 --> 00:16:22,950
interval of time.

290
00:16:22,950 --> 00:16:26,520
The output is that there's
water coming out.

291
00:16:26,520 --> 00:16:29,180
And the idea is that I'm going
to characterize the system--

292
00:16:29,180 --> 00:16:33,080
whatever it is, as the rule
that transforms the input

293
00:16:33,080 --> 00:16:34,500
signal into the output signal.

294
00:16:37,070 --> 00:16:38,690
Here's a third example.

295
00:16:38,690 --> 00:16:42,100
I could think of a cell
phone system.

296
00:16:42,100 --> 00:16:44,170
Here again, there are very
complicated ways we could

297
00:16:44,170 --> 00:16:45,960
think about the system, but
I'm going to take the

298
00:16:45,960 --> 00:16:49,810
particularly simple approach
called signals and systems.

299
00:16:49,810 --> 00:16:52,300
Then I'm going to characterize
the phone system by the way it

300
00:16:52,300 --> 00:16:58,580
transforms some input sound
into some output sound.

301
00:16:58,580 --> 00:17:00,810
And as you can imagine, there's
a way of thinking

302
00:17:00,810 --> 00:17:03,490
about performance in terms
of that transformation.

303
00:17:03,490 --> 00:17:08,349
Ideally, we would like this to
bear some resemblance to that.

304
00:17:08,349 --> 00:17:10,050
So the point then,
is that we're

305
00:17:10,050 --> 00:17:11,810
going to focus on behaviors.

306
00:17:11,810 --> 00:17:14,440
And to do so, we're going to
think about the signals and

307
00:17:14,440 --> 00:17:16,089
systems approach.

308
00:17:16,089 --> 00:17:19,060
Represent a system, whatever
it is, by the way it

309
00:17:19,060 --> 00:17:22,569
transforms inputs
into outputs.

310
00:17:22,569 --> 00:17:24,730
One of the reasons we
like the approach is

311
00:17:24,730 --> 00:17:25,980
that it's so general.

312
00:17:28,420 --> 00:17:32,860
So you can use it for virtually
any kind of a system

313
00:17:32,860 --> 00:17:37,040
for which you can develop a
mathematical underpinning.

314
00:17:37,040 --> 00:17:39,330
You can use it to analyze
electrical systems, mechanical

315
00:17:39,330 --> 00:17:41,340
systems, optical systems,
acoustic systems, biological

316
00:17:41,340 --> 00:17:44,280
systems, financial systems if
you're on the dark side.

317
00:17:44,280 --> 00:17:51,340
So there's lots of different
kinds of systems that are

318
00:17:51,340 --> 00:17:52,790
amenable to this kind
of approach.

319
00:17:55,390 --> 00:17:59,435
Also, this approach has
a nice modularity.

320
00:18:02,720 --> 00:18:08,020
Having represented a cellphone
by transformation from sound

321
00:18:08,020 --> 00:18:11,220
in to electromagnetic field out,
as illustrated by this

322
00:18:11,220 --> 00:18:14,560
cartoon depicting sound going
in and having a radio wave

323
00:18:14,560 --> 00:18:17,430
transmitting to a tower.

324
00:18:17,430 --> 00:18:20,480
Then we represent tower to tower
communication some way,

325
00:18:20,480 --> 00:18:25,210
maybe via an optical fiber,
maybe via a satellite.

326
00:18:25,210 --> 00:18:28,160
Then tower to cell by the same
kind of reverse transformation

327
00:18:28,160 --> 00:18:30,440
that we used in the first one.

328
00:18:30,440 --> 00:18:33,520
We can piece those all together,
we can treat them as

329
00:18:33,520 --> 00:18:38,100
modules, because each box takes
an input signal and

330
00:18:38,100 --> 00:18:41,260
makes an output signal.

331
00:18:41,260 --> 00:18:45,510
The method is oblivious to
the underlying physics.

332
00:18:45,510 --> 00:18:49,030
That affords us a certain
amount of power.

333
00:18:49,030 --> 00:18:51,540
And in particular, it's
very modular.

334
00:18:51,540 --> 00:18:55,860
You can put together modules
that represent very different

335
00:18:55,860 --> 00:18:57,440
physical substrates.

336
00:19:00,210 --> 00:19:04,670
That allows us to
go back to PCAP.

337
00:19:04,670 --> 00:19:06,860
If the underlying
representations for the

338
00:19:06,860 --> 00:19:11,370
different physical substrates
are the same, we will be able

339
00:19:11,370 --> 00:19:14,670
to-- and we will over the next
three weeks, develop a bunch

340
00:19:14,670 --> 00:19:20,450
of techniques for combining
multiple modules into one.

341
00:19:20,450 --> 00:19:23,780
That provides the same kind of
abstraction and modularity

342
00:19:23,780 --> 00:19:29,020
that we saw in programming
for the last two weeks.

343
00:19:29,020 --> 00:19:30,380
So that's the idea.

344
00:19:30,380 --> 00:19:33,740
What we want to do is represent
a system by the way

345
00:19:33,740 --> 00:19:38,600
it transforms an input signal
to an output signal.

346
00:19:38,600 --> 00:19:43,050
There are many different kinds
of inputs and outputs, but a

347
00:19:43,050 --> 00:19:46,450
fundamental distinction that we
are going to have to make

348
00:19:46,450 --> 00:19:51,140
is continuous time,
and discrete time.

349
00:19:51,140 --> 00:19:53,810
This system works in what
we will refer to

350
00:19:53,810 --> 00:19:55,220
as continuous time.

351
00:19:55,220 --> 00:19:58,950
Because my position of my hand
is a continuous function of

352
00:19:58,950 --> 00:20:00,380
the continuous variable, time.

353
00:20:03,850 --> 00:20:07,120
The robots, by contrast, work
with what we will call,

354
00:20:07,120 --> 00:20:08,710
discrete time.

355
00:20:08,710 --> 00:20:10,870
Steps.

356
00:20:10,870 --> 00:20:13,550
It turns out the math for those
two different approaches

357
00:20:13,550 --> 00:20:15,280
are very different.

358
00:20:15,280 --> 00:20:18,450
And we will focus entirely in
this class on discrete time,

359
00:20:18,450 --> 00:20:21,370
because our area of application
is the robot.

360
00:20:21,370 --> 00:20:24,450
It's not that continuous is
deeper, or harder, or anything

361
00:20:24,450 --> 00:20:26,420
like that, it's different.

362
00:20:26,420 --> 00:20:30,110
So we'll focus on
discrete time.

363
00:20:30,110 --> 00:20:32,290
And the point of today then,
is to develop some

364
00:20:32,290 --> 00:20:38,290
representations for signals and
systems of this free time

365
00:20:38,290 --> 00:20:43,800
nature, that will let us analyze
and predict behaviors

366
00:20:43,800 --> 00:20:45,890
of systems like the
robot system.

367
00:20:48,480 --> 00:20:53,320
The first class of methods for
representing such systems is

368
00:20:53,320 --> 00:20:54,260
difference equations.

369
00:20:54,260 --> 00:20:57,610
Difference equations are a lot
like differential equations,

370
00:20:57,610 --> 00:20:59,110
except there's no differentials,
there's

371
00:20:59,110 --> 00:21:00,690
differences.

372
00:21:00,690 --> 00:21:06,050
Difference equations are the
discrete time analog of

373
00:21:06,050 --> 00:21:10,110
differential equations for
continuous time systems.

374
00:21:10,110 --> 00:21:12,670
Simplest possible
example here.

375
00:21:12,670 --> 00:21:17,410
Say I have an output y, that for
reasons that I don't care

376
00:21:17,410 --> 00:21:21,090
about, I know can be represented
as the difference

377
00:21:21,090 --> 00:21:23,790
between two values
of the input --

378
00:21:23,790 --> 00:21:26,250
x at time n, and x at
time n minus 1.

379
00:21:29,220 --> 00:21:33,280
That's a way to represent the
behavior of a system, a

380
00:21:33,280 --> 00:21:37,710
discrete time system, by using
a difference equation.

381
00:21:37,710 --> 00:21:39,660
That's in fact, almost
a complete

382
00:21:39,660 --> 00:21:40,910
description of the system.

383
00:21:43,990 --> 00:21:46,540
So let me just explain the
way you would use that.

384
00:21:46,540 --> 00:21:47,870
It's almost-- because
I didn't tell you

385
00:21:47,870 --> 00:21:49,120
anything about the input.

386
00:21:52,620 --> 00:21:55,190
I'll tell you something about
the input for the purpose of

387
00:21:55,190 --> 00:21:57,840
example, where I'll
use the simplest

388
00:21:57,840 --> 00:21:59,850
possible input I can imagine.

389
00:21:59,850 --> 00:22:03,990
Something that we'll call
a delta function.

390
00:22:03,990 --> 00:22:05,460
A delta function is a signal.

391
00:22:08,660 --> 00:22:10,910
It's a discrete time signal.

392
00:22:10,910 --> 00:22:14,660
It has the value 1 if the time
index is 0, and has the value

393
00:22:14,660 --> 00:22:17,330
0 everywhere else.

394
00:22:17,330 --> 00:22:20,170
It's, in some sense, the
simplest possible signal that

395
00:22:20,170 --> 00:22:22,600
we could imagine.

396
00:22:22,600 --> 00:22:24,490
So it's natural to
start there.

397
00:22:24,490 --> 00:22:26,930
So what I want to do now is
think about if this were a

398
00:22:26,930 --> 00:22:29,430
characterization of the system,
and if this were the

399
00:22:29,430 --> 00:22:30,530
input to that system?

400
00:22:30,530 --> 00:22:31,790
What would the output be?

401
00:22:31,790 --> 00:22:32,980
That's after all--

402
00:22:32,980 --> 00:22:35,830
that was the question that
I posed at the beginning.

403
00:22:35,830 --> 00:22:39,380
We would like to build a
representation for a system so

404
00:22:39,380 --> 00:22:43,080
that we can predict the output,
given the input.

405
00:22:43,080 --> 00:22:45,940
So how does that work?

406
00:22:45,940 --> 00:22:51,120
So given the difference
equation, all we need to do is

407
00:22:51,120 --> 00:22:52,380
step through it.

408
00:22:52,380 --> 00:22:53,600
OK, it's trivial.

409
00:22:53,600 --> 00:22:57,980
We call that analyzing
by step by step.

410
00:22:57,980 --> 00:23:03,170
So given the difference
equation, given the input

411
00:23:03,170 --> 00:23:08,080
signal, all we need to do is
sequentially go through the

412
00:23:08,080 --> 00:23:11,070
different values of n, and think
about the implication of

413
00:23:11,070 --> 00:23:13,000
the system on that input.

414
00:23:13,000 --> 00:23:19,300
So if I were to use the value
of n, being minus 1, this

415
00:23:19,300 --> 00:23:22,240
general form of the difference
equation tells me that the

416
00:23:22,240 --> 00:23:27,550
minus 1 value of n for the
output is related by this

417
00:23:27,550 --> 00:23:29,030
difference, with the input.

418
00:23:29,030 --> 00:23:31,300
So y of minus 1 is x of minus
1 minus x of minus 2.

419
00:23:33,870 --> 00:23:39,423
Since both of those are 0, it
says that the output at time

420
00:23:39,423 --> 00:23:41,700
minus 1 is 0.

421
00:23:41,700 --> 00:23:43,310
Trivial, right?

422
00:23:43,310 --> 00:23:44,730
Trivial.

423
00:23:44,730 --> 00:23:47,200
And similarly, we can just
iterate through the solution

424
00:23:47,200 --> 00:23:48,860
to the whole signal.

425
00:23:48,860 --> 00:23:53,640
So y of 0 is x of 0 minus
x of minus 1.

426
00:23:53,640 --> 00:23:57,000
x of 0 is that special
one, that is 1.

427
00:23:57,000 --> 00:24:01,630
So now we get 1 minus
0, which is 1.

428
00:24:01,630 --> 00:24:05,280
y of 1 is x of 1 minus x of 0.

429
00:24:05,280 --> 00:24:08,640
Now the special one is on the
other side of the minus sign,

430
00:24:08,640 --> 00:24:09,890
so the answer is minus 1.

431
00:24:13,390 --> 00:24:16,120
y of 2 is x of 2
minus x of 1 --

432
00:24:16,120 --> 00:24:17,470
they're both 0.

433
00:24:17,470 --> 00:24:21,400
And in fact, all the answers
from now on are going to be 0.

434
00:24:21,400 --> 00:24:25,910
So what I just did is a
trivial example of --

435
00:24:25,910 --> 00:24:30,380
I use a difference equation to
represent a system, and I

436
00:24:30,380 --> 00:24:33,275
figured out the output signal
from the input signal.

437
00:24:36,290 --> 00:24:38,840
That's the method
that we call--

438
00:24:38,840 --> 00:24:41,680
that's the representation for
discrete time systems that we

439
00:24:41,680 --> 00:24:43,220
refer to as difference
equations.

440
00:24:43,220 --> 00:24:46,180
Difference equations
are very powerful.

441
00:24:46,180 --> 00:24:49,570
As we will see, of all the
representations we look at,

442
00:24:49,570 --> 00:24:52,140
difference equations is the most
compact representation.

443
00:24:54,650 --> 00:24:57,120
But there are features of other
kinds of representations

444
00:24:57,120 --> 00:24:58,980
that are also valuable.

445
00:24:58,980 --> 00:25:00,560
So the next representation
I want to look

446
00:25:00,560 --> 00:25:01,810
at is a block diagram.

447
00:25:04,280 --> 00:25:09,130
What I'm trying to show here is
a picture, a diagram, that

448
00:25:09,130 --> 00:25:11,900
represents the same system that
we just analyzed with

449
00:25:11,900 --> 00:25:15,100
difference equations.

450
00:25:15,100 --> 00:25:17,380
Here though, I'm thinking
about it as

451
00:25:17,380 --> 00:25:20,350
a signal flow path.

452
00:25:20,350 --> 00:25:23,620
I'm thinking about what's the
cascade of operations that you

453
00:25:23,620 --> 00:25:29,540
need to do on each sample in
order to get from the input to

454
00:25:29,540 --> 00:25:31,860
the output?

455
00:25:31,860 --> 00:25:34,520
So the difference equation said
every value of the output

456
00:25:34,520 --> 00:25:36,200
should be equal to the
corresponding value of the

457
00:25:36,200 --> 00:25:40,950
input less the value
before that.

458
00:25:40,950 --> 00:25:44,110
I represent that in a block
diagram by saying there's a

459
00:25:44,110 --> 00:25:46,660
straight through path, y of
n is equal to x of n.

460
00:25:46,660 --> 00:25:51,060
The plus just adds the signals
on these two paths.

461
00:25:51,060 --> 00:25:53,360
So y of n is equal to x of n.

462
00:25:53,360 --> 00:25:56,770
Subtract out, because I'm
multiplying by minus 1.

463
00:25:56,770 --> 00:26:00,880
Delay, so I'm getting
the one from before.

464
00:26:00,880 --> 00:26:03,660
So this block diagram just is
a symbolic representation of

465
00:26:03,660 --> 00:26:04,910
that difference equation.

466
00:26:07,300 --> 00:26:08,770
The value of the
block diagram--

467
00:26:08,770 --> 00:26:11,490
we'll see several of them,
but one of them is focus

468
00:26:11,490 --> 00:26:13,180
on signal flow path.

469
00:26:13,180 --> 00:26:17,640
If you want to visualize the
transformation from input to

470
00:26:17,640 --> 00:26:23,990
output, the block diagram can
provide visual insight into

471
00:26:23,990 --> 00:26:27,350
what that transformation
is like.

472
00:26:27,350 --> 00:26:30,950
So as before, if I gave you
this representation rather

473
00:26:30,950 --> 00:26:33,720
than the difference equation,
you could still step by step

474
00:26:33,720 --> 00:26:35,280
and figure out the
way it worked.

475
00:26:35,280 --> 00:26:36,880
It's still easy.

476
00:26:36,880 --> 00:26:39,040
There's one new caveat here.

477
00:26:39,040 --> 00:26:44,130
We have to start the
system in a state.

478
00:26:44,130 --> 00:26:47,130
The state that we will usually
talk about is what we will

479
00:26:47,130 --> 00:26:48,880
call, at rest.

480
00:26:48,880 --> 00:26:54,560
At rest just means all the
outputs of all the delays are

481
00:26:54,560 --> 00:26:55,810
initially 0.

482
00:26:58,290 --> 00:27:01,130
So that specifies the state of
the system at the time the

483
00:27:01,130 --> 00:27:04,280
signal was turned on.

484
00:27:04,280 --> 00:27:07,000
So the system is at rest,
which means that all the

485
00:27:07,000 --> 00:27:10,440
delays start out with
output equal to 0.

486
00:27:10,440 --> 00:27:16,530
So at rest means this delay
has an output of 0.

487
00:27:16,530 --> 00:27:20,390
Well, if I tell you the output
is 0 times 0 for this delay,

488
00:27:20,390 --> 00:27:23,210
then it's a simple matter of
stepping through what is the

489
00:27:23,210 --> 00:27:25,710
output for each corresponding
input?

490
00:27:25,710 --> 00:27:27,420
So if I--

491
00:27:27,420 --> 00:27:29,930
the special value of the delta
function is that it's

492
00:27:29,930 --> 00:27:31,910
1 at the time 0.

493
00:27:31,910 --> 00:27:35,190
So at the time 0, there's
1 coming in.

494
00:27:35,190 --> 00:27:38,700
That 1 makes it through
the adder, adds to 0.

495
00:27:38,700 --> 00:27:42,210
Well, this is 0 because
it was at rest.

496
00:27:42,210 --> 00:27:44,775
So the 1 adds to 0 and
the output becomes 1.

497
00:27:47,950 --> 00:27:50,750
Notice that the 1 also goes
down this path, and goes

498
00:27:50,750 --> 00:27:54,442
through the gain of minus
1 to give me minus 1.

499
00:27:54,442 --> 00:27:57,520
But I'm in step 0.

500
00:27:57,520 --> 00:28:03,730
So at step 0, the output of the
delay is 0, not minus 1.

501
00:28:03,730 --> 00:28:08,880
So the output then, for time
equals 0, is y equals 1.

502
00:28:08,880 --> 00:28:10,450
Just like we solved for the
difference equation--

503
00:28:10,450 --> 00:28:13,250
after all, I'm hypothesizing
that those two systems are the

504
00:28:13,250 --> 00:28:15,940
same, they better give
me the same answer.

505
00:28:15,940 --> 00:28:23,000
So then at the next instant, as
the time index goes from 0

506
00:28:23,000 --> 00:28:26,310
to 1, two things happen.

507
00:28:26,310 --> 00:28:31,130
The input goes from
1 to 0, and the

508
00:28:31,130 --> 00:28:32,820
delay box gets updated.

509
00:28:32,820 --> 00:28:36,470
The delay is now reporting
to me the value

510
00:28:36,470 --> 00:28:38,780
that was at its input.

511
00:28:38,780 --> 00:28:42,180
So the output of the delay,
which had been 0 because it

512
00:28:42,180 --> 00:28:44,170
was at rest, becomes minus 1.

513
00:28:48,690 --> 00:28:50,940
So then what happens?

514
00:28:50,940 --> 00:28:56,300
The 1 goes to 0, the 0 goes to
minus 1, the 0 adds to minus

515
00:28:56,300 --> 00:29:00,130
1, and we get an answer
which is minus 1.

516
00:29:05,010 --> 00:29:09,390
Then the input becomes 0.

517
00:29:09,390 --> 00:29:12,120
That 0 comes down here,
the minus 1 goes to 0.

518
00:29:12,120 --> 00:29:15,290
We end up with 0 being added to
0, and the next answer is

519
00:29:15,290 --> 00:29:18,360
0, et cetera.

520
00:29:18,360 --> 00:29:21,620
So the idea then, is that you
can step through the block

521
00:29:21,620 --> 00:29:23,610
diagram representation, just
like you would a difference

522
00:29:23,610 --> 00:29:26,230
equation, it's just that now
we're thinking about these

523
00:29:26,230 --> 00:29:31,270
blocks characterizing the
system, rather than thinking

524
00:29:31,270 --> 00:29:34,745
of math as characterizing
the system.

525
00:29:37,690 --> 00:29:41,080
Why on earth would
you do that?

526
00:29:41,080 --> 00:29:42,720
What's good and bad?

527
00:29:42,720 --> 00:29:46,350
What's the relative merits of
difference equations verses

528
00:29:46,350 --> 00:29:48,230
block diagrams?

529
00:29:48,230 --> 00:29:50,830
Take 30 seconds, talk to your
neighbor, figure out some good

530
00:29:50,830 --> 00:29:51,790
feature of each.

531
00:29:51,790 --> 00:29:53,040
AUDIENCE: [INAUDIBLE]

532
00:31:16,200 --> 00:31:18,060
PROFESSOR: OK, we'll start
with the easy one.

533
00:31:18,060 --> 00:31:20,340
What's a feature, what's a
property of the difference

534
00:31:20,340 --> 00:31:22,421
equation that makes
it very good.

535
00:31:22,421 --> 00:31:25,367
I already said it, so.

536
00:31:25,367 --> 00:31:26,840
What's good about the
difference equation?

537
00:31:26,840 --> 00:31:27,822
Yeah.

538
00:31:27,822 --> 00:31:30,280
AUDIENCE: They can be solved
mathematically.

539
00:31:30,280 --> 00:31:33,780
PROFESSOR: They can be solved
mathematically.

540
00:31:33,780 --> 00:31:36,300
The block diagram could
be solved, maybe not

541
00:31:36,300 --> 00:31:38,350
mathematically, but kind of.

542
00:31:38,350 --> 00:31:40,250
Could you refine that
a little more?

543
00:31:40,250 --> 00:31:42,730
What's special about difference
equations that's

544
00:31:42,730 --> 00:31:44,045
different from block diagrams?

545
00:31:47,698 --> 00:31:51,020
Oh come on, I said it.

546
00:31:51,020 --> 00:31:51,680
AUDIENCE: Use math?

547
00:31:51,680 --> 00:31:54,013
PROFESSOR: They use
math, yes yes.

548
00:31:54,013 --> 00:31:57,380
They're concise, a
little, right?

549
00:31:57,380 --> 00:32:00,410
It's a very simple expression
to say that.

550
00:32:00,410 --> 00:32:03,710
It's by contrast, a bit more
complicated to draw this

551
00:32:03,710 --> 00:32:04,290
picture, right?

552
00:32:04,290 --> 00:32:06,450
It's mathematically
concise, right?

553
00:32:06,450 --> 00:32:08,500
It's completely accurate,

554
00:32:08,500 --> 00:32:14,070
self-contained, concise, small.

555
00:32:14,070 --> 00:32:17,370
It's a very concise
representation of a system.

556
00:32:17,370 --> 00:32:19,210
So why would we want to
use block diagrams?

557
00:32:19,210 --> 00:32:21,630
Can anybody think of any good
reason for block diagrams

558
00:32:21,630 --> 00:32:24,965
other than Freeman's up front
saying, do block diagrams?

559
00:32:24,965 --> 00:32:26,360
AUDIENCE: Electrical
engineering?

560
00:32:26,360 --> 00:32:28,685
PROFESSOR: Electrical
engineering.

561
00:32:28,685 --> 00:32:31,980
There should be a deeper
reason, I would hope.

562
00:32:31,980 --> 00:32:33,300
I don't disagree with
that reason.

563
00:32:36,270 --> 00:32:39,200
Why do electrical engineers
like this?

564
00:32:39,200 --> 00:32:40,120
Yes.

565
00:32:40,120 --> 00:32:42,880
AUDIENCE: It's a more physical
representation of this.

566
00:32:42,880 --> 00:32:44,980
PROFESSOR: It's more physical?

567
00:32:44,980 --> 00:32:47,207
Is there anything that
you can see that you

568
00:32:47,207 --> 00:32:48,457
can't see in math?

569
00:32:52,900 --> 00:32:54,385
Yes.

570
00:32:54,385 --> 00:32:56,035
AUDIENCE: In the way that you're
actually going to be

571
00:32:56,035 --> 00:32:56,365
programming it.

572
00:32:56,365 --> 00:32:59,335
Like, you're gonna make the
delay machine, you're gonna

573
00:32:59,335 --> 00:33:01,810
make the state machine that
multiplies them by negative 1

574
00:33:01,810 --> 00:33:03,790
and you're gonna see how
to connect them.

575
00:33:03,790 --> 00:33:05,275
PROFESSOR: That's a
really good point.

576
00:33:05,275 --> 00:33:10,770
It's kind of isomorphic
to the implementation.

577
00:33:10,770 --> 00:33:12,630
Everybody get that?

578
00:33:12,630 --> 00:33:14,850
It's kind of a picture
of the way you

579
00:33:14,850 --> 00:33:18,100
would build the system.

580
00:33:18,100 --> 00:33:21,130
Along those lines, there's
some bit of information--

581
00:33:21,130 --> 00:33:23,140
there's actually more
information in this one, than

582
00:33:23,140 --> 00:33:25,346
there is in that one.

583
00:33:25,346 --> 00:33:31,690
There is exactly one bit more
information in the block

584
00:33:31,690 --> 00:33:32,940
diagram, what's that bit?

585
00:33:38,520 --> 00:33:39,876
AUDIENCE: Delay?

586
00:33:39,876 --> 00:33:41,870
PROFESSOR: Delay?

587
00:33:41,870 --> 00:33:44,960
There's kind of delay
by the n minus 1.

588
00:33:44,960 --> 00:33:46,274
Yeah.

589
00:33:46,274 --> 00:33:47,524
AUDIENCE: [UNINTELLIGIBLE]

590
00:33:49,648 --> 00:33:52,540
PROFESSOR: The input and
output are explicit.

591
00:33:52,540 --> 00:33:53,986
Yes.

592
00:33:53,986 --> 00:33:58,980
The arrows are the
big difference.

593
00:33:58,980 --> 00:34:01,920
You can't tell from the
difference equation, what's

594
00:34:01,920 --> 00:34:05,470
the input and the output?

595
00:34:05,470 --> 00:34:08,020
You can tell from the block
diagram, what is the input and

596
00:34:08,020 --> 00:34:12,080
the output by the direction
of the arrows.

597
00:34:12,080 --> 00:34:14,205
So there's more information
in the block diagram.

598
00:34:17,870 --> 00:34:19,949
There's another way of thinking
about it, and this is

599
00:34:19,949 --> 00:34:21,929
kind of a summary of several
comments that

600
00:34:21,929 --> 00:34:23,540
came from the audience.

601
00:34:23,540 --> 00:34:25,860
The difference equation
is declarative.

602
00:34:25,860 --> 00:34:29,555
It tells you a true statement
about what the system will do.

603
00:34:32,820 --> 00:34:35,790
The block diagram
is imperative.

604
00:34:35,790 --> 00:34:39,909
It tells you what to do now.

605
00:34:39,909 --> 00:34:41,630
Take the input, put
into an adder.

606
00:34:41,630 --> 00:34:43,370
Take the input, multiply
by minus 1.

607
00:34:43,370 --> 00:34:44,239
Put it into a delay.

608
00:34:44,239 --> 00:34:46,530
Take the delay output,
put it into an adder.

609
00:34:46,530 --> 00:34:52,120
The representation with a block
diagram is imperative.

610
00:34:52,120 --> 00:34:54,889
It tells you what to do.

611
00:34:54,889 --> 00:34:58,400
So there's extra information,
but it comes at a cost.

612
00:34:58,400 --> 00:35:00,250
It's a more complicated
representation.

613
00:35:00,250 --> 00:35:06,820
It's a whole picture instead
of just an equation.

614
00:35:06,820 --> 00:35:09,260
What we'd like to do, and what
I'm going to do now, is

615
00:35:09,260 --> 00:35:11,980
develop a different mathematical
approach where

616
00:35:11,980 --> 00:35:18,050
you get a difference equation
that has the same properties

617
00:35:18,050 --> 00:35:24,880
of concision, the same
conciseness, but also contains

618
00:35:24,880 --> 00:35:28,860
all of the information that
was in the block diagram.

619
00:35:28,860 --> 00:35:32,390
And the way to do that is
to change our focus.

620
00:35:34,960 --> 00:35:38,940
And this is the big abstraction
of the day.

621
00:35:38,940 --> 00:35:43,370
Change our focus from thinking
about samples, to thinking

622
00:35:43,370 --> 00:35:45,430
about signals.

623
00:35:45,430 --> 00:35:50,340
Stop thinking about x of n,
start thinking about the

624
00:35:50,340 --> 00:35:53,310
input signal x.

625
00:35:53,310 --> 00:35:58,360
This is the same kind of
lumping that was key to

626
00:35:58,360 --> 00:36:01,770
abstraction in Python.

627
00:36:01,770 --> 00:36:04,390
Put all the interesting data
together into a list, put all

628
00:36:04,390 --> 00:36:07,620
the interesting operations
together into a definition.

629
00:36:07,620 --> 00:36:10,520
Here put all of the interesting
samples together

630
00:36:10,520 --> 00:36:13,890
into one signal.

631
00:36:13,890 --> 00:36:17,980
So what we want to do, is
develop a math by which we can

632
00:36:17,980 --> 00:36:22,570
operate on signals instead
of samples.

633
00:36:22,570 --> 00:36:26,500
So what I'm going to do is
replace the representation x

634
00:36:26,500 --> 00:36:31,180
of n, little x of n, with cap-X.
Cap-X means, all of the

635
00:36:31,180 --> 00:36:36,830
n's, it's the signal X. Cap-Y
means the signal Y. And I'm

636
00:36:36,830 --> 00:36:38,300
going to reinterpret
all the boxes.

637
00:36:41,860 --> 00:36:46,370
This box means, take this
signal, the whole thing, all n

638
00:36:46,370 --> 00:36:51,660
values on it, multiply it sample
by sample, by minus 1.

639
00:36:51,660 --> 00:36:55,710
Flip the whole signal
upside down.

640
00:36:55,710 --> 00:36:58,240
So I'm going to reinterpret all
of the operations on the

641
00:36:58,240 --> 00:37:02,220
block diagram in terms of
signals, rather than samples.

642
00:37:05,700 --> 00:37:07,910
To do that, I need a
representation--

643
00:37:07,910 --> 00:37:12,610
a mathematical representation,
for the delay box.

644
00:37:12,610 --> 00:37:17,730
And I'm going to call that R,
the right shift operator.

645
00:37:17,730 --> 00:37:22,700
If you apply the right shift
operator to a single X, it

646
00:37:22,700 --> 00:37:27,040
takes the whole signal X and
shifts it to the right one.

647
00:37:27,040 --> 00:37:29,830
That's all it does.

648
00:37:29,830 --> 00:37:35,220
So I'm going to say Y equals
R applied to X, or more

649
00:37:35,220 --> 00:37:37,970
abbreviated, RX.

650
00:37:37,970 --> 00:37:42,760
Simply says, let Y represent the
signal that is the same as

651
00:37:42,760 --> 00:37:45,190
X, except every sample was
shifted to the right.

652
00:37:45,190 --> 00:37:48,890
The entire signal was shifted
to the right.

653
00:37:48,890 --> 00:37:50,990
That's going to let me
represent this block

654
00:37:50,990 --> 00:37:54,680
diagram this way.

655
00:37:54,680 --> 00:37:56,570
Y--

656
00:37:56,570 --> 00:38:01,690
the whole signal Y, is the sum
of the whole signal X,

657
00:38:01,690 --> 00:38:10,970
subtract out R applied to X.
Or, even more concisely,

658
00:38:10,970 --> 00:38:20,140
calculate Y by applying to
X the operator 1 minus R.

659
00:38:20,140 --> 00:38:21,950
So I'm thinking now
of an operator.

660
00:38:21,950 --> 00:38:26,760
An operator is not something
that works on a number.

661
00:38:26,760 --> 00:38:31,730
Operations work on numbers,
operators operate on signals.

662
00:38:31,730 --> 00:38:33,880
So I'm thinking about
operator expression.

663
00:38:33,880 --> 00:38:37,730
I'm going to try to formulate
the transformation from the

664
00:38:37,730 --> 00:38:42,150
input to the output in
terms of operators.

665
00:38:42,150 --> 00:38:46,300
The way I take X, which is the
input, and turn it into Y, is

666
00:38:46,300 --> 00:38:53,480
to operate on it with the
operator 1 minus R.

667
00:38:53,480 --> 00:38:57,110
OK, just to see that you're with
me, connecting signals

668
00:38:57,110 --> 00:39:00,770
and samples, assume the
Y is RX, which of the

669
00:39:00,770 --> 00:39:03,700
following is also true?

670
00:39:03,700 --> 00:39:05,020
Take 30 seconds, talk
to your neighbor.

671
00:39:05,020 --> 00:39:06,755
Figure out some number
-- (1) through (5).

672
00:39:06,755 --> 00:39:08,005
AUDIENCE: [INAUDIBLE]

673
00:41:33,350 --> 00:41:36,980
PROFESSOR: OK, so which
representation works best?

674
00:41:36,980 --> 00:41:39,882
(1), (2), (3), (4), or
none of the above?

675
00:41:39,882 --> 00:41:41,754
Everybody raise a hand,
tell me some number.

676
00:41:45,030 --> 00:41:47,150
OK, virtually 100% correct.

677
00:41:47,150 --> 00:41:51,750
The answer was (2), why
is the answer (2)?

678
00:41:51,750 --> 00:41:53,225
Can somebody explain
that concisely?

679
00:41:57,636 --> 00:41:58,480
No no,no.

680
00:41:58,480 --> 00:42:00,170
I asked that wrong, of
course everybody

681
00:42:00,170 --> 00:42:01,410
can explain it concisely.

682
00:42:01,410 --> 00:42:03,730
Do I have a volunteer to
explain it concisely?

683
00:42:08,326 --> 00:42:09,254
Yes.

684
00:42:09,254 --> 00:42:12,760
AUDIENCE: The R operator just
shifts all of the values in X

685
00:42:12,760 --> 00:42:14,072
of n to the right.

686
00:42:14,072 --> 00:42:17,030
So you just add 1 to each
of these basically?

687
00:42:17,030 --> 00:42:19,000
PROFESSOR: So you think about
it-- so a good way to think

688
00:42:19,000 --> 00:42:22,070
about this is to think
about simple cases.

689
00:42:22,070 --> 00:42:22,450
Right?

690
00:42:22,450 --> 00:42:24,870
That's the same thing I
talked about earlier.

691
00:42:24,870 --> 00:42:26,000
What's a simple case?

692
00:42:26,000 --> 00:42:28,030
Well what if X--

693
00:42:28,030 --> 00:42:32,220
let's imagine that
X is simple.

694
00:42:32,220 --> 00:42:36,720
So let's say that X
looks like that.

695
00:42:36,720 --> 00:42:40,340
So X is delta.

696
00:42:40,340 --> 00:42:43,510
What would happen, what
is the signal RX?

697
00:42:48,250 --> 00:42:49,845
It's a right shift operator.

698
00:42:49,845 --> 00:42:51,888
So what does the signal
RX look like?

699
00:42:55,030 --> 00:42:57,090
Shifted to the right, right?

700
00:42:57,090 --> 00:42:58,600
That's the whole point.

701
00:42:58,600 --> 00:43:04,660
So the right shift operator
gives you that signal, and

702
00:43:04,660 --> 00:43:13,250
we've said that that's Y. So is
it true that Y of n is X of

703
00:43:13,250 --> 00:43:16,330
n, for all n?

704
00:43:16,330 --> 00:43:17,790
No.

705
00:43:17,790 --> 00:43:20,440
Is it true that Y of (n
plus 1) is equal to X

706
00:43:20,440 --> 00:43:22,560
of n for all n?

707
00:43:22,560 --> 00:43:24,075
Well, is it true
for n equals 0?

708
00:43:32,940 --> 00:43:41,170
So if we did n equals 0 we get Y
of 1, which happens to be 1.

709
00:43:41,170 --> 00:43:43,645
And X of 0, which also
happens to be 1.

710
00:43:46,380 --> 00:43:50,890
And if we choose any other
n, we would get two 0's.

711
00:43:50,890 --> 00:43:54,100
So at least for this simple
case, and it seems to be true,

712
00:43:54,100 --> 00:43:58,510
and if you think about building
upon this simple

713
00:43:58,510 --> 00:44:00,480
case, you can convince yourself
that number (2) is

714
00:44:00,480 --> 00:44:01,450
always true.

715
00:44:01,450 --> 00:44:04,970
And in fact, the general rule
is going to be that the left

716
00:44:04,970 --> 00:44:07,910
hand side has to have a number
that's bigger than

717
00:44:07,910 --> 00:44:10,680
the right hand side.

718
00:44:10,680 --> 00:44:12,270
Which is only true
for number (2).

719
00:44:15,670 --> 00:44:20,420
So the idea then, is that by
changing our focus, by looking

720
00:44:20,420 --> 00:44:24,020
not at samples, but looking
instead at signals, we can

721
00:44:24,020 --> 00:44:29,520
generate an algebra that looks
for all the world like

722
00:44:29,520 --> 00:44:31,410
difference equations.

723
00:44:31,410 --> 00:44:35,940
Except it knows the direction
from the input to the output.

724
00:44:35,940 --> 00:44:39,210
So it's more powerful.

725
00:44:39,210 --> 00:44:42,890
And in fact, this new algebra
is going to obey some very

726
00:44:42,890 --> 00:44:47,920
simple properties which we
can get a hint at here.

727
00:44:47,920 --> 00:44:51,180
If we were to cascade two
systems, imagine this system

728
00:44:51,180 --> 00:44:53,930
which looks just like the system
we've been looking at,

729
00:44:53,930 --> 00:44:57,610
but it's cascaded
with a clone.

730
00:44:57,610 --> 00:44:59,845
The question is, what would be
the behavior of that cascade?

731
00:45:02,350 --> 00:45:06,250
Well, according to our operator
representation, this

732
00:45:06,250 --> 00:45:15,600
Y1 signal is just the 1 minus
R operator applied to X.

733
00:45:15,600 --> 00:45:20,990
Analogously, the Y2 signal
should be a similar 1 minus R

734
00:45:20,990 --> 00:45:26,540
operator applied to the Y1
signal, which gives us a very

735
00:45:26,540 --> 00:45:29,065
concise representation
for the cascade.

736
00:45:31,800 --> 00:45:34,880
The point of the slide is that
the operator representation

737
00:45:34,880 --> 00:45:38,280
gives us a representation that
is just as compact as

738
00:45:38,280 --> 00:45:39,530
difference equations.

739
00:45:41,970 --> 00:45:46,050
It has other features, that it
can be manipulated just like

740
00:45:46,050 --> 00:45:48,910
difference equations.

741
00:45:48,910 --> 00:45:52,070
So if we continue with this same
example and try to think

742
00:45:52,070 --> 00:45:57,850
of the transformation on a
sample level, we could say

743
00:45:57,850 --> 00:46:05,585
that Y2 is Y1, the straight
path, minus Y1 delayed.

744
00:46:08,160 --> 00:46:12,510
But then we could substitute for
Y1 of n, that Y1 of n is X

745
00:46:12,510 --> 00:46:19,980
of n, this path, subtract
X of (n minus 1).

746
00:46:19,980 --> 00:46:24,370
Similarly, collapse, and we
get a simple expression.

747
00:46:27,340 --> 00:46:29,640
Now if we think about that same
sequence of operations in

748
00:46:29,640 --> 00:46:36,090
operator notation, we get a
much simpler expression.

749
00:46:36,090 --> 00:46:42,080
Throw away the index arithmetic,
it's just R. So

750
00:46:42,080 --> 00:46:47,970
the Y2 operator is 1 minus R
applied to the Y1 signal.

751
00:46:47,970 --> 00:46:51,870
The Y1 signal is 1 minus R
applied to the X signal.

752
00:46:51,870 --> 00:46:57,180
The total is 1 minus R the
operator squared, which by

753
00:46:57,180 --> 00:47:02,320
polynomial math is just 1 minus
2R plus R squared, the

754
00:47:02,320 --> 00:47:04,870
same thing we got there.

755
00:47:04,870 --> 00:47:08,560
The point is, the operator
notation is just as compact as

756
00:47:08,560 --> 00:47:10,515
the difference equation
representation.

757
00:47:13,400 --> 00:47:14,835
And it contains all
the information

758
00:47:14,835 --> 00:47:18,110
that's in block diagrams.

759
00:47:18,110 --> 00:47:23,410
And it's just as easy to
manipulate as a polynomial.

760
00:47:23,410 --> 00:47:27,630
So it's got lots of features
that make it superior to

761
00:47:27,630 --> 00:47:30,450
difference equations.

762
00:47:30,450 --> 00:47:34,550
The most important of which,
is you will be able to

763
00:47:34,550 --> 00:47:39,670
understand all systems that we
represent using the R operator

764
00:47:39,670 --> 00:47:41,970
using polynomial arithmetic,
something you

765
00:47:41,970 --> 00:47:44,870
learned in high school.

766
00:47:44,870 --> 00:47:47,300
There's nothing new here.

767
00:47:47,300 --> 00:47:48,290
That's what we like.

768
00:47:48,290 --> 00:47:53,160
Representations that simplify
the task of finding an answer.

769
00:47:53,160 --> 00:47:56,500
We'll be able to find the
answer to these operator

770
00:47:56,500 --> 00:47:58,640
expressions by treating
them as polynomials.

771
00:48:04,010 --> 00:48:06,560
So you can get a feeling for the
way that works by looking

772
00:48:06,560 --> 00:48:07,650
here, the power of this.

773
00:48:07,650 --> 00:48:10,580
So the power here is that, among
other things, you'll be

774
00:48:10,580 --> 00:48:15,530
able to use the operator
representation to prove

775
00:48:15,530 --> 00:48:18,050
equivalences.

776
00:48:18,050 --> 00:48:21,010
The idea is that here's a
system that we looked at

777
00:48:21,010 --> 00:48:26,750
before, that was the cascade of
two simple delay systems.

778
00:48:26,750 --> 00:48:31,980
Here's a somewhat more
complicated, somewhat simpler,

779
00:48:31,980 --> 00:48:34,890
representation.

780
00:48:34,890 --> 00:48:38,520
The point is, it's different.

781
00:48:38,520 --> 00:48:41,490
And if we compare the operator
representations for the two,

782
00:48:41,490 --> 00:48:44,660
we see that they are the same.

783
00:48:44,660 --> 00:48:47,530
And what I'm about to prove,
is that when the operator

784
00:48:47,530 --> 00:48:51,120
representations are the same,
the systems represent the same

785
00:48:51,120 --> 00:48:51,940
transformations--

786
00:48:51,940 --> 00:48:54,910
provided they all
start at rest.

787
00:48:54,910 --> 00:48:57,100
The provided is important.

788
00:48:57,100 --> 00:49:01,160
Obviously since they have
different delays in them, if

789
00:49:01,160 --> 00:49:06,090
the delays didn't all start out
at 0, the differences in

790
00:49:06,090 --> 00:49:08,890
the delays could propagate
into the output.

791
00:49:08,890 --> 00:49:11,880
So all of the statements that
I'm making are premised on the

792
00:49:11,880 --> 00:49:13,455
idea of initial rest.

793
00:49:16,580 --> 00:49:19,680
The other important thing to
remember about operators is

794
00:49:19,680 --> 00:49:24,510
that it's a higher level
of abstraction.

795
00:49:24,510 --> 00:49:28,450
We can think about the operator
as composing things,

796
00:49:28,450 --> 00:49:30,950
but the things that are composed
are whole signals,

797
00:49:30,950 --> 00:49:32,220
not samples.

798
00:49:32,220 --> 00:49:34,200
And here's an illustration of
how to think about that

799
00:49:34,200 --> 00:49:36,150
previous example.

800
00:49:36,150 --> 00:49:38,740
How do you think about this
transformation, 1 minus 2R

801
00:49:38,740 --> 00:49:40,710
plus R squared.

802
00:49:40,710 --> 00:49:43,730
What happens when you apply
that operator to an

803
00:49:43,730 --> 00:49:45,830
input signal X?

804
00:49:45,830 --> 00:49:50,020
Well let's say that X was
our unit sample signal.

805
00:49:50,020 --> 00:49:53,570
In order to apply this operator
1 minus 2R plus R

806
00:49:53,570 --> 00:49:56,960
squared, all we need to do is
think about each component.

807
00:49:56,960 --> 00:50:03,120
1 times X is X. Minus 2R applied
to X is minus 2RX.

808
00:50:03,120 --> 00:50:07,790
Plus R squared X is just plus
R squared X. So we start out

809
00:50:07,790 --> 00:50:12,170
with X, which is a unit sample,
minus 2RX means shift

810
00:50:12,170 --> 00:50:16,540
it to the right and multiply
by minus 2.

811
00:50:16,540 --> 00:50:21,390
Shift it to the right,
multiply by minus 2.

812
00:50:21,390 --> 00:50:26,050
Plus R squared X means shift
it twice to the right.

813
00:50:26,050 --> 00:50:30,430
So the result, this operator
1 minus 2R plus R squared

814
00:50:30,430 --> 00:50:33,230
applied to X is just the
sum of these things.

815
00:50:33,230 --> 00:50:36,410
So you can think about the
operator expression, it's just

816
00:50:36,410 --> 00:50:40,680
like algebra, except that
the elements are

817
00:50:40,680 --> 00:50:42,110
signals, not samples.

818
00:50:46,200 --> 00:50:49,220
And as I alluded previously,
you can make powerful

819
00:50:49,220 --> 00:50:52,680
statements about the way these
operators work which map

820
00:50:52,680 --> 00:50:57,100
isomorphically onto
polynomial math.

821
00:50:57,100 --> 00:51:01,160
So for example, it's easy to
prove that if you were to

822
00:51:01,160 --> 00:51:10,130
cascade the 1 minus R operator
with R. So start with X, apply

823
00:51:10,130 --> 00:51:20,580
1 minus R. Start with X, apply
1 minus R. Then apply R.

824
00:51:20,580 --> 00:51:24,210
That's going to result in the
same signal, assuming initial

825
00:51:24,210 --> 00:51:29,390
rest, as if you were to
flip those operators.

826
00:51:29,390 --> 00:51:34,540
The way I can see that is by
thinking about signal flow.

827
00:51:34,540 --> 00:51:36,780
You'll remember that I said,
one of the features, one of

828
00:51:36,780 --> 00:51:39,610
the powers of the block diagram
representation is that

829
00:51:39,610 --> 00:51:42,100
we can look at signal
flow paths.

830
00:51:42,100 --> 00:51:45,920
We can use that as a way
of proving things.

831
00:51:45,920 --> 00:51:48,750
This system has two signal flow
paths, the one that goes

832
00:51:48,750 --> 00:51:52,010
straight through that way, and
the one that goes down this

833
00:51:52,010 --> 00:51:53,260
way and up that way.

834
00:51:56,240 --> 00:51:59,370
Because of the addition, all it
does-- the adder just adds

835
00:51:59,370 --> 00:52:01,390
the result of those
two flow paths.

836
00:52:01,390 --> 00:52:04,960
So the first flow path
introduces one delay, the

837
00:52:04,960 --> 00:52:09,620
second flow path inverts
and puts in two delays.

838
00:52:09,620 --> 00:52:13,910
So there are two ways to get
from the input to the output.

839
00:52:13,910 --> 00:52:16,420
Similarly here, there are two
ways to get from the input to

840
00:52:16,420 --> 00:52:17,100
the output.

841
00:52:17,100 --> 00:52:19,450
One of them goes through a delay
and then goes through

842
00:52:19,450 --> 00:52:21,480
the adder, the other
goes through two

843
00:52:21,480 --> 00:52:23,840
delays at a minus 1.

844
00:52:23,840 --> 00:52:26,480
But that's the same two
signal paths that

845
00:52:26,480 --> 00:52:28,130
were in the top one.

846
00:52:28,130 --> 00:52:31,150
So that's a way of using the
block diagram to prove a

847
00:52:31,150 --> 00:52:33,890
relationship about
the operator.

848
00:52:33,890 --> 00:52:38,040
What I've just showed, is
that the operators obey

849
00:52:38,040 --> 00:52:40,180
commutativity.

850
00:52:40,180 --> 00:52:42,780
So what I was able to show is
that I can commute these two

851
00:52:42,780 --> 00:52:43,940
operators--

852
00:52:43,940 --> 00:52:46,105
doing a general proof is
slightly more complicated, I

853
00:52:46,105 --> 00:52:48,140
proved it in a special case.

854
00:52:48,140 --> 00:52:49,890
But the general case
works too.

855
00:52:52,930 --> 00:52:57,600
Just like polynomials,
operators commute.

856
00:52:57,600 --> 00:53:01,640
And I indicated why you should
think that's true by thinking

857
00:53:01,640 --> 00:53:04,630
about signal flow paths.

858
00:53:04,630 --> 00:53:07,220
Multiplication distributes
over addition.

859
00:53:07,220 --> 00:53:10,910
I apologize, the diagram
in your notes is wrong.

860
00:53:10,910 --> 00:53:12,770
This is right.

861
00:53:12,770 --> 00:53:14,420
I will always post the notes--

862
00:53:14,420 --> 00:53:17,910
I get up in the morning, I
make coffee, I read the

863
00:53:17,910 --> 00:53:20,090
lecture notes, and I say,
oh my goodness,

864
00:53:20,090 --> 00:53:22,150
there's a wrong figure.

865
00:53:22,150 --> 00:53:24,310
In this particular case, one of
the staff members wrote me

866
00:53:24,310 --> 00:53:26,180
an email and said, Hey
Freeman, your slides,

867
00:53:26,180 --> 00:53:27,590
something or other, is wrong.

868
00:53:27,590 --> 00:53:29,560
He was right.

869
00:53:29,560 --> 00:53:32,110
So this is the right diagram.

870
00:53:32,110 --> 00:53:36,380
So the idea is that if
multiplication distributes

871
00:53:36,380 --> 00:53:39,840
over addition, we should expect
that R applied to 1

872
00:53:39,840 --> 00:53:43,640
minus R, would give
R minus R squared.

873
00:53:43,640 --> 00:53:46,730
And we can again get a feeling
for why that ought to be true

874
00:53:46,730 --> 00:53:49,170
by thinking about the
signal flow paths.

875
00:53:49,170 --> 00:53:52,090
The two signals flow paths that
represent-- so the signal

876
00:53:52,090 --> 00:53:54,740
flow path that represents here,
this says take the 1

877
00:53:54,740 --> 00:53:58,850
minus R operator and apply it
to X, then apply R to the 1

878
00:53:58,850 --> 00:54:02,000
minus R operator, result.

879
00:54:02,000 --> 00:54:06,550
As opposed to this one says,
apply the R operator to X,

880
00:54:06,550 --> 00:54:08,890
then apply the R squared
operator to the X

881
00:54:08,890 --> 00:54:10,270
and subtract them.

882
00:54:10,270 --> 00:54:12,720
If you think about the signal
flow paths through those two

883
00:54:12,720 --> 00:54:15,520
systems, they're also the same
two signal flow paths.

884
00:54:18,380 --> 00:54:21,270
And here's a more complicated
example that shows

885
00:54:21,270 --> 00:54:22,520
associativity.

886
00:54:24,300 --> 00:54:28,940
You can think through
that, same idea.

887
00:54:28,940 --> 00:54:31,080
The reason that the idea--

888
00:54:31,080 --> 00:54:34,540
the big important point is,
difference equations are a

889
00:54:34,540 --> 00:54:36,960
good representation for
discrete time systems.

890
00:54:36,960 --> 00:54:38,240
They're mathematically
compact.

891
00:54:38,240 --> 00:54:40,750
Block diagrams are a good
representation, but they have

892
00:54:40,750 --> 00:54:42,210
more information.

893
00:54:42,210 --> 00:54:44,150
They tell you what is the input,
what is the output, and

894
00:54:44,150 --> 00:54:48,010
what are all the different flow
paths through the system?

895
00:54:48,010 --> 00:54:53,200
Operators kind of combine the
best features of both.

896
00:54:53,200 --> 00:54:55,460
It's mathematically concise,
it tells you which is the

897
00:54:55,460 --> 00:54:58,470
input and which is the output.

898
00:54:58,470 --> 00:55:01,050
And you can visualize all the
flow paths by thinking about

899
00:55:01,050 --> 00:55:06,110
all the ads in the operator
expression.

900
00:55:06,110 --> 00:55:08,470
OK, to make sure that
everybody's up with me, how

901
00:55:08,470 --> 00:55:12,240
many of the following systems
are equivalent?

902
00:55:12,240 --> 00:55:13,350
You have 30 seconds.

903
00:55:13,350 --> 00:55:14,600
AUDIENCE: [INAUDIBLE]

904
00:57:04,520 --> 00:57:06,380
PROFESSOR: OK, so how many
of those are equivalent?

905
00:57:11,440 --> 00:57:13,630
More hands, more hands.

906
00:57:13,630 --> 00:57:15,600
Not necessarily more fingers,
but more hands.

907
00:57:21,480 --> 00:57:28,410
OK, about 75% correct,
roughly speaking.

908
00:57:28,410 --> 00:57:33,840
OK, how many distinct signal
flow paths are going through

909
00:57:33,840 --> 00:57:35,090
the first system?

910
00:57:37,812 --> 00:57:41,291
How many distinct signal
flow paths can you see?

911
00:57:44,780 --> 00:57:46,030
Well, here's one.

912
00:57:48,744 --> 00:57:51,630
How many more are there?

913
00:57:51,630 --> 00:57:53,073
AUDIENCE: Three.

914
00:57:53,073 --> 00:57:54,035
PROFESSOR: Three more.

915
00:57:54,035 --> 00:58:03,822
So here's one, here's one,
here's one, and here's one.

916
00:58:03,822 --> 00:58:06,870
All you need to do to think
about this system, is think

917
00:58:06,870 --> 00:58:12,430
about all of the signal flow
paths through all of them,

918
00:58:12,430 --> 00:58:18,440
make a sum, and see how many
of them have the same sum.

919
00:58:18,440 --> 00:58:23,220
So the path with the greatest
delay through this path is two

920
00:58:23,220 --> 00:58:24,910
times two delay delay.

921
00:58:24,910 --> 00:58:29,390
Two delays with a
multiply by 4.

922
00:58:29,390 --> 00:58:31,010
What's the path with
the biggest delay

923
00:58:31,010 --> 00:58:34,140
through this one?

924
00:58:34,140 --> 00:58:37,160
Also straight through.

925
00:58:37,160 --> 00:58:39,835
Also delay of two, also
a coefficient of 4.

926
00:58:43,160 --> 00:58:44,840
How about this one?

927
00:58:44,840 --> 00:58:46,090
So that's this way.

928
00:58:49,020 --> 00:58:52,640
So they all have the same paths
with maximum delay.

929
00:58:52,640 --> 00:58:57,190
The delay is 2 and the
coefficient is 4.

930
00:58:57,190 --> 00:58:59,840
This one has four possible
paths, this

931
00:58:59,840 --> 00:59:03,210
one only has three.

932
00:59:03,210 --> 00:59:05,230
So there's one straight
through this way.

933
00:59:05,230 --> 00:59:08,900
There's one that has
one fewer delay.

934
00:59:08,900 --> 00:59:11,880
And there's one that
only has--

935
00:59:11,880 --> 00:59:14,930
so there's a straight through
one, there's a delay of 2, and

936
00:59:14,930 --> 00:59:18,150
there's a delay of 1.

937
00:59:18,150 --> 00:59:20,220
So let's do the straight
through one.

938
00:59:20,220 --> 00:59:23,440
This one has a straight
through path.

939
00:59:23,440 --> 00:59:30,820
No delay, coefficient is 1.

940
00:59:30,820 --> 00:59:32,240
This one has a straight
through path,

941
00:59:32,240 --> 00:59:33,540
coefficient is 1.

942
00:59:33,540 --> 00:59:34,870
This one has a straight
through path,

943
00:59:34,870 --> 00:59:38,200
coefficient is 1.

944
00:59:38,200 --> 00:59:43,030
So all three systems have the
same maximum delay path, they

945
00:59:43,030 --> 00:59:46,130
all have the same minimum delay
path, we only have one

946
00:59:46,130 --> 00:59:47,400
in the middle yet.

947
00:59:47,400 --> 00:59:50,990
This one has two ways
to get a delay of 1.

948
00:59:50,990 --> 00:59:56,370
2 delay, 2R, or 2R.

949
00:59:56,370 --> 00:59:58,770
Since they're both 2R, they
sum, so that's 4R.

950
01:00:01,990 --> 01:00:06,640
This one only has one way that
we can get 1 delay, and that

951
01:00:06,640 --> 01:00:09,180
is to come this way and then
go that way, that's 4R.

952
01:00:12,180 --> 01:00:14,310
This one, to get 1 delay,
I take the center

953
01:00:14,310 --> 01:00:16,490
path, and that's 4R.

954
01:00:16,490 --> 01:00:21,440
Each path has the same ways to
get through the system with

955
01:00:21,440 --> 01:00:24,290
zero delay, 1 delay,
and 2 delays.

956
01:00:24,290 --> 01:00:27,550
They're equivalent in the sense
that if you started them

957
01:00:27,550 --> 01:00:34,240
with initial rest, they would
all generate the same output

958
01:00:34,240 --> 01:00:36,060
given the same input.

959
01:00:36,060 --> 01:00:38,870
So the answer's (3).

960
01:00:38,870 --> 01:00:40,120
OK?

961
01:00:42,570 --> 01:00:45,680
So far I've only worked with
systems that propagate the

962
01:00:45,680 --> 01:00:49,710
inputs systematically through
to the outputs.

963
01:00:49,710 --> 01:00:51,100
We call such systems
feedforward.

964
01:01:02,470 --> 01:01:04,420
Things are a little
bit different

965
01:01:04,420 --> 01:01:07,270
when you have cycles.

966
01:01:07,270 --> 01:01:09,023
We call such systems feedback.

967
01:01:14,950 --> 01:01:19,150
So what I want to think about
now is how do you think about

968
01:01:19,150 --> 01:01:21,276
a system that has a feedback
loop in it?

969
01:01:24,420 --> 01:01:26,180
The interesting thing that
happens when you have a

970
01:01:26,180 --> 01:01:33,670
feedback loop is that the
operator expression no longer

971
01:01:33,670 --> 01:01:38,610
represents a simple sum
of input signals.

972
01:01:38,610 --> 01:01:40,760
Let's look at what
happens here.

973
01:01:40,760 --> 01:01:45,690
So Y is apparently the
sum of two things.

974
01:01:45,690 --> 01:01:51,630
It's the signal RY, which
comes around that way.

975
01:01:51,630 --> 01:01:54,000
Does everybody see that?

976
01:01:54,000 --> 01:01:56,650
So if I think about labeling
this input as X, labeling this

977
01:01:56,650 --> 01:02:01,270
output as Y, then the correct
label for this point is--

978
01:02:04,876 --> 01:02:08,700
don't everybody shout at once.

979
01:02:08,700 --> 01:02:12,350
If this can be labeled as the
point Y, what is the correct

980
01:02:12,350 --> 01:02:13,530
label to a label at this point?

981
01:02:13,530 --> 01:02:16,410
RY.

982
01:02:16,410 --> 01:02:25,730
So the signal Y must be, RY
plus X. What that says, is

983
01:02:25,730 --> 01:02:32,000
that if I apply the 1 minus R
operator to Y, I should get X.

984
01:02:32,000 --> 01:02:36,740
OK, that's a fine operator
expression, except that it's

985
01:02:36,740 --> 01:02:41,780
not a formulaic operator
applied to the input.

986
01:02:41,780 --> 01:02:47,390
The operator is applied
to the output.

987
01:02:47,390 --> 01:02:52,880
OK, the difference here is
the difference between an

988
01:02:52,880 --> 01:03:00,110
imperative system, like we
talked about block diagrams

989
01:03:00,110 --> 01:03:01,780
when we were thinking
about samples.

990
01:03:01,780 --> 01:03:07,970
The block diagram tells you
what to do step by step.

991
01:03:07,970 --> 01:03:10,210
Regardless of whether you have
feedback, the block diagram

992
01:03:10,210 --> 01:03:15,350
always tells you take X of n,
add it to Y of n, whatever.

993
01:03:15,350 --> 01:03:19,880
There's an imperative
rule, do this.

994
01:03:19,880 --> 01:03:22,450
We took the block diagrams and
we turned them into operators,

995
01:03:22,450 --> 01:03:25,085
and we ended up with something
that is not imperative.

996
01:03:28,140 --> 01:03:31,140
This is much more the kind of
statement we got when we did

997
01:03:31,140 --> 01:03:33,370
difference equations.

998
01:03:33,370 --> 01:03:37,930
This is a statement of truth,
it's declarative.

999
01:03:37,930 --> 01:03:43,760
If you tell me the signal X,
it must be true that the

1000
01:03:43,760 --> 01:03:49,350
resulting signal Y when operated
upon by 1 minus R, is

1001
01:03:49,350 --> 01:03:56,190
X. So the idea is that it's
a declaration, it's not an

1002
01:03:56,190 --> 01:03:58,860
imperative rule.

1003
01:03:58,860 --> 01:04:00,110
Does everybody get that?

1004
01:04:02,420 --> 01:04:07,750
So this statement up here told
me a rule, start with X, apply

1005
01:04:07,750 --> 01:04:12,780
the 1 minus R operator and
you will get Y. That's an

1006
01:04:12,780 --> 01:04:15,340
imperative operation, do this.

1007
01:04:18,070 --> 01:04:21,540
This is a declaration.

1008
01:04:21,540 --> 01:04:26,350
If you tell me X, Y must be the
signal that when operated

1009
01:04:26,350 --> 01:04:31,270
on by 1 minus R, gives you X.
But it doesn't tell me a way

1010
01:04:31,270 --> 01:04:34,010
to find it.

1011
01:04:34,010 --> 01:04:37,060
It tells me a truth, but it
doesn't tell me how to find

1012
01:04:37,060 --> 01:04:39,350
that truth.

1013
01:04:39,350 --> 01:04:41,090
So let's go back,
let's back up.

1014
01:04:41,090 --> 01:04:43,550
OK, we got a representation,
we like the representation.

1015
01:04:43,550 --> 01:04:46,270
It's concise, it has many
of the features of block

1016
01:04:46,270 --> 01:04:49,695
diagrams, it doesn't seem
to be imperative.

1017
01:04:49,695 --> 01:04:51,500
Well, that's a problem.

1018
01:04:51,500 --> 01:04:54,930
So let's back up, think about
how this same system that ran

1019
01:04:54,930 --> 01:04:57,760
into a problem with the
operator, think about what

1020
01:04:57,760 --> 01:04:59,010
must the answer be.

1021
01:05:02,330 --> 01:05:06,990
Well the answer we can figure
out by doing step by step.

1022
01:05:06,990 --> 01:05:09,760
Imagine that it starts
at rest, so the

1023
01:05:09,760 --> 01:05:12,660
output starts at 0.

1024
01:05:12,660 --> 01:05:14,675
And now I just tick through
the samples.

1025
01:05:17,470 --> 01:05:20,980
So when the first sample comes
in, X is equal to 1, I'm

1026
01:05:20,980 --> 01:05:23,840
thinking about the unit
sample response.

1027
01:05:23,840 --> 01:05:28,510
We call the delta function
the unit sample.

1028
01:05:28,510 --> 01:05:31,840
When the unit sample at time n
equals 0 comes in, it has a

1029
01:05:31,840 --> 01:05:33,180
value of 1.

1030
01:05:33,180 --> 01:05:36,010
The 1 adds to the initial
condition, which is

1031
01:05:36,010 --> 01:05:37,760
0, to give me 1.

1032
01:05:42,537 --> 01:05:47,410
Then, this output is 1, so
when the clock ticks, the

1033
01:05:47,410 --> 01:05:51,690
input goes from 1 to 0, but the
output of the delay goes

1034
01:05:51,690 --> 01:05:52,940
from 0 to 1.

1035
01:05:55,980 --> 01:05:58,650
So when the clock ticks,
I get another 1.

1036
01:06:01,190 --> 01:06:04,190
And that persists.

1037
01:06:04,190 --> 01:06:06,450
Does everybody see
what's going on?

1038
01:06:06,450 --> 01:06:10,870
So I initially had a 0 coming
out of the delay.

1039
01:06:10,870 --> 01:06:16,430
The unit sample made the first
output be one, but then that 1

1040
01:06:16,430 --> 01:06:19,180
fed back in to make this be 1.

1041
01:06:19,180 --> 01:06:23,250
Which combined with the next 0
to give me the same 1, and

1042
01:06:23,250 --> 01:06:25,790
that state persisted.

1043
01:06:25,790 --> 01:06:34,540
What's different, is that the
output signal persists long

1044
01:06:34,540 --> 01:06:36,050
after the input went away.

1045
01:06:38,900 --> 01:06:43,720
In fact, there is a prescriptive
way to figure out

1046
01:06:43,720 --> 01:06:46,670
the relationship between the
input and the output.

1047
01:06:46,670 --> 01:06:51,030
It's just that it takes an
infinite number of delays.

1048
01:06:51,030 --> 01:06:54,840
Here's an alternative system
that would generate the same

1049
01:06:54,840 --> 01:06:59,990
response to a unit sample signal
as was generated by the

1050
01:06:59,990 --> 01:07:03,140
simple feedback system.

1051
01:07:03,140 --> 01:07:07,450
It needs to generate the
answer 1, 1, 1, 1, 1 --

1052
01:07:07,450 --> 01:07:11,090
when the input is just 1.

1053
01:07:11,090 --> 01:07:15,540
Well, the output at 0 happens
through this path.

1054
01:07:18,260 --> 01:07:21,830
The output at 1 happens
through this path.

1055
01:07:21,830 --> 01:07:24,510
The output at 2 happens
through this path.

1056
01:07:24,510 --> 01:07:25,170
3--

1057
01:07:25,170 --> 01:07:26,065
et cetera.

1058
01:07:26,065 --> 01:07:30,950
There's a separate path for
every one of those separate

1059
01:07:30,950 --> 01:07:32,930
components of the output.

1060
01:07:32,930 --> 01:07:35,350
That's how we can think about
this construction.

1061
01:07:35,350 --> 01:07:41,360
The input had a single non-zero
entry, the output has

1062
01:07:41,360 --> 01:07:43,550
an infinite number.

1063
01:07:43,550 --> 01:07:46,830
We can think about that as
resulting from an infinite

1064
01:07:46,830 --> 01:07:51,390
number of paths, or something
similar, about the simple

1065
01:07:51,390 --> 01:07:54,540
feedback system, which can be
represented by that operator

1066
01:07:54,540 --> 01:08:02,990
representation, and the infinite
feedforward system.

1067
01:08:02,990 --> 01:08:06,400
This is a simple feedback
system.

1068
01:08:06,400 --> 01:08:09,000
This is an infinite feedforward
system.

1069
01:08:09,000 --> 01:08:11,100
There's something the same
about those two.

1070
01:08:13,900 --> 01:08:17,899
In fact, they're equivalent in
the sense that if all the

1071
01:08:17,899 --> 01:08:21,710
delays start out with initial
conditions of 0, they will

1072
01:08:21,710 --> 01:08:27,819
generate the same response to
all possible input signals.

1073
01:08:27,819 --> 01:08:29,450
Those two signals are
equivalent, and

1074
01:08:29,450 --> 01:08:32,210
that's proved here.

1075
01:08:32,210 --> 01:08:43,319
All you do is you say, OK, Y2
depends on X2 this way.

1076
01:08:43,319 --> 01:08:47,220
If X2 is the same as X1,
I can substitute it.

1077
01:08:47,220 --> 01:08:52,950
But X1, according to this rule,
looks like 1 minus RY1.

1078
01:08:52,950 --> 01:08:55,455
When you multiply out this
mess, you get Y1.

1079
01:08:58,040 --> 01:09:07,359
What I just showed is that if X1
is equal to X2, then Y1 is

1080
01:09:07,359 --> 01:09:08,490
equal to Y2.

1081
01:09:08,490 --> 01:09:11,979
Those two systems
are the same.

1082
01:09:11,979 --> 01:09:14,899
Well that's weird.

1083
01:09:14,899 --> 01:09:17,640
So there's something
the same about that

1084
01:09:17,640 --> 01:09:20,060
operator and that operator.

1085
01:09:20,060 --> 01:09:22,439
We write that this way.

1086
01:09:22,439 --> 01:09:26,000
So here's the feedback system,
we think about that as

1087
01:09:26,000 --> 01:09:32,740
representing the operator Y over
X, 1 over (1 minus R).

1088
01:09:32,740 --> 01:09:38,450
So in order to calculate X,
cross multiply by X. Y is the

1089
01:09:38,450 --> 01:09:43,410
operator, 1 minus
R applied to X.

1090
01:09:43,410 --> 01:09:51,319
So we want to say Y is the
operator 1 minus R applied to

1091
01:09:51,319 --> 01:09:56,775
X. What is the operator
1 over (1 minus R)?

1092
01:10:00,040 --> 01:10:06,330
Well, if you didn't know
anything but polynomial math,

1093
01:10:06,330 --> 01:10:08,495
you might have expanded
this in a series.

1094
01:10:11,350 --> 01:10:15,390
And in fact, that gives you
exactly the right answer if

1095
01:10:15,390 --> 01:10:19,250
you were to expand 1
over R in a series.

1096
01:10:19,250 --> 01:10:22,270
So, for example, evaluate it
using synthetic division,

1097
01:10:22,270 --> 01:10:24,290
evaluate it with a Taylor
series, however

1098
01:10:24,290 --> 01:10:25,890
you want to do it.

1099
01:10:25,890 --> 01:10:28,240
Think about R as though it were
a number, just like you

1100
01:10:28,240 --> 01:10:31,300
would if it were a polynomial.

1101
01:10:31,300 --> 01:10:35,710
Expanded just like you would
if it were a polynomial.

1102
01:10:35,710 --> 01:10:38,640
And what you see, is that
there's a representation for

1103
01:10:38,640 --> 01:10:42,950
this operator 1 over (1 minus
R) that is equivalent.

1104
01:10:42,950 --> 01:10:46,920
That's exactly the same as if I
applied the operator 1 plus

1105
01:10:46,920 --> 01:10:54,850
R plus R squared plus R cubed to
X. Those two are equivalent

1106
01:10:54,850 --> 01:10:59,740
in the sense that if both
systems start out at rest, and

1107
01:10:59,740 --> 01:11:03,150
if they are both applied to
the same input, they both

1108
01:11:03,150 --> 01:11:06,230
generate the same output.

1109
01:11:06,230 --> 01:11:12,590
So that gives us that way of
thinking about operators that

1110
01:11:12,590 --> 01:11:14,723
have numerators and
denominators.

1111
01:11:19,220 --> 01:11:24,370
So, to make sure you're up to
speed, a system is described

1112
01:11:24,370 --> 01:11:27,120
by the following operator
expression.

1113
01:11:27,120 --> 01:11:29,190
Determine the output of the
system when the input is a

1114
01:11:29,190 --> 01:11:29,850
unit sample.

1115
01:11:29,850 --> 01:11:31,100
AUDIENCE: [INAUDIBLE]

1116
01:13:13,430 --> 01:13:14,890
PROFESSOR: What's the first
thing I should do?

1117
01:13:21,228 --> 01:13:23,770
OK, this is one of those
systems that has the R

1118
01:13:23,770 --> 01:13:26,800
polynomial in the bottom.

1119
01:13:26,800 --> 01:13:31,450
So it says that X must be
the same signal by cross

1120
01:13:31,450 --> 01:13:32,250
multiplying--

1121
01:13:32,250 --> 01:13:36,140
X must be the same signal as
the (1 plus 2R) operator on

1122
01:13:36,140 --> 01:13:38,080
the Y. OK, that's backwards.

1123
01:13:38,080 --> 01:13:40,300
That's not the way I want
to think about it.

1124
01:13:40,300 --> 01:13:44,320
How do I make that into a
forward statement that tells

1125
01:13:44,320 --> 01:13:46,405
me what operator gets
applied to X?

1126
01:13:49,180 --> 01:13:50,430
The answer is that.

1127
01:13:53,030 --> 01:13:54,280
So what do I do?

1128
01:14:00,350 --> 01:14:03,640
Multiply by--

1129
01:14:03,640 --> 01:14:07,280
actually you could
cross multiply.

1130
01:14:07,280 --> 01:14:12,280
How do I convert this into an
operator that looks like just

1131
01:14:12,280 --> 01:14:16,388
the numerator times X. Yeah.

1132
01:14:16,388 --> 01:14:19,600
AUDIENCE: 1 minus 2R
plus 4R squared.

1133
01:14:19,600 --> 01:14:21,270
PROFESSOR: Exactly.

1134
01:14:21,270 --> 01:14:25,490
What I want to do is convert
it by synthetic division,

1135
01:14:25,490 --> 01:14:27,600
Taylor series, whatever
method.

1136
01:14:27,600 --> 01:14:31,510
I want to think about
what would 1 over (1

1137
01:14:31,510 --> 01:14:32,710
plus 2R) look like?

1138
01:14:32,710 --> 01:14:37,140
What's the reciprocal
of 1 plus 2R?

1139
01:14:37,140 --> 01:14:40,710
That is 1 minus 2R plus
4R squared, et cetera.

1140
01:14:40,710 --> 01:14:44,290
So now I have this, which
I apply to X,

1141
01:14:44,290 --> 01:14:47,440
which is a unit sample.

1142
01:14:47,440 --> 01:14:50,530
So now I want to think about
applying this operator to the

1143
01:14:50,530 --> 01:14:52,420
unit sample signal.

1144
01:14:52,420 --> 01:14:54,530
But that's easy.

1145
01:14:54,530 --> 01:14:59,550
The first term just
brings out delta.

1146
01:14:59,550 --> 01:15:06,230
Minus 2R applied to delta
shifts the delta by 1.

1147
01:15:06,230 --> 01:15:10,005
Gives me delta of n minus 1,
and multiplies by minus 2.

1148
01:15:13,280 --> 01:15:16,780
And that whole mess then
just says that my

1149
01:15:16,780 --> 01:15:19,310
output looks like this.

1150
01:15:19,310 --> 01:15:23,990
If the input was X, which was
a unit sample signal, my

1151
01:15:23,990 --> 01:15:28,570
output has an infinite
number of terms.

1152
01:15:28,570 --> 01:15:34,050
Each one is a delayed version
of the predecessor, and the

1153
01:15:34,050 --> 01:15:39,460
weights go 1, minus 2, plus 4,
minus 8, plus 16, and diverge.

1154
01:15:42,910 --> 01:15:45,530
So what we just did was
pretty complicated.

1155
01:15:45,530 --> 01:15:49,120
We just solved a block diagram,
but we did it with

1156
01:15:49,120 --> 01:15:50,230
polynomial math.

1157
01:15:50,230 --> 01:15:52,420
We did it with math that you
learned in high school.

1158
01:15:52,420 --> 01:15:54,600
That's the point.

1159
01:15:54,600 --> 01:16:00,610
In fact, the point of today is
that any system that's built

1160
01:16:00,610 --> 01:16:01,870
out of simple parts--

1161
01:16:01,870 --> 01:16:04,920
delays, adders, scalers,
that sort of thing--

1162
01:16:04,920 --> 01:16:07,300
can be represented by a
difference equation.

1163
01:16:07,300 --> 01:16:11,750
Fine, that's good, difference
equations are wonderful.

1164
01:16:11,750 --> 01:16:13,480
They can equivalently
be represented

1165
01:16:13,480 --> 01:16:16,930
by an operator equation.

1166
01:16:16,930 --> 01:16:23,100
The operator equation has
more information in it.

1167
01:16:23,100 --> 01:16:26,090
It knows how to get from the
input to the output.

1168
01:16:26,090 --> 01:16:28,220
It's imperative.

1169
01:16:28,220 --> 01:16:30,560
It's easy to manipulate.

1170
01:16:30,560 --> 01:16:33,940
You use the same rules that
you use for polynomials.

1171
01:16:33,940 --> 01:16:37,140
So all in all, this is a
more powerful kind of

1172
01:16:37,140 --> 01:16:38,010
representation.

1173
01:16:38,010 --> 01:16:40,880
And any system that can be
represented by a difference

1174
01:16:40,880 --> 01:16:43,140
equation can similarly
be represented

1175
01:16:43,140 --> 01:16:45,340
by an operator equation.

1176
01:16:45,340 --> 01:16:47,920
That's why we're focusing
on operators.

1177
01:16:47,920 --> 01:16:50,470
So final question.

1178
01:16:50,470 --> 01:16:52,560
Think about--

1179
01:16:52,560 --> 01:16:55,770
do everything backwards now.

1180
01:16:55,770 --> 01:17:00,530
Here's a block diagram,
find the

1181
01:17:00,530 --> 01:17:02,065
associated difference equation.

1182
01:17:05,040 --> 01:17:07,980
And the idea is to take
advantage of operators.

1183
01:17:11,110 --> 01:17:15,250
In the interest of time,
let me just do it.

1184
01:17:15,250 --> 01:17:16,560
If we wanted to--

1185
01:17:16,560 --> 01:17:18,810
because I'm running
out of time.

1186
01:17:18,810 --> 01:17:21,180
So I could start with the block
diagram, I could stay in

1187
01:17:21,180 --> 01:17:23,660
block diagram domain.

1188
01:17:23,660 --> 01:17:26,270
Presumably that will
work, that's hard.

1189
01:17:26,270 --> 01:17:28,580
I want to do the easy way.

1190
01:17:28,580 --> 01:17:30,020
So convert it to operators.

1191
01:17:30,020 --> 01:17:33,350
How do you convert a block
diagram to operators?

1192
01:17:33,350 --> 01:17:38,050
Replace the delays by R,
label all the signals.

1193
01:17:38,050 --> 01:17:41,240
x becomes X, y becomes Y. I
don't have a name for this, so

1194
01:17:41,240 --> 01:17:44,290
I'll call it E, error.

1195
01:17:44,290 --> 01:17:46,860
I don't have a name for this, so
I'll call it W, who knows.

1196
01:17:49,400 --> 01:17:54,480
And then I'll express each of
the relationships imposed by

1197
01:17:54,480 --> 01:17:57,760
the plus sign, this
R or this R, by a

1198
01:17:57,760 --> 01:18:01,000
line of operator reasoning.

1199
01:18:01,000 --> 01:18:07,330
The plus says that the E signal
is X plus W. The R says

1200
01:18:07,330 --> 01:18:12,490
that the Y signal is R applied
to E. This box says that the W

1201
01:18:12,490 --> 01:18:15,280
signal is R applied to Y.

1202
01:18:15,280 --> 01:18:23,320
I get three equations in R. I
just solve algebraically.

1203
01:18:23,320 --> 01:18:25,660
None of this difference stuff,
none of the square brackets

1204
01:18:25,660 --> 01:18:26,920
with n's in them.

1205
01:18:26,920 --> 01:18:28,170
I just use algebra.

1206
01:18:30,640 --> 01:18:34,210
So I solve it algebraically
and I get this.

1207
01:18:34,210 --> 01:18:37,640
And that translates into a
corresponding difference

1208
01:18:37,640 --> 01:18:39,360
equation, showed here.

1209
01:18:43,390 --> 01:18:44,350
The point.

1210
01:18:44,350 --> 01:18:46,550
The point is three different
representations.

1211
01:18:46,550 --> 01:18:49,330
Difference equations, block
diagrams, operators.

1212
01:18:51,960 --> 01:18:54,940
Operators are easiest.

1213
01:18:54,940 --> 01:18:57,990
Even when I was asked to solve
a problem that has no

1214
01:18:57,990 --> 01:19:01,150
operators in it, it's easier
to cast it into an operator

1215
01:19:01,150 --> 01:19:05,610
expression, solve it in the
operator domain, and then turn

1216
01:19:05,610 --> 01:19:08,890
it back into a difference
equation.

1217
01:19:08,890 --> 01:19:12,220
Starting next week, we will
figure out much more powerful

1218
01:19:12,220 --> 01:19:13,650
things that we can do
with operators.

1219
01:19:13,650 --> 01:19:16,040
This is just the beginning.

1220
01:19:16,040 --> 01:19:20,370
So with that, let me just
summarize that we looked at

1221
01:19:20,370 --> 01:19:26,500
three representations, and the
point of the labs for the week

1222
01:19:26,500 --> 01:19:30,160
are going to be to exercise
this, to get some experience

1223
01:19:30,160 --> 01:19:32,980
with representing signals
in Python.