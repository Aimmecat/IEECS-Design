1
00:00:00,000 --> 00:00:00,530

2
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

3
00:00:02,960 --> 00:00:04,370
Commons license.

4
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

5
00:00:07,410 --> 00:00:11,060
offer high quality educational
resources for free.

6
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

7
00:00:13,960 --> 00:00:17,890
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:17,890 --> 00:00:19,140
ocw.mit.edu.

9
00:00:19,140 --> 00:00:28,480

10
00:00:28,480 --> 00:00:31,600
PROFESSOR: Hello, and
welcome to 6.01.

11
00:00:31,600 --> 00:00:32,409
I'm Denny Freeman.

12
00:00:32,409 --> 00:00:33,930
I'm the lecturer.

13
00:00:33,930 --> 00:00:35,970
One thing you should know about
today is that there's a

14
00:00:35,970 --> 00:00:37,060
single hand-out.

15
00:00:37,060 --> 00:00:38,830
You should have picked
it up on your way in.

16
00:00:38,830 --> 00:00:40,370
It's available at either
of the two doors.

17
00:00:40,370 --> 00:00:42,980

18
00:00:42,980 --> 00:00:47,650
What I want to do today in this
first lecture is mostly

19
00:00:47,650 --> 00:00:50,750
focus on content.

20
00:00:50,750 --> 00:00:54,030
But before I do that, since
6.01 is a little bit of an

21
00:00:54,030 --> 00:00:56,320
unusual course, I want to give
you a little bit of an

22
00:00:56,320 --> 00:00:59,010
overview and tell you a little
bit about the administration

23
00:00:59,010 --> 00:01:00,260
of the course.

24
00:01:00,260 --> 00:01:03,020

25
00:01:03,020 --> 00:01:11,490
6.01 is mostly about
modes of reasoning.

26
00:01:11,490 --> 00:01:14,410
What we would like you to get
out of this course is ways to

27
00:01:14,410 --> 00:01:17,800
think about engineering.

28
00:01:17,800 --> 00:01:21,330
We want to talk about how do you
design, how do you build,

29
00:01:21,330 --> 00:01:26,030
how do you construct, how do you
debug complicated systems?

30
00:01:26,030 --> 00:01:30,670
That's what engineers do, and
we're very good at it.

31
00:01:30,670 --> 00:01:33,700
And we want to make you
very good at it.

32
00:01:33,700 --> 00:01:34,780
We're very good at it.

33
00:01:34,780 --> 00:01:37,590
And you know that from your
common, everyday experience.

34
00:01:37,590 --> 00:01:41,010
Laptops are incredible.

35
00:01:41,010 --> 00:01:43,990
As we go through the course,
you're going to see that

36
00:01:43,990 --> 00:01:47,210
laptops incorporate things
from the tiniest, tiniest

37
00:01:47,210 --> 00:01:51,550
level, things so small that
you can't see them.

38
00:01:51,550 --> 00:01:52,370
They're microscopic.

39
00:01:52,370 --> 00:01:55,600
The individual transistors are
not things that you can see.

40
00:01:55,600 --> 00:01:58,160
We develop special tools for
you even to be able to

41
00:01:58,160 --> 00:02:00,520
visualize them.

42
00:02:00,520 --> 00:02:04,360
And yet, we conglomerate
billions of them into a system

43
00:02:04,360 --> 00:02:06,430
that works relatively
reliably.

44
00:02:06,430 --> 00:02:09,580
Now, I realize I'm going out on
a limb because when you say

45
00:02:09,580 --> 00:02:11,415
things like that, then
things always fail.

46
00:02:11,415 --> 00:02:15,250
But I'll go out on a limb and
say, for the most part, the

47
00:02:15,250 --> 00:02:19,270
systems we construct
are very reliable.

48
00:02:19,270 --> 00:02:22,790
We'd like you to know how you
think about making such a

49
00:02:22,790 --> 00:02:26,680
complicated system and
making it reliable.

50
00:02:26,680 --> 00:02:29,760
We want to tell you about how
you would model things.

51
00:02:29,760 --> 00:02:30,770
How do you gain insight?

52
00:02:30,770 --> 00:02:32,500
How do you get predictability?

53
00:02:32,500 --> 00:02:35,890
How do you figure out how
something will work before

54
00:02:35,890 --> 00:02:38,820
you've built it?

55
00:02:38,820 --> 00:02:42,390
If you're limited to trying
out how things work by

56
00:02:42,390 --> 00:02:45,750
actually constructing it,
you spend a lot of time

57
00:02:45,750 --> 00:02:48,430
constructing things that
never make it.

58
00:02:48,430 --> 00:02:52,310
We want to avoid that by
-- where we can --

59
00:02:52,310 --> 00:02:55,400
making a model, analyzing the
model, making a prediction

60
00:02:55,400 --> 00:02:59,860
from the model, and using that
prediction to build a better

61
00:02:59,860 --> 00:03:01,230
system on the first try.

62
00:03:01,230 --> 00:03:04,080

63
00:03:04,080 --> 00:03:07,750
We want to tell you about how
to augment the physical

64
00:03:07,750 --> 00:03:11,390
behavior of a system by putting
computation in it.

65
00:03:11,390 --> 00:03:15,470
That's a very powerful technique
that is increasingly

66
00:03:15,470 --> 00:03:20,090
common in anything from a
microwave to a refrigerator.

67
00:03:20,090 --> 00:03:21,750
We'd like you to know
the principles

68
00:03:21,750 --> 00:03:23,990
by which to do that.

69
00:03:23,990 --> 00:03:26,630
And we'd like you to be able
to build systems that are

70
00:03:26,630 --> 00:03:29,500
robust to failure.

71
00:03:29,500 --> 00:03:31,580
That's a newer idea.

72
00:03:31,580 --> 00:03:35,540
It's something that people
are very good at.

73
00:03:35,540 --> 00:03:38,090
If we try to do something,
and we make a mistake, we

74
00:03:38,090 --> 00:03:39,830
know how to fix it.

75
00:03:39,830 --> 00:03:42,480
And often, the fix works.

76
00:03:42,480 --> 00:03:46,090
We're less good at doing that
in constructing artificial

77
00:03:46,090 --> 00:03:48,080
systems, in engineering
systems.

78
00:03:48,080 --> 00:03:49,740
And we'd like to talk
about principles by

79
00:03:49,740 --> 00:03:52,080
which we can do that.

80
00:03:52,080 --> 00:03:56,320
So the goal of 6.01 is, then,
really to convey a distinct

81
00:03:56,320 --> 00:04:02,330
perspective about how
we engineer systems.

82
00:04:02,330 --> 00:04:07,310
Now, having said that, this is
not a philosophy course.

83
00:04:07,310 --> 00:04:10,770
We are not going to make lists
of things to do if you want it

84
00:04:10,770 --> 00:04:13,250
to be robust.

85
00:04:13,250 --> 00:04:15,240
We're going to learn
to do things by

86
00:04:15,240 --> 00:04:17,329
actually making systems.

87
00:04:17,329 --> 00:04:19,700
This is an introductory
engineering course.

88
00:04:19,700 --> 00:04:22,230
And so you're going
to build things.

89
00:04:22,230 --> 00:04:25,040
The idea is going to be that in
constructing those things,

90
00:04:25,040 --> 00:04:28,380
we've written the exercises so
that some of those important

91
00:04:28,380 --> 00:04:31,450
themes become transparent.

92
00:04:31,450 --> 00:04:35,170
So the idea is -- this is
introductory engineering.

93
00:04:35,170 --> 00:04:36,900
You'll all make things.

94
00:04:36,900 --> 00:04:40,280
You'll all get things to work,
and in the process of doing

95
00:04:40,280 --> 00:04:44,710
that, learn something about the
bigger view of how quality

96
00:04:44,710 --> 00:04:45,960
engineering happens.

97
00:04:45,960 --> 00:04:48,120

98
00:04:48,120 --> 00:04:51,220
So despite the fact that we're
really about modes of

99
00:04:51,220 --> 00:04:55,670
reasoning, that will be
grounded in content.

100
00:04:55,670 --> 00:05:00,080
We selected the content very
broadly from across EECS.

101
00:05:00,080 --> 00:05:04,050
EECS is an enormous endeavor.

102
00:05:04,050 --> 00:05:06,180
We can't possibly introduce
everything

103
00:05:06,180 --> 00:05:08,310
about EECS in one subject.

104
00:05:08,310 --> 00:05:11,460
That's ridiculous.

105
00:05:11,460 --> 00:05:13,630
However, we wanted to
give you a variety.

106
00:05:13,630 --> 00:05:16,320
We wanted to give you a sense
of the variety of tasks that

107
00:05:16,320 --> 00:05:21,450
you can use, that you can apply
the same techniques to.

108
00:05:21,450 --> 00:05:23,610
So we want to introduce modes
of reasoning, and then show

109
00:05:23,610 --> 00:05:27,750
you explicitly how you can use
those modes of reasoning in a

110
00:05:27,750 --> 00:05:29,640
variety of contexts.

111
00:05:29,640 --> 00:05:31,830
So we've chosen four, and we've
organized the course

112
00:05:31,830 --> 00:05:33,690
around four modules.

113
00:05:33,690 --> 00:05:35,940
First module is software
engineering, then signals and

114
00:05:35,940 --> 00:05:39,700
systems, then circuits, then
probability and planning.

115
00:05:39,700 --> 00:05:43,330
Even so, even having chosen
just four out of the vast

116
00:05:43,330 --> 00:05:46,240
number of things we could have
chosen, there's no way we can

117
00:05:46,240 --> 00:05:48,220
tell you adequately--

118
00:05:48,220 --> 00:05:50,420
we can't give you an adequate
introduction to any of those

119
00:05:50,420 --> 00:05:52,980
things either.

120
00:05:52,980 --> 00:05:57,250
What we've chosen to do instead
is focus on key

121
00:05:57,250 --> 00:06:01,740
concepts represented
by the asterisks.

122
00:06:01,740 --> 00:06:06,110
The idea is going to be we
choose one or two things and

123
00:06:06,110 --> 00:06:09,090
really focus on those deeply
so you get a thorough

124
00:06:09,090 --> 00:06:14,070
understanding not only of how
that fits within, for example,

125
00:06:14,070 --> 00:06:17,440
the context of software
engineering, but also how that

126
00:06:17,440 --> 00:06:20,260
concept ramifies into
other areas.

127
00:06:20,260 --> 00:06:23,500
Notice that I tried to choose
the stars so they

128
00:06:23,500 --> 00:06:25,960
hit multiple circles.

129
00:06:25,960 --> 00:06:27,080
That's what we're
trying to do.

130
00:06:27,080 --> 00:06:30,050
We're trying to not only
introduce an idea to you, but

131
00:06:30,050 --> 00:06:33,710
also show you how it connects
to other ideas.

132
00:06:33,710 --> 00:06:36,270

133
00:06:36,270 --> 00:06:40,700
So the idea, then, is to focus
on a few, we hope, very

134
00:06:40,700 --> 00:06:45,220
well-chosen applications that
will demonstrate a variety of

135
00:06:45,220 --> 00:06:46,470
powerful techniques.

136
00:06:46,470 --> 00:06:48,560

137
00:06:48,560 --> 00:06:52,430
Our mantra, the way we intend
to go about teaching this

138
00:06:52,430 --> 00:06:58,950
stuff, is practice,
theory, practice.

139
00:06:58,950 --> 00:07:00,710
There's an enormous educational

140
00:07:00,710 --> 00:07:02,420
literature that says--

141
00:07:02,420 --> 00:07:04,630
whether you like it or not--

142
00:07:04,630 --> 00:07:08,610
people learn better when
they're doing things.

143
00:07:08,610 --> 00:07:10,140
You have a lot of experience
with that.

144
00:07:10,140 --> 00:07:13,770
You have a lot of experience
on the other side, too.

145
00:07:13,770 --> 00:07:15,370
I'll try to forget the other
side, or at least try to wipe

146
00:07:15,370 --> 00:07:20,150
it from your brain momentarily
to focus on your more

147
00:07:20,150 --> 00:07:23,170
fundamental modes of learning.

148
00:07:23,170 --> 00:07:25,190
When you were a kid and you
were learning your first

149
00:07:25,190 --> 00:07:30,340
language, you didn't learn all
the rules of grammar first.

150
00:07:30,340 --> 00:07:32,440
You didn't learn all the letters
of the alphabet first.

151
00:07:32,440 --> 00:07:37,060
You didn't learn about
conjugating verbs first.

152
00:07:37,060 --> 00:07:38,580
You learned a little
bit about language.

153
00:07:38,580 --> 00:07:39,580
You started to use it.

154
00:07:39,580 --> 00:07:40,700
You ran into problems.

155
00:07:40,700 --> 00:07:43,840
You learned a little more
about language.

156
00:07:43,840 --> 00:07:50,750
You learned to go from words
like "feed me" to higher level

157
00:07:50,750 --> 00:07:54,300
concepts, like "Hey,
what's for dinner?"

158
00:07:54,300 --> 00:07:58,490
So the idea is that you learned
it in an iterative

159
00:07:58,490 --> 00:08:02,240
process where you learned some
stuff, tried it out, learned

160
00:08:02,240 --> 00:08:03,810
some more stuff, tried it out.

161
00:08:03,810 --> 00:08:05,580
And it built up.

162
00:08:05,580 --> 00:08:08,010
There's an enormous literature
in education that says that's

163
00:08:08,010 --> 00:08:11,140
exactly how we always
learn everything.

164
00:08:11,140 --> 00:08:13,170
And so that's the way this
course is focused.

165
00:08:13,170 --> 00:08:16,210
What we will do is, for example,
for today, we'll

166
00:08:16,210 --> 00:08:19,100
learn a little bit about
software engineering.

167
00:08:19,100 --> 00:08:21,370
Then, we'll do two lab sessions
where you actually

168
00:08:21,370 --> 00:08:25,110
try to use the things
we talk about.

169
00:08:25,110 --> 00:08:26,590
Then, we'll come back to lecture
and we'll have some

170
00:08:26,590 --> 00:08:30,770
more theory about how you
would do programming.

171
00:08:30,770 --> 00:08:33,429
And then, you go back to the
lab and do some more stuff.

172
00:08:33,429 --> 00:08:39,020
And the hope is that by this
tangible context, you'll have

173
00:08:39,020 --> 00:08:40,900
a deeper appreciation
of the ideas that

174
00:08:40,900 --> 00:08:42,150
we're trying to convey.

175
00:08:42,150 --> 00:08:45,480

176
00:08:45,480 --> 00:08:48,530
So let me tell you a little
bit about the four modules

177
00:08:48,530 --> 00:08:49,600
that we've chosen.

178
00:08:49,600 --> 00:08:53,560
The course is going to be
organized on four modules.

179
00:08:53,560 --> 00:08:56,360
Each module will take about
one fourth of the course.

180
00:08:56,360 --> 00:08:59,990
First thing we'll look at
is software engineering.

181
00:08:59,990 --> 00:09:04,720
As I said, we don't have time
to focus on, or even survey,

182
00:09:04,720 --> 00:09:06,660
all of the big ideas in
software engineering.

183
00:09:06,660 --> 00:09:07,980
It's far too big.

184
00:09:07,980 --> 00:09:12,760
So we're going to focus narrowly
on one or two things.

185
00:09:12,760 --> 00:09:16,780
We'd like you to know about
abstraction and modularity

186
00:09:16,780 --> 00:09:20,680
because that's such an
important idea in the

187
00:09:20,680 --> 00:09:23,670
construction of big systems.

188
00:09:23,670 --> 00:09:26,550
So that's going to
be our focus.

189
00:09:26,550 --> 00:09:31,580
In today's lecture, we'll begin
talking about modularity

190
00:09:31,580 --> 00:09:35,760
and abstraction at
the small scale.

191
00:09:35,760 --> 00:09:38,240
How does it affect the
things you type as

192
00:09:38,240 --> 00:09:40,990
instructions to a computer?

193
00:09:40,990 --> 00:09:43,270
But by next week, we're going
to be talking about a whole

194
00:09:43,270 --> 00:09:45,350
bigger scale.

195
00:09:45,350 --> 00:09:48,380
By next week, we're going to
talk about constructing

196
00:09:48,380 --> 00:09:52,460
software modules at a
much higher level.

197
00:09:52,460 --> 00:09:54,180
In particular, we'll talk about
something that we'll

198
00:09:54,180 --> 00:09:56,750
call a state machine.

199
00:09:56,750 --> 00:10:02,710
A state machine is a thing
that works in steps.

200
00:10:02,710 --> 00:10:08,580
On every step, the state machine
gets a new input.

201
00:10:08,580 --> 00:10:11,670
Then, based on that input and
its memory of what's come

202
00:10:11,670 --> 00:10:14,830
before, the state machine
decides to do something.

203
00:10:14,830 --> 00:10:16,420
It generates an output.

204
00:10:16,420 --> 00:10:17,670
And then, the process repeats.

205
00:10:17,670 --> 00:10:20,210

206
00:10:20,210 --> 00:10:23,380
We will see that that kind
of an abstraction --

207
00:10:23,380 --> 00:10:25,550
state machines --

208
00:10:25,550 --> 00:10:27,530
there's a way to think about
state machines that is

209
00:10:27,530 --> 00:10:33,030
compositional that you can think
of as a hierarchy, just

210
00:10:33,030 --> 00:10:36,740
as you can think of low-level
hierarchies within a language.

211
00:10:36,740 --> 00:10:39,260
I'll say a lot more
about that today.

212
00:10:39,260 --> 00:10:42,300
So the idea will be that once
you've composed a state

213
00:10:42,300 --> 00:10:46,070
machine, you'll be able to join
two state machines and

214
00:10:46,070 --> 00:10:49,500
have its behavior look just
like one state machine.

215
00:10:49,500 --> 00:10:52,520
That's a way to get a more
complicated behavior by

216
00:10:52,520 --> 00:10:54,620
constructing two simpler
behaviors.

217
00:10:54,620 --> 00:10:55,400
That's what we want.

218
00:10:55,400 --> 00:10:58,830
We want to learn tools that
let us compose complex

219
00:10:58,830 --> 00:11:01,100
behaviors out of simple
behaviors.

220
00:11:01,100 --> 00:11:05,610
And the tangible model of
that will be the robot.

221
00:11:05,610 --> 00:11:11,110
We will see how to write a
program that controls a robot

222
00:11:11,110 --> 00:11:14,250
as a state machine.

223
00:11:14,250 --> 00:11:17,270
That's certainly not the only
way you could control a robot.

224
00:11:17,270 --> 00:11:20,050
And it's probably not the way
you would first think of it if

225
00:11:20,050 --> 00:11:23,350
you took one course in
programming and somebody said

226
00:11:23,350 --> 00:11:27,160
to you, go program the robot
to do something.

227
00:11:27,160 --> 00:11:30,090
What we will see is that it's
a very powerful way to think

228
00:11:30,090 --> 00:11:35,460
about it for exactly this
reason of modularity.

229
00:11:35,460 --> 00:11:37,900
The bigger point that we will
make in thinking about this

230
00:11:37,900 --> 00:11:41,460
first module is the idea
of, how do you

231
00:11:41,460 --> 00:11:43,120
make systems modular?

232
00:11:43,120 --> 00:11:46,300
How do you use abstraction to
simplify the design task?

233
00:11:46,300 --> 00:11:48,930
And in particular, we will
focus on something

234
00:11:48,930 --> 00:11:52,300
that we'll call PCAP.

235
00:11:52,300 --> 00:11:54,765
When you think about a system,
we will always think about it

236
00:11:54,765 --> 00:11:57,950
in terms of, what are
the primitives?

237
00:11:57,950 --> 00:12:00,300
How do you combine them?

238
00:12:00,300 --> 00:12:05,480
How do you abstract a
bigger behavior from

239
00:12:05,480 --> 00:12:07,350
those smaller behaviors?

240
00:12:07,350 --> 00:12:11,990
And what are the patterns that
are important to capture?

241
00:12:11,990 --> 00:12:15,430
So the bigger point is this idea
of PCAP, which we will

242
00:12:15,430 --> 00:12:20,970
then revisit in every
subsequent module.

243
00:12:20,970 --> 00:12:24,350
OK, second module is on
signals and systems.

244
00:12:24,350 --> 00:12:27,580
That's also an enormous area.

245
00:12:27,580 --> 00:12:29,590
So we only have time
to do one thing.

246
00:12:29,590 --> 00:12:33,530
The thing that we will do is we
will think about discrete

247
00:12:33,530 --> 00:12:36,780
time feedback.

248
00:12:36,780 --> 00:12:40,350
How do you make a system that's
cognizant of what it's

249
00:12:40,350 --> 00:12:44,580
done so that it, in the future,
can do things with

250
00:12:44,580 --> 00:12:48,570
awareness of how it got there?

251
00:12:48,570 --> 00:12:51,920
A good example is robotic
steering.

252
00:12:51,920 --> 00:12:55,270
So the idea is going to be, OK,
think about what you do

253
00:12:55,270 --> 00:12:58,160
when you're driving a car.

254
00:12:58,160 --> 00:13:00,400
And think about how you
would tell a robot to

255
00:13:00,400 --> 00:13:03,860
do that same thing.

256
00:13:03,860 --> 00:13:06,390
Here's a naive driving
algorithm.

257
00:13:06,390 --> 00:13:08,530
I don't recommend it, but it's
widely used in Boston,

258
00:13:08,530 --> 00:13:09,150
apparently.

259
00:13:09,150 --> 00:13:11,190
[LAUGHTER]

260
00:13:11,190 --> 00:13:14,080
I find myself to the right of
where I would like to be.

261
00:13:14,080 --> 00:13:16,520
So what should I do?

262
00:13:16,520 --> 00:13:18,500
Turn left.

263
00:13:18,500 --> 00:13:20,330
I'm still to the right of
where I'd like to be.

264
00:13:20,330 --> 00:13:22,160
What should I do?

265
00:13:22,160 --> 00:13:24,060
Turn left.

266
00:13:24,060 --> 00:13:25,050
Oh!

267
00:13:25,050 --> 00:13:27,390
I'm exactly where I should be.

268
00:13:27,390 --> 00:13:30,170
What should I do?

269
00:13:30,170 --> 00:13:32,470
Go straight ahead.

270
00:13:32,470 --> 00:13:34,610
Oh, that's a bad idea.

271
00:13:34,610 --> 00:13:38,400
And what we'll see is that
perfectly innocent looking

272
00:13:38,400 --> 00:13:42,180
algorithms can have horrendous
performance.

273
00:13:42,180 --> 00:13:46,490
What we'll do is try to make
an abstraction of that.

274
00:13:46,490 --> 00:13:48,570
We'll try to make a model.

275
00:13:48,570 --> 00:13:51,510
We'll try to capture that in
math so that we don't need to

276
00:13:51,510 --> 00:13:55,020
build it to see the
bad behavior.

277
00:13:55,020 --> 00:13:57,200
We'll make a model.

278
00:13:57,200 --> 00:14:01,950
We'll use the model to predict
that that algorithm stinks.

279
00:14:01,950 --> 00:14:05,490
But more importantly, we'll use
the model to figure out an

280
00:14:05,490 --> 00:14:07,740
algorithm that'll work better.

281
00:14:07,740 --> 00:14:11,710
In fact, we'll even be able to
come up with bounds on how

282
00:14:11,710 --> 00:14:15,920
well such a controller
could possibly work.

283
00:14:15,920 --> 00:14:19,130
So the focus in this module is
going to be, how do you make a

284
00:14:19,130 --> 00:14:20,510
model to predict behavior?

285
00:14:20,510 --> 00:14:24,300
How do you analyze the model
so that you can design a

286
00:14:24,300 --> 00:14:25,870
better system?

287
00:14:25,870 --> 00:14:29,970
And then, how do you use the
model and the analysis to make

288
00:14:29,970 --> 00:14:32,110
a well-behaved system?

289
00:14:32,110 --> 00:14:34,830

290
00:14:34,830 --> 00:14:37,690
The third module
is on circuits.

291
00:14:37,690 --> 00:14:39,790
Again, circuits is huge.

292
00:14:39,790 --> 00:14:41,810
We don't have time to talk
about all of circuits.

293
00:14:41,810 --> 00:14:43,680
We'll do very simple things.

294
00:14:43,680 --> 00:14:47,440
We'll focus our attention on
how you would add a sensory

295
00:14:47,440 --> 00:14:52,770
capability to an already
complicated system.

296
00:14:52,770 --> 00:14:55,020
The idea is going to be to
start with a robot--

297
00:14:55,020 --> 00:14:56,150
I guess this is brighter--

298
00:14:56,150 --> 00:15:03,720
start with our robots and design
a head for the robot.

299
00:15:03,720 --> 00:15:07,500
The robot comes from the factory
with sonar sensors.

300
00:15:07,500 --> 00:15:09,000
The sonar sensors are
these things.

301
00:15:09,000 --> 00:15:10,130
There's eight of them.

302
00:15:10,130 --> 00:15:13,840
They tell you how far away
something that reflects the

303
00:15:13,840 --> 00:15:17,560
ultrasonic wave is.

304
00:15:17,560 --> 00:15:21,960
As they come from the factory,
the robots can't sense light.

305
00:15:21,960 --> 00:15:24,940
What you'll do is add
light sensors.

306
00:15:24,940 --> 00:15:29,730
The goal is to make a system
to modify the robot so that

307
00:15:29,730 --> 00:15:31,720
the robot tracks light.

308
00:15:31,720 --> 00:15:33,820
That's a very simple goal.

309
00:15:33,820 --> 00:15:37,970
And the way we'll that is to
augment the robot with a

310
00:15:37,970 --> 00:15:42,140
simple sensor here, showed a
little more magnified here.

311
00:15:42,140 --> 00:15:46,030
The idea is that this
is a LEGO motor.

312
00:15:46,030 --> 00:15:51,980
The LEGO motor will turn this
relative to the attachment.

313
00:15:51,980 --> 00:15:55,230
That's the robot head's neck.

314
00:15:55,230 --> 00:16:00,070
So the robot will be
able to do this.

315
00:16:00,070 --> 00:16:02,170
And the robot will have eyes.

316
00:16:02,170 --> 00:16:06,680
These are photosensors,
photoresistors, actually.

317
00:16:06,680 --> 00:16:08,900
So the idea is going to be
that there's information

318
00:16:08,900 --> 00:16:12,560
available in those sensors for
figuring out where light is so

319
00:16:12,560 --> 00:16:15,690
that you can track it.

320
00:16:15,690 --> 00:16:17,940
Your job will be to
build a circuit--

321
00:16:17,940 --> 00:16:20,290
that that's this thing--

322
00:16:20,290 --> 00:16:21,760
that connects via cables--

323
00:16:21,760 --> 00:16:23,800
these red cables and
yellow cables--

324
00:16:23,800 --> 00:16:25,930
connects via cables
over to this head.

325
00:16:25,930 --> 00:16:28,770
We'll give you the head.

326
00:16:28,770 --> 00:16:33,870
Your job will be to make the
circuit that converts the

327
00:16:33,870 --> 00:16:35,660
signal from the photoresistor--

328
00:16:35,660 --> 00:16:38,390
which is in proportion
to light--

329
00:16:38,390 --> 00:16:43,710
and figures out how to turn the
motor to get the head to

330
00:16:43,710 --> 00:16:47,300
face the light and then ship
that information down to the

331
00:16:47,300 --> 00:16:51,310
robot to let the robot turn its
wheels to get the body.

332
00:16:51,310 --> 00:16:54,100
So it's kind of like the light
comes on bright over here.

333
00:16:54,100 --> 00:16:55,650
The robot looks at it and says,
oh, yeah, that's where I

334
00:16:55,650 --> 00:16:57,260
want to be.

335
00:16:57,260 --> 00:17:00,450
So that's the idea in the third
module is to incorporate

336
00:17:00,450 --> 00:17:04,460
new sensing capabilities
into the robot.

337
00:17:04,460 --> 00:17:08,069
The final module is on
probability and planning.

338
00:17:08,069 --> 00:17:14,810
And the idea there is to learn
about how you make systems

339
00:17:14,810 --> 00:17:22,599
that are robust to uncertainty
and that can implement

340
00:17:22,599 --> 00:17:26,839
complicated plans, that they,
too, are robust to

341
00:17:26,839 --> 00:17:28,870
uncertainty.

342
00:17:28,870 --> 00:17:31,820
So there's a number of things
that we will do, including

343
00:17:31,820 --> 00:17:36,860
creating maps of spaces that the
robot doesn't understand,

344
00:17:36,860 --> 00:17:41,030
telling the robot how to
localize itself, how if it

345
00:17:41,030 --> 00:17:43,050
woke up suddenly in an
environment, it could figure

346
00:17:43,050 --> 00:17:47,520
out where it is, how
to make a plan.

347
00:17:47,520 --> 00:17:51,790
And as an example, I'll show you
the kind of system that we

348
00:17:51,790 --> 00:17:53,540
will construct.

349
00:17:53,540 --> 00:17:55,950
Here, the idea is that
we have a robot.

350
00:17:55,950 --> 00:17:58,710
The robot knows where it is.

351
00:17:58,710 --> 00:18:00,100
Imagine there's a GPS in it.

352
00:18:00,100 --> 00:18:01,380
There isn't, but imagine
there is.

353
00:18:01,380 --> 00:18:03,600
So the robot knows where it
is, and it knows where it

354
00:18:03,600 --> 00:18:04,110
wants to go.

355
00:18:04,110 --> 00:18:06,965
That's the star.

356
00:18:06,965 --> 00:18:10,630
But it has no idea what kind of
obstacles are in the way.

357
00:18:10,630 --> 00:18:15,010
So if you were a robotic driver
in Boston, you know

358
00:18:15,010 --> 00:18:18,410
that you started out at home and
you want to end up in MIT.

359
00:18:18,410 --> 00:18:20,330
But there's these annoying
obstacles, they're called

360
00:18:20,330 --> 00:18:26,450
people, that you should, in
principle at least, miss.

361
00:18:26,450 --> 00:18:30,500
So that's kind of the idea.

362
00:18:30,500 --> 00:18:32,460
So I know where I am.

363
00:18:32,460 --> 00:18:32,980
I'm the robot.

364
00:18:32,980 --> 00:18:33,650
I know where I am.

365
00:18:33,650 --> 00:18:34,740
I know where I want to be.

366
00:18:34,740 --> 00:18:37,570
And I'm going to summarize
that information here.

367
00:18:37,570 --> 00:18:38,960
Where I am is purple.

368
00:18:38,960 --> 00:18:40,870
Where I want to be is gold.

369
00:18:40,870 --> 00:18:43,610
And I have a plan.

370
00:18:43,610 --> 00:18:45,340
That's blue.

371
00:18:45,340 --> 00:18:46,330
My plan's very simple.

372
00:18:46,330 --> 00:18:49,490
I don't know anything about
anything other than I'm in

373
00:18:49,490 --> 00:18:51,800
Waltham and I want to
go to Cambridge.

374
00:18:51,800 --> 00:18:54,100
So blast east.

375
00:18:54,100 --> 00:18:57,130

376
00:18:57,130 --> 00:18:59,250
So I imagine that the
best way to do there

377
00:18:59,250 --> 00:19:02,390
is a straight line.

378
00:19:02,390 --> 00:19:07,160
OK, so now what I'm going to
do is turn on the robot.

379
00:19:07,160 --> 00:19:09,680
The robot has now
made one step.

380
00:19:09,680 --> 00:19:13,510
And I told you before about
these sonar sensors.

381
00:19:13,510 --> 00:19:16,370
From the sonar sensors, the
robot has learned now that

382
00:19:16,370 --> 00:19:19,590
there seems to be something
reflecting at each of these

383
00:19:19,590 --> 00:19:22,160
black dots.

384
00:19:22,160 --> 00:19:24,860
It got a reflection from
the black dots,

385
00:19:24,860 --> 00:19:26,540
from the sonar sensors.

386
00:19:26,540 --> 00:19:28,670
That means there's probably a
wall there, or a person, or

387
00:19:28,670 --> 00:19:30,105
something that, in principle,
I should avoid.

388
00:19:30,105 --> 00:19:32,820

389
00:19:32,820 --> 00:19:37,200
And the red dots represent, OK,
the obstacle is so close I

390
00:19:37,200 --> 00:19:39,340
really can't get there.

391
00:19:39,340 --> 00:19:43,620
So I'm excluded from the red
spots because I'm too big.

392
00:19:43,620 --> 00:19:47,290
The black spots seem
to be an obstacle.

393
00:19:47,290 --> 00:19:51,040
The red spots seem to be
where I can't fit.

394
00:19:51,040 --> 00:19:54,750
I still want to go from the
where I am, purple, to where I

395
00:19:54,750 --> 00:19:56,060
want to be, gold.

396
00:19:56,060 --> 00:20:00,060
So what I do is I compute
the new plan.

397
00:20:00,060 --> 00:20:03,580
OK then, I start to take
a step along that plan.

398
00:20:03,580 --> 00:20:07,990
And as I'm stepping along, OK,
so now, I think that I can't

399
00:20:07,990 --> 00:20:09,840
go from where I started
over to here.

400
00:20:09,840 --> 00:20:11,660
I have to go around
this wall that I

401
00:20:11,660 --> 00:20:14,320
didn't know about initially.

402
00:20:14,320 --> 00:20:15,355
So now I just start driving.

403
00:20:15,355 --> 00:20:17,580
And it looks fine, right?

404
00:20:17,580 --> 00:20:20,230
I'm getting there, right?

405
00:20:20,230 --> 00:20:21,720
Now, I know I can go
straight down here.

406
00:20:21,720 --> 00:20:22,230
Oh, wait a minute.

407
00:20:22,230 --> 00:20:23,210
There's another wall.

408
00:20:23,210 --> 00:20:26,380
OK, what do I do now?

409
00:20:26,380 --> 00:20:31,350
So as the robot goes along, it
didn't know when it started

410
00:20:31,350 --> 00:20:33,480
what kinds of obstacles
it would encounter.

411
00:20:33,480 --> 00:20:34,895
But as it's driving,
it learned.

412
00:20:34,895 --> 00:20:36,870
Oh, that didn't work.

413
00:20:36,870 --> 00:20:39,970
Start over!

414
00:20:39,970 --> 00:20:46,330
So the idea is that this robot
is executing a very

415
00:20:46,330 --> 00:20:49,850
complicated plan.

416
00:20:49,850 --> 00:20:53,640
The plan has, in fact,
many sub-plans.

417
00:20:53,640 --> 00:20:56,130
And the sub-plans all
involve uncertainty.

418
00:20:56,130 --> 00:21:00,630
It didn't know where the walls
were when it started.

419
00:21:00,630 --> 00:21:03,630
And when it's all done, it's
going to have figured out

420
00:21:03,630 --> 00:21:05,340
where the walls were and--

421
00:21:05,340 --> 00:21:06,900
provided there's a way--

422
00:21:06,900 --> 00:21:11,300
presumably find the way to
negotiate the maze and get to

423
00:21:11,300 --> 00:21:13,440
the destination.

424
00:21:13,440 --> 00:21:19,120
So the idea, then, is that if
you were asked to write a

425
00:21:19,120 --> 00:21:23,156
conventional kind of program for
solving that, it might be

426
00:21:23,156 --> 00:21:25,090
kind of hard because
of the number of

427
00:21:25,090 --> 00:21:27,450
contingencies involved.

428
00:21:27,450 --> 00:21:31,240
What we will do is break down
the problem and figure out

429
00:21:31,240 --> 00:21:34,380
simple and elegant ways
to deal not only with

430
00:21:34,380 --> 00:21:36,755
uncertainty, but how do you
make complex plans.

431
00:21:36,755 --> 00:21:41,360

432
00:21:41,360 --> 00:21:45,290
So as I said, our primary
pedagogy is going to be

433
00:21:45,290 --> 00:21:49,080
practice, theory, practice.

434
00:21:49,080 --> 00:21:54,880
And so that ramifies in how
the course is organized.

435
00:21:54,880 --> 00:21:59,370
So this is a quick map of some
of the aspects of the course.

436
00:21:59,370 --> 00:22:01,670
So we'll have weekly lectures.

437
00:22:01,670 --> 00:22:04,270
It's lecture unintensive.

438
00:22:04,270 --> 00:22:06,790
In total, there's only
13 lectures.

439
00:22:06,790 --> 00:22:10,160
We'll meet once a week
here for lecture.

440
00:22:10,160 --> 00:22:11,580
There's readings.

441
00:22:11,580 --> 00:22:13,340
There's voluminous readings.

442
00:22:13,340 --> 00:22:16,730
There's readings about every
topic that we will talk about.

443
00:22:16,730 --> 00:22:18,390
And the readings were
specifically

444
00:22:18,390 --> 00:22:19,910
designed for this course.

445
00:22:19,910 --> 00:22:21,880
I highly recommend
that you become

446
00:22:21,880 --> 00:22:23,200
familiar with the readings.

447
00:22:23,200 --> 00:22:26,510
If you have a question after
lecture, it's probably there.

448
00:22:26,510 --> 00:22:27,760
It's probably explained.

449
00:22:27,760 --> 00:22:30,390

450
00:22:30,390 --> 00:22:33,180
We will do online
tutor problems.

451
00:22:33,180 --> 00:22:36,030
We sent you an email if you
pre-registered for the course.

452
00:22:36,030 --> 00:22:37,470
So you may already
know about this.

453
00:22:37,470 --> 00:22:41,540
The idea is going to be that
there's ways that you can

454
00:22:41,540 --> 00:22:45,350
prepare for the course by doing
computer exercises.

455
00:22:45,350 --> 00:22:48,850
And we will also use those same
kinds of exercises in all

456
00:22:48,850 --> 00:22:51,420
of the class sessions.

457
00:22:51,420 --> 00:22:53,410
We will have two kinds
of lab experiences.

458
00:22:53,410 --> 00:22:58,390
Besides lecture, the other two
events that you have to attend

459
00:22:58,390 --> 00:23:01,610
are a software lab
and a design lab.

460
00:23:01,610 --> 00:23:04,340
That's the practice part.

461
00:23:04,340 --> 00:23:06,330
So after you learned a little
bit about the theory by going

462
00:23:06,330 --> 00:23:09,380
to lecture, by doing the
reading, then you go to the

463
00:23:09,380 --> 00:23:12,310
lab and try some things out.

464
00:23:12,310 --> 00:23:15,170
We call the first lab
a software lab.

465
00:23:15,170 --> 00:23:16,100
It's a short lab.

466
00:23:16,100 --> 00:23:17,020
It's an hour and a half.

467
00:23:17,020 --> 00:23:18,120
You work individually.

468
00:23:18,120 --> 00:23:19,260
You try things out.

469
00:23:19,260 --> 00:23:20,910
You write little programs.

470
00:23:20,910 --> 00:23:27,390
The courseware can check the
program to see if it's OK.

471
00:23:27,390 --> 00:23:32,630
And primarily, the exercises
in the software lab are due

472
00:23:32,630 --> 00:23:34,000
during the software lab.

473
00:23:34,000 --> 00:23:36,870
But on occasion, there will
be extra things due

474
00:23:36,870 --> 00:23:38,780
a day or two later.

475
00:23:38,780 --> 00:23:40,340
The due dates are very
clearly written

476
00:23:40,340 --> 00:23:42,830
in the tutor exercises.

477
00:23:42,830 --> 00:23:44,350
Once a week, there's
a design lab.

478
00:23:44,350 --> 00:23:48,060
That's a three hour session in
which you work with a partner.

479
00:23:48,060 --> 00:23:51,800
The reason for the partner
is that the intent--

480
00:23:51,800 --> 00:23:54,000
the difference between the
design labs and the software

481
00:23:54,000 --> 00:23:58,720
labs is that the design labs ask
you to solve slightly more

482
00:23:58,720 --> 00:24:04,130
open-ended questions, the kind
of question that you might

483
00:24:04,130 --> 00:24:06,870
have no clue what
we're asking.

484
00:24:06,870 --> 00:24:09,170
Open-ended, the kind of thing
that you will be asked to do

485
00:24:09,170 --> 00:24:10,800
after you graduate.

486
00:24:10,800 --> 00:24:11,640
Design the system.

487
00:24:11,640 --> 00:24:12,890
What do you mean, design
the system?

488
00:24:12,890 --> 00:24:15,420

489
00:24:15,420 --> 00:24:20,250
So the idea is that working with
a partner will give you a

490
00:24:20,250 --> 00:24:24,030
second, immediate source of
help and a little more

491
00:24:24,030 --> 00:24:26,700
confidence if neither of you
knows the solution so that you

492
00:24:26,700 --> 00:24:28,240
raise your hand and say,
I don't have a clue

493
00:24:28,240 --> 00:24:29,710
what's going on here.

494
00:24:29,710 --> 00:24:32,470
So the idea is that once a
week we do a software lab

495
00:24:32,470 --> 00:24:33,400
individually.

496
00:24:33,400 --> 00:24:36,260
Once a week, we do a design lab,
a little more open-ended

497
00:24:36,260 --> 00:24:38,170
with partners.

498
00:24:38,170 --> 00:24:40,865
There's a little bit of written
homework, four total.

499
00:24:40,865 --> 00:24:43,010
It's not much compared
to other subjects.

500
00:24:43,010 --> 00:24:46,480
It's mostly practice.

501
00:24:46,480 --> 00:24:50,610
There's a nano-quiz, just to
help you keep pace to make

502
00:24:50,610 --> 00:24:53,580
sure that you don't get
too far behind.

503
00:24:53,580 --> 00:24:56,200
The first 15 minutes
of every design lab

504
00:24:56,200 --> 00:24:57,560
starts with a nano-quiz.

505
00:24:57,560 --> 00:25:02,500
The nano-quizzes are intended to
be simple if you've caught

506
00:25:02,500 --> 00:25:04,860
up, if you're up to date.

507
00:25:04,860 --> 00:25:08,650
So the idea is that you go to
design lab, the first thing

508
00:25:08,650 --> 00:25:11,420
you do is a little, 15
minute nano-quiz.

509
00:25:11,420 --> 00:25:14,560
The nano-quiz uses a tutor much
like the homework tutor,

510
00:25:14,560 --> 00:25:17,150
much like the Python tutor.

511
00:25:17,150 --> 00:25:20,450
And it's intended
to be simple.

512
00:25:20,450 --> 00:25:25,730
But it does mean please get
to the design lab on time.

513
00:25:25,730 --> 00:25:29,540
The nano-quizzes are
administered by the software.

514
00:25:29,540 --> 00:25:32,520
It starts the hour when
the design lab starts.

515
00:25:32,520 --> 00:25:35,090
It times out 15 minutes later.

516
00:25:35,090 --> 00:25:38,250
So if you come 10 minutes late,
you will have 5 minutes

517
00:25:38,250 --> 00:25:39,700
to do something that
we planned to give

518
00:25:39,700 --> 00:25:40,950
you 15 minutes for.

519
00:25:40,950 --> 00:25:44,290

520
00:25:44,290 --> 00:25:46,720
We will also have exams
and interviews.

521
00:25:46,720 --> 00:25:51,600
The interviews are intended to
be a one-on-one conversation

522
00:25:51,600 --> 00:25:52,850
about how the labs went.

523
00:25:52,850 --> 00:25:55,520

524
00:25:55,520 --> 00:25:59,340
And we will have two mid-terms
and a final.

525
00:25:59,340 --> 00:26:01,050
So that's kind of
the logistics.

526
00:26:01,050 --> 00:26:05,880
The idea behind the logistics is
practice, theory, practice.

527
00:26:05,880 --> 00:26:06,830
Come to the labs.

528
00:26:06,830 --> 00:26:07,780
Try things out.

529
00:26:07,780 --> 00:26:09,160
Make sure you understand.

530
00:26:09,160 --> 00:26:10,280
Develop a little code.

531
00:26:10,280 --> 00:26:10,820
Type it in.

532
00:26:10,820 --> 00:26:12,290
See if it works.

533
00:26:12,290 --> 00:26:14,890
If it works, you're
on top of things.

534
00:26:14,890 --> 00:26:18,240
You're ready to get the next
batch of information from the

535
00:26:18,240 --> 00:26:21,050
lecture and readings.

536
00:26:21,050 --> 00:26:23,770
OK, let's go on, and let's
talk about the technical

537
00:26:23,770 --> 00:26:25,990
material in the first module
of the course, in

538
00:26:25,990 --> 00:26:27,580
the software module.

539
00:26:27,580 --> 00:26:31,720
We kick the course off talking
about software engineering for

540
00:26:31,720 --> 00:26:32,500
two reasons.

541
00:26:32,500 --> 00:26:34,190
We'd like you to know about
software engineering.

542
00:26:34,190 --> 00:26:39,060
It's an incredibly important
part of our department.

543
00:26:39,060 --> 00:26:41,690
It's an incredibly important
part of the engineering of

544
00:26:41,690 --> 00:26:46,490
absolutely any system,
any modern system.

545
00:26:46,490 --> 00:26:49,520
But we'd also like you to know
about it because it provides a

546
00:26:49,520 --> 00:26:52,460
very convenient way to think
about-- it's a convenient

547
00:26:52,460 --> 00:26:59,220
language to think about the
design issues, the engineering

548
00:26:59,220 --> 00:27:01,800
issues in all the other
parts of the class.

549
00:27:01,800 --> 00:27:03,330
So it's a very good
place to start.

550
00:27:03,330 --> 00:27:06,840

551
00:27:06,840 --> 00:27:10,800
So what I will do today is talk
about some of the very

552
00:27:10,800 --> 00:27:15,530
simplest ideas about abstraction
and modularity in

553
00:27:15,530 --> 00:27:19,300
what I think of as the lowest
level of granularity.

554
00:27:19,300 --> 00:27:22,240
How do you think about
abstraction and modularity at

555
00:27:22,240 --> 00:27:25,760
the micro scale, at
the individual

556
00:27:25,760 --> 00:27:28,870
lines of code scale?

557
00:27:28,870 --> 00:27:33,620
As I said earlier, we will,
as we progress, look at

558
00:27:33,620 --> 00:27:37,530
modularity and abstraction
at the higher scale.

559
00:27:37,530 --> 00:27:38,990
But we have to start
somewhere.

560
00:27:38,990 --> 00:27:41,220
And we're going to start by
thinking about, how do you

561
00:27:41,220 --> 00:27:46,230
think about abstraction and
modularity at the micro scale?

562
00:27:46,230 --> 00:27:49,250
Special note about
programming.

563
00:27:49,250 --> 00:27:54,640
So what we are trying to do is,
in the first two weeks,

564
00:27:54,640 --> 00:28:00,000
ramp everybody up to some level
of software security,

565
00:28:00,000 --> 00:28:03,330
where you feel comfortable.

566
00:28:03,330 --> 00:28:07,570
So the first two weeks of this
course is intended to make you

567
00:28:07,570 --> 00:28:09,200
comfortable with programming.

568
00:28:09,200 --> 00:28:11,770
We don't assume you've done
extensive programming before.

569
00:28:11,770 --> 00:28:14,750

570
00:28:14,750 --> 00:28:16,750
We want you to become
comfortable

571
00:28:16,750 --> 00:28:19,160
that you're not behind.

572
00:28:19,160 --> 00:28:24,060
And that's the focus of the
first two weeks' exercises.

573
00:28:24,060 --> 00:28:27,400
If you have little or no
previous background, if you

574
00:28:27,400 --> 00:28:32,990
are uncomfortable, please do
the Python tutor exercises.

575
00:28:32,990 --> 00:28:34,770
If you have not --

576
00:28:34,770 --> 00:28:38,240
if you do not have a lot of
experience programming, if

577
00:28:38,240 --> 00:28:41,970
you're uncomfortable with the
expectation that you can do

578
00:28:41,970 --> 00:28:46,240
programming, do that first.

579
00:28:46,240 --> 00:28:49,320
That takes priority over all the
other assignments during

580
00:28:49,320 --> 00:28:52,350
the first two weeks.

581
00:28:52,350 --> 00:28:56,190
In particular, if you're
uncomfortable, we will run a

582
00:28:56,190 --> 00:29:00,580
special Python help
session on Sunday.

583
00:29:00,580 --> 00:29:05,213
And if you attend that, you
can get a free extension.

584
00:29:05,213 --> 00:29:08,140

585
00:29:08,140 --> 00:29:12,480
The idea is completing the tutor
exercises is intended to

586
00:29:12,480 --> 00:29:14,920
make you feel comfortable that
you have the software

587
00:29:14,920 --> 00:29:18,320
background to finish the
rest of the course.

588
00:29:18,320 --> 00:29:20,640
Do that first.

589
00:29:20,640 --> 00:29:26,000
We will forgive falling behind
in other things so that you

590
00:29:26,000 --> 00:29:29,190
feel comfortable with
programming.

591
00:29:29,190 --> 00:29:34,650
If, at the end of two weeks, you
still feel uncomfortable,

592
00:29:34,650 --> 00:29:40,780
we have a deal with 6.00, the
Python programming class, that

593
00:29:40,780 --> 00:29:43,170
they will allow you to switch
your registration

594
00:29:43,170 --> 00:29:46,360
from 6.01 to 6.00.

595
00:29:46,360 --> 00:29:49,990
But that expires Valentine's
Day.

596
00:29:49,990 --> 00:29:51,810
[LAUGHTER]

597
00:29:51,810 --> 00:29:54,730
So you have to make up your mind
before Valentine's Day if

598
00:29:54,730 --> 00:29:57,020
you'd like to use that option.

599
00:29:57,020 --> 00:30:00,850
So the idea is we'd like you
to be comfortable with

600
00:30:00,850 --> 00:30:01,620
programming.

601
00:30:01,620 --> 00:30:03,750
If you haven't programmed
before, do the

602
00:30:03,750 --> 00:30:05,120
Python tutor exercises.

603
00:30:05,120 --> 00:30:06,960
Go to software lab.

604
00:30:06,960 --> 00:30:10,350
Go to design lab, but work
on the tutor exercises.

605
00:30:10,350 --> 00:30:13,340
The staff will help
you with them.

606
00:30:13,340 --> 00:30:14,710
You can go to office hours.

607
00:30:14,710 --> 00:30:18,410
There's office hours listed
on the home page.

608
00:30:18,410 --> 00:30:20,630
You should try to become
comfortable, and you should

609
00:30:20,630 --> 00:30:22,510
try to set as your goal --

610
00:30:22,510 --> 00:30:25,510
I'm going to be comfortable
before Valentine's Day.

611
00:30:25,510 --> 00:30:29,220
And if you're not, talk to a
staff member about that.

612
00:30:29,220 --> 00:30:32,320

613
00:30:32,320 --> 00:30:36,880
OK, so what do I want you to
know about programming?

614
00:30:36,880 --> 00:30:39,300
Well, we're going
to use Python.

615
00:30:39,300 --> 00:30:46,390
We selected Python because it's
very simple and because

616
00:30:46,390 --> 00:30:51,130
it lets us illustrate some
very important ideas in

617
00:30:51,130 --> 00:30:55,120
software engineering in
a very simple context.

618
00:30:55,120 --> 00:30:57,050
That's the reason.

619
00:30:57,050 --> 00:31:01,320
One of the reasons that it's
simple is that it's an

620
00:31:01,320 --> 00:31:02,570
interpreter.

621
00:31:02,570 --> 00:31:04,630

622
00:31:04,630 --> 00:31:10,020
After some initialization, the
behavior of Python is to fall

623
00:31:10,020 --> 00:31:11,736
into an interpreter loop.

624
00:31:11,736 --> 00:31:16,450
The interpreter loop is, ask the
user what he would like me

625
00:31:16,450 --> 00:31:24,370
to do, read what the user types,
figure out what they're

626
00:31:24,370 --> 00:31:28,430
talking about, and print
the result, repeat--

627
00:31:28,430 --> 00:31:29,140
very simple.

628
00:31:29,140 --> 00:31:32,590
What that means is that you
can learn by doing.

629
00:31:32,590 --> 00:31:35,090

630
00:31:35,090 --> 00:31:38,760
That's one of the points of
today's software lab.

631
00:31:38,760 --> 00:31:40,720
You can simply walk
up to a computer,

632
00:31:40,720 --> 00:31:43,940
type the word python--

633
00:31:43,940 --> 00:31:46,640
what you type is in red.

634
00:31:46,640 --> 00:31:51,380
Type the word "python." It
will prompt you, so this

635
00:31:51,380 --> 00:31:54,490
chevron, that says, I'd
like you to tell me

636
00:31:54,490 --> 00:31:55,180
something to do.

637
00:31:55,180 --> 00:31:57,550
I have nothing to do.

638
00:31:57,550 --> 00:32:01,350
If you type "2," Python tries
to interpret that.

639
00:32:01,350 --> 00:32:05,000
In this particular case,
Python says, oh, I see.

640
00:32:05,000 --> 00:32:06,810
That's a primitive data item.

641
00:32:06,810 --> 00:32:08,250
That's an integer.

642
00:32:08,250 --> 00:32:10,860
This person wants me to
understand an integer.

643
00:32:10,860 --> 00:32:17,040
And so it will echo 2,
indicating that it thinks you

644
00:32:17,040 --> 00:32:18,750
want it to understand
a simple integer.

645
00:32:18,750 --> 00:32:21,260

646
00:32:21,260 --> 00:32:25,000
Similarly, if you type 5.7,
it says, oh, I got that.

647
00:32:25,000 --> 00:32:27,320
That's a float.

648
00:32:27,320 --> 00:32:28,820
The person wants me
to remember a

649
00:32:28,820 --> 00:32:31,160
floating point number.

650
00:32:31,160 --> 00:32:35,290
And it will similarly
echo the float.

651
00:32:35,290 --> 00:32:40,550
Now, of course, there's no
exact representation for

652
00:32:40,550 --> 00:32:41,800
floats, right?

653
00:32:41,800 --> 00:32:43,030
There's too many
of them, right?

654
00:32:43,030 --> 00:32:44,710
There's a lot of them.

655
00:32:44,710 --> 00:32:48,150
There's even more floats than
there are ints, right?

656
00:32:48,150 --> 00:32:50,950
So it has an approximation.

657
00:32:50,950 --> 00:32:54,810
So it will print its
approximation to the float

658
00:32:54,810 --> 00:32:56,770
that it thinks you are
interested in.

659
00:32:56,770 --> 00:32:59,560

660
00:32:59,560 --> 00:33:04,520
If you type a string, "Hello,"
it'll say, oh, primitive data

661
00:33:04,520 --> 00:33:07,050
structure, string.

662
00:33:07,050 --> 00:33:09,760
And it'll print out
that string.

663
00:33:09,760 --> 00:33:12,780
So the idea is one of the
features of Python that makes

664
00:33:12,780 --> 00:33:16,410
it easy to learn is the fact
that it's interpreter based.

665
00:33:16,410 --> 00:33:17,350
You can play around.

666
00:33:17,350 --> 00:33:19,230
You can learn by doing.

667
00:33:19,230 --> 00:33:23,070
Now, of course, if the only
thing it did was simple data

668
00:33:23,070 --> 00:33:24,865
structures, it would
not be very useful.

669
00:33:24,865 --> 00:33:27,540

670
00:33:27,540 --> 00:33:32,010
So the next more complex thing
that it can do is think about

671
00:33:32,010 --> 00:33:34,270
combinations.

672
00:33:34,270 --> 00:33:38,130
If you type "2 + 3," it
says, oh, I got it.

673
00:33:38,130 --> 00:33:40,000
This person's interested
in a combination.

674
00:33:40,000 --> 00:33:46,250
I should combine by the plus
operator two ints, 2 and 3.

675
00:33:46,250 --> 00:33:48,890
Oh, and if I do that, if I
combine by the plus operator

676
00:33:48,890 --> 00:33:50,290
two and three, I'll get 5.

677
00:33:50,290 --> 00:33:52,640
So it prints 5.

678
00:33:52,640 --> 00:33:59,120
So that's a way you know that
it interprets "2 + 3" as 5.

679
00:33:59,120 --> 00:34:02,950
Similarly here, except
I've mixed types.

680
00:34:02,950 --> 00:34:08,710
"5.7 + 3," it says, oh, this
user wants me to apply the

681
00:34:08,710 --> 00:34:12,489
plus operator on a
float and an int.

682
00:34:12,489 --> 00:34:15,840
OK, well I'll upgrade
the int to a float.

683
00:34:15,840 --> 00:34:20,560
I'll do the float version, and
I'll get this, which is its

684
00:34:20,560 --> 00:34:26,150
representation of 8.7.

685
00:34:26,150 --> 00:34:29,360
So the idea is that it will
first try to interpret what

686
00:34:29,360 --> 00:34:31,600
you're saying as a
simple data type.

687
00:34:31,600 --> 00:34:34,840
If that works, it prints the
result to tell you what it

688
00:34:34,840 --> 00:34:36,270
thinks is going on.

689
00:34:36,270 --> 00:34:39,679
It then will try to interpret
it as an expression.

690
00:34:39,679 --> 00:34:43,630
And sometimes, the expressions
won't makes sense.

691
00:34:43,630 --> 00:34:46,340
In particular, if you try to add
an int to a string, it's

692
00:34:46,340 --> 00:34:48,110
going to say, huh?

693
00:34:48,110 --> 00:34:50,810
And over the course of the first
two weeks, we hope that

694
00:34:50,810 --> 00:34:52,889
you get familiar with
interpreting

695
00:34:52,889 --> 00:34:55,330
this kind of mess.

696
00:34:55,330 --> 00:34:59,430
That's Python's attempt to tell
you what it was trying to

697
00:34:59,430 --> 00:35:03,130
do on your behalf and can't
figure out what

698
00:35:03,130 --> 00:35:04,380
you're talking about.

699
00:35:04,380 --> 00:35:07,040

700
00:35:07,040 --> 00:35:09,280
OK, so that was simple.

701
00:35:09,280 --> 00:35:11,350
But it already illustrates
something that's very

702
00:35:11,350 --> 00:35:16,730
important, and that's the
idea of a composition.

703
00:35:16,730 --> 00:35:22,306
So the way Python works, the
fact that when you added 3 to

704
00:35:22,306 --> 00:35:27,950
2 it came out 5, what we were
doing was composing

705
00:35:27,950 --> 00:35:29,030
complicated--

706
00:35:29,030 --> 00:35:32,060
well, potentially complicated
(that was pretty simple) --

707
00:35:32,060 --> 00:35:36,470
potentially complicated
expressions and reducing them

708
00:35:36,470 --> 00:35:38,035
to a single data structure.

709
00:35:38,035 --> 00:35:41,160

710
00:35:41,160 --> 00:35:46,190
And so that means that, in some
sense, this operation, 3

711
00:35:46,190 --> 00:35:53,030
times 8, can be thought of as
exactly the same as if the

712
00:35:53,030 --> 00:35:56,610
user had typed in 24.

713
00:35:56,610 --> 00:36:02,570
Whenever you can substitute
for a complex expression a

714
00:36:02,570 --> 00:36:07,490
simpler thing, we say that the
system is compositional.

715
00:36:07,490 --> 00:36:10,290
That's a very powerful idea.

716
00:36:10,290 --> 00:36:12,380
Even though it's simple, it's
a very powerful idea.

717
00:36:12,380 --> 00:36:16,120
And it's an idea that
you all know.

718
00:36:16,120 --> 00:36:20,580
You've seen it before in
algebra, in arithmetic.

719
00:36:20,580 --> 00:36:24,680
So in arithmetic expressions,
you can think about how the

720
00:36:24,680 --> 00:36:26,540
sum of two integers is an int.

721
00:36:26,540 --> 00:36:29,530

722
00:36:29,530 --> 00:36:30,410
That's a closure.

723
00:36:30,410 --> 00:36:33,550
That's a kind of a combination
that makes the system

724
00:36:33,550 --> 00:36:38,220
compositional and that
provides a layer of

725
00:36:38,220 --> 00:36:41,950
hierarchical thinking so that,
in your head, even though it

726
00:36:41,950 --> 00:36:44,510
says 3 times 8, you don't need
to remember that anymore.

727
00:36:44,510 --> 00:36:47,920
You can say, oh, for any
purposes that follow, I might

728
00:36:47,920 --> 00:36:49,880
just as well think of
3 times 8 as being a

729
00:36:49,880 --> 00:36:53,670
single integer, 24.

730
00:36:53,670 --> 00:36:58,450
It's part of many other kinds
of systems, for example,

731
00:36:58,450 --> 00:37:00,850
natural language.

732
00:37:00,850 --> 00:37:03,810
The simplest example in natural
language is that you

733
00:37:03,810 --> 00:37:06,440
can think about "Apples
are good as snacks".

734
00:37:06,440 --> 00:37:08,490
"Apples" is a noun.

735
00:37:08,490 --> 00:37:11,380
It's a plural noun.

736
00:37:11,380 --> 00:37:15,130
Or you could substitute "Apples
and oranges", and it

737
00:37:15,130 --> 00:37:18,040
makes complete sense within
that same structure.

738
00:37:18,040 --> 00:37:22,450
So "Apples and oranges
are good as snacks".

739
00:37:22,450 --> 00:37:27,510
The combination of "apples" and
"oranges" works in every

740
00:37:27,510 --> 00:37:30,900
way from the point of view of
the grammar in the same way

741
00:37:30,900 --> 00:37:36,390
that a simple noun,
"apples," worked.

742
00:37:36,390 --> 00:37:40,270
What we would like to do is use
that idea as the starting

743
00:37:40,270 --> 00:37:43,590
point for a more general
compositional system.

744
00:37:43,590 --> 00:37:46,790

745
00:37:46,790 --> 00:37:52,210
And a good way to think about
that is by way of names.

746
00:37:52,210 --> 00:37:55,550
What if we had some sequence of
operations that we think is

747
00:37:55,550 --> 00:38:00,220
particularly important so that
we would like to somehow

748
00:38:00,220 --> 00:38:04,100
canonize that so that,
subsequently, we can use that

749
00:38:04,100 --> 00:38:07,960
sequence of operations easily?

750
00:38:07,960 --> 00:38:10,680
Python provides a very
simple way to do it.

751
00:38:10,680 --> 00:38:11,960
Every programming
language does.

752
00:38:11,960 --> 00:38:14,550
It's not unique to Python.

753
00:38:14,550 --> 00:38:16,050
But the idea is --

754
00:38:16,050 --> 00:38:17,600
so here's an example.

755
00:38:17,600 --> 00:38:19,640
"2 times 2" --

756
00:38:19,640 --> 00:38:22,230
I'm squaring 2 and get
4. "3 times 3" --

757
00:38:22,230 --> 00:38:24,970
I'm squaring 3, and
I'm getting 9.

758
00:38:24,970 --> 00:38:29,400
"8 plus 4 times 8 plus 4",
I'm squaring "8 plus 4".

759
00:38:29,400 --> 00:38:31,300
"8 plus 4", well, I can
think of that as 12.

760
00:38:31,300 --> 00:38:34,940
I'm squaring 12, I'm
getting 144.

761
00:38:34,940 --> 00:38:37,280
The thing I'm trying to
illustrate there is the notion

762
00:38:37,280 --> 00:38:38,990
of squaring.

763
00:38:38,990 --> 00:38:43,970
Squaring is a sequence of
operations that I would like

764
00:38:43,970 --> 00:38:49,040
to be able to canonize as a
single entity so that, in

765
00:38:49,040 --> 00:38:51,140
subsequent programs, I can
think of the squaring

766
00:38:51,140 --> 00:38:54,880
operation as a single
operation just

767
00:38:54,880 --> 00:38:56,950
like I think of times.

768
00:38:56,950 --> 00:39:01,460
The way we say that in Python
is "define square of x to be

769
00:39:01,460 --> 00:39:02,710
return x squared".

770
00:39:02,710 --> 00:39:07,190

771
00:39:07,190 --> 00:39:10,880
Then, having made that
definition, I can say "square

772
00:39:10,880 --> 00:39:14,040
of 6", and the answer is 36.

773
00:39:14,040 --> 00:39:15,850
OK, this is a very small step.

774
00:39:15,850 --> 00:39:18,150
But it illustrates a very
important point, the idea

775
00:39:18,150 --> 00:39:23,580
being that Python provides
a compositional facility.

776
00:39:23,580 --> 00:39:27,630

777
00:39:27,630 --> 00:39:28,880
And it's hierarchical.

778
00:39:28,880 --> 00:39:31,420

779
00:39:31,420 --> 00:39:35,240
Having defined square, I can use
square just as though it

780
00:39:35,240 --> 00:39:38,720
were a primitive operator.

781
00:39:38,720 --> 00:39:44,840
And I can use square to define
higher level operations.

782
00:39:44,840 --> 00:39:47,780
So for example, what if I were
interested in doing lots of

783
00:39:47,780 --> 00:39:49,320
sums of squares?

784
00:39:49,320 --> 00:39:51,960
Say I'm Pythagoreas, right?

785
00:39:51,960 --> 00:39:55,460
So I might want to add the
square of 2 and the square of

786
00:39:55,460 --> 00:39:58,720
4 to get 20, or the square
of 3 with the

787
00:39:58,720 --> 00:40:01,950
square of 4 to get 25.

788
00:40:01,950 --> 00:40:06,810
Using that simple idea of
composition, we can write a

789
00:40:06,810 --> 00:40:10,080
new program, sumOfSquares.

790
00:40:10,080 --> 00:40:13,540
sumOfSquares takes two
arguments, x and y.

791
00:40:13,540 --> 00:40:16,980
And it returns the square of
x and the square of y.

792
00:40:16,980 --> 00:40:19,530
SumOfSquares doesn't
care about how

793
00:40:19,530 --> 00:40:22,000
you compute the square.

794
00:40:22,000 --> 00:40:25,150
It trusts that square knows
how to do that.

795
00:40:25,150 --> 00:40:28,590
So the work is smaller.

796
00:40:28,590 --> 00:40:32,170
The idea is that square
takes care of

797
00:40:32,170 --> 00:40:35,470
squaring single numbers.

798
00:40:35,470 --> 00:40:39,190
sumOfSquares doesn't have to
know how to square numbers.

799
00:40:39,190 --> 00:40:44,390
It just needs to know how to
make a sum of squares.

800
00:40:44,390 --> 00:40:47,530
So what we've done is we've
broken a task, which was not

801
00:40:47,530 --> 00:40:52,560
very complicated, but the whole
idea is hierarchical.

802
00:40:52,560 --> 00:40:56,730
We've taken a problem and broken
it into two pieces.

803
00:40:56,730 --> 00:40:59,440
We factored the problem into
how do you do a square, and

804
00:40:59,440 --> 00:41:00,690
how do you sum squares.

805
00:41:00,690 --> 00:41:03,210

806
00:41:03,210 --> 00:41:07,200
And the idea, then, is that this
hierarchical structure is

807
00:41:07,200 --> 00:41:12,920
a way of building complex
systems out of simpler parts.

808
00:41:12,920 --> 00:41:17,130

809
00:41:17,130 --> 00:41:23,450
So that's the idea of how you
would build programs that are

810
00:41:23,450 --> 00:41:24,700
compositional.

811
00:41:24,700 --> 00:41:27,320

812
00:41:27,320 --> 00:41:32,430
Python also provides a utility
for making lists, for making

813
00:41:32,430 --> 00:41:36,220
data structures that
are compositional.

814
00:41:36,220 --> 00:41:39,950

815
00:41:39,950 --> 00:41:44,940
The most primitive is a list.

816
00:41:44,940 --> 00:41:48,570
So in Python, you can
specify a list.

817
00:41:48,570 --> 00:41:51,540
Here's a list of integers.

818
00:41:51,540 --> 00:41:53,860
So the list says, beginning
list, end of

819
00:41:53,860 --> 00:41:55,020
list, elements of list.

820
00:41:55,020 --> 00:41:57,170
So there's five elements
in the list, the

821
00:41:57,170 --> 00:41:58,420
integers 1, 2, 3, 4, 5.

822
00:41:58,420 --> 00:42:00,940

823
00:42:00,940 --> 00:42:07,310
Python doesn't care what the
elements of a list are.

824
00:42:07,310 --> 00:42:11,440
We'll see in a minute that
that's really important.

825
00:42:11,440 --> 00:42:13,520
But for the time being, the
simplest thing that you can

826
00:42:13,520 --> 00:42:15,840
imagine is a heterogeneous
list.

827
00:42:15,840 --> 00:42:21,030
It's not critical that the list
contain just integers.

828
00:42:21,030 --> 00:42:23,510
Here's a list that contains
an int, a string,

829
00:42:23,510 --> 00:42:25,450
an int, and a string.

830
00:42:25,450 --> 00:42:26,810
Python doesn't care.

831
00:42:26,810 --> 00:42:28,630
It's a list that has
four elements.

832
00:42:28,630 --> 00:42:29,880
The first element's an int.

833
00:42:29,880 --> 00:42:34,120
The second element's a
string, et cetera.

834
00:42:34,120 --> 00:42:36,690
Here's an even more
complex example.

835
00:42:36,690 --> 00:42:38,045
Here's a list of lists.

836
00:42:38,045 --> 00:42:41,320

837
00:42:41,320 --> 00:42:46,860
How many elements are
in that list?

838
00:42:46,860 --> 00:42:49,300
Three.

839
00:42:49,300 --> 00:42:53,030
How many elements are
in that list?

840
00:42:53,030 --> 00:42:57,730
So the idea is that you can
build more complex data

841
00:42:57,730 --> 00:42:59,660
structures out of simple ones.

842
00:42:59,660 --> 00:43:02,980
That's the idea of compositional
factoring

843
00:43:02,980 --> 00:43:04,230
applied to data.

844
00:43:04,230 --> 00:43:07,840

845
00:43:07,840 --> 00:43:12,040
Just like it was important when
we were thinking about

846
00:43:12,040 --> 00:43:16,350
procedures, to associate
names with procedures--

847
00:43:16,350 --> 00:43:19,280
that's what "def" did--

848
00:43:19,280 --> 00:43:22,360
we can also think about
associating names with data

849
00:43:22,360 --> 00:43:24,790
structures.

850
00:43:24,790 --> 00:43:27,060
And that's what we use something
that Python calls a

851
00:43:27,060 --> 00:43:29,540
variable for.

852
00:43:29,540 --> 00:43:32,940
So I can say "b is 3".

853
00:43:32,940 --> 00:43:39,990
And that associates the data
item, 3, with the label, b.

854
00:43:39,990 --> 00:43:44,510
I can say, "x is 5 times 2.2".

855
00:43:44,510 --> 00:43:46,310
Python will figure out
what I mean by the

856
00:43:46,310 --> 00:43:49,170
expression on the right.

857
00:43:49,170 --> 00:43:52,480
It'll figure out that I'm
composing by using the star

858
00:43:52,480 --> 00:43:55,600
operator, which is multiply, an
integer and a float, which

859
00:43:55,600 --> 00:43:57,090
will give me a float.

860
00:43:57,090 --> 00:44:00,780
The answer to that's going to
be a floating point number.

861
00:44:00,780 --> 00:44:06,650
And it will assign a label, x,
to that floating point number.

862
00:44:06,650 --> 00:44:10,030
You can have a more complicated
list, a data

863
00:44:10,030 --> 00:44:13,250
structure, and associate
the name y with it.

864
00:44:13,250 --> 00:44:15,790
Then, having associated the name
y, you get many of the

865
00:44:15,790 --> 00:44:19,590
same benefits of associating a
name with a data structure

866
00:44:19,590 --> 00:44:22,980
that we got previously
in associating a

867
00:44:22,980 --> 00:44:25,480
name with an operation.

868
00:44:25,480 --> 00:44:28,370
So we can say, y(0).

869
00:44:28,370 --> 00:44:32,680
And what that means is, what's
the zero-th elements of the

870
00:44:32,680 --> 00:44:35,450
data structure, y?

871
00:44:35,450 --> 00:44:37,390
So the zero-th element of
the data structure,

872
00:44:37,390 --> 00:44:38,760
y, is a list, [1, 2, 3].

873
00:44:38,760 --> 00:44:42,940

874
00:44:42,940 --> 00:44:45,980
Python has some funky
notations.

875
00:44:45,980 --> 00:44:49,010
The -1 element is
the last one.

876
00:44:49,010 --> 00:44:51,470
So the -1th element
of y is [7, 8, 9].

877
00:44:51,470 --> 00:44:54,500

878
00:44:54,500 --> 00:44:57,270
And it's completely
hierarchical.

879
00:44:57,270 --> 00:45:01,040
If I asked for the -1 element
of y, I get [7, 8, 9].

880
00:45:01,040 --> 00:45:02,770
But then, if I asked for the
first element of that

881
00:45:02,770 --> 00:45:06,870
result, I get 8.

882
00:45:06,870 --> 00:45:08,220
OK?

883
00:45:08,220 --> 00:45:09,470
Everything is clear?

884
00:45:09,470 --> 00:45:12,410

885
00:45:12,410 --> 00:45:15,030
OK, just to make sure everything
is clear, I want to

886
00:45:15,030 --> 00:45:17,060
ask you a question.

887
00:45:17,060 --> 00:45:19,340
But to kick off the idea of
working together, I'd like you

888
00:45:19,340 --> 00:45:21,670
to think about this question
with your neighbor.

889
00:45:21,670 --> 00:45:27,650
So before thinking about this
question, everybody stand up.

890
00:45:27,650 --> 00:45:29,290
Introduce yourself
to your neighbor.

891
00:45:29,290 --> 00:46:34,430
[AUDIENCE TALKS]

892
00:46:34,430 --> 00:46:43,870
So now, I'd like you to each
discuss with your neighbor the

893
00:46:43,870 --> 00:46:46,510
list that is best represented
by which of the following

894
00:46:46,510 --> 00:46:49,840
figures, 1, 2, 3, 4, or 5,
or none of the above.

895
00:46:49,840 --> 00:46:52,670
And in 30 seconds, I'm going
to ask everybody to raise a

896
00:46:52,670 --> 00:46:58,100
hand with a number of fingers
indicating the right answer.

897
00:46:58,100 --> 00:47:00,120
You're allowed to talk.

898
00:47:00,120 --> 00:47:02,479
That's the whole point
of having a partner.

899
00:47:02,479 --> 00:48:37,950
[AUDIENCE TALKS]

900
00:48:37,950 --> 00:48:39,200
OK.

901
00:48:39,200 --> 00:48:41,940

902
00:48:41,940 --> 00:48:45,460
I'd like everybody now
to raise their hand.

903
00:48:45,460 --> 00:48:47,930
Put up the number of fingers
that show the answer.

904
00:48:47,930 --> 00:48:49,270
And I want to tally.

905
00:48:49,270 --> 00:48:52,330

906
00:48:52,330 --> 00:48:53,040
Fantastic!

907
00:48:53,040 --> 00:48:54,420
Everybody gets it.

908
00:48:54,420 --> 00:48:57,530
OK, so which one do you like?

909
00:48:57,530 --> 00:48:58,330
AUDIENCE: 3.

910
00:48:58,330 --> 00:48:59,580
PROFESSOR: 3 --

911
00:48:59,580 --> 00:49:01,000
why do you like three.

912
00:49:01,000 --> 00:49:04,385
Somebody explain this to me?

913
00:49:04,385 --> 00:49:06,200
It just looks good?

914
00:49:06,200 --> 00:49:09,665
Its pattern recognition.

915
00:49:09,665 --> 00:49:12,635
What's good about 3?

916
00:49:12,635 --> 00:49:13,872
AUDIENCE: It shows
the compositional

917
00:49:13,872 --> 00:49:16,120
element of the list.

918
00:49:16,120 --> 00:49:16,890
PROFESSOR: Compositional?

919
00:49:16,890 --> 00:49:19,600
What is the compositional
element in the pictures?

920
00:49:19,600 --> 00:49:22,790

921
00:49:22,790 --> 00:49:26,460
What represents what?

922
00:49:26,460 --> 00:49:28,370
OK, 'a' represents a.

923
00:49:28,370 --> 00:49:30,760
That's pretty easy, right?

924
00:49:30,760 --> 00:49:32,860
So that takes care of the
bulk of the figures.

925
00:49:32,860 --> 00:49:34,230
What's the blue lines
represent?

926
00:49:34,230 --> 00:49:39,708

927
00:49:39,708 --> 00:49:40,704
Someone else?

928
00:49:40,704 --> 00:49:42,696
I didn't quite understand.

929
00:49:42,696 --> 00:49:45,690
AUDIENCE: The angles represent
like a list.

930
00:49:45,690 --> 00:49:47,469
PROFESSOR: They represent
a list.

931
00:49:47,469 --> 00:49:51,690
Where is the list
on the figures?

932
00:49:51,690 --> 00:49:52,630
AUDIENCE: The vertex?

933
00:49:52,630 --> 00:49:53,700
PROFESSOR: The vertex.

934
00:49:53,700 --> 00:49:57,050
The vertices are lists.

935
00:49:57,050 --> 00:49:59,300
So in 3 --

936
00:49:59,300 --> 00:50:03,960
at the highest level, we have a
list that's composed of how

937
00:50:03,960 --> 00:50:05,730
many elements?

938
00:50:05,730 --> 00:50:06,770
2.

939
00:50:06,770 --> 00:50:08,726
The first element
of that list is?

940
00:50:08,726 --> 00:50:09,420
AUDIENCE: a.

941
00:50:09,420 --> 00:50:11,220
PROFESSOR: And the second
element of that list is?

942
00:50:11,220 --> 00:50:11,730
AUDIENCE: Another list.

943
00:50:11,730 --> 00:50:12,660
PROFESSOR: Another list.

944
00:50:12,660 --> 00:50:15,650
That's the hierarchical
part, right?

945
00:50:15,650 --> 00:50:18,740
That second list has
how many elements?

946
00:50:18,740 --> 00:50:19,440
AUDIENCE: 2.

947
00:50:19,440 --> 00:50:21,066
PROFESSOR: Fine,
good, recurse.

948
00:50:21,066 --> 00:50:22,920
You got it.

949
00:50:22,920 --> 00:50:25,300
What is the list represented
by number 2?

950
00:50:25,300 --> 00:50:29,260

951
00:50:29,260 --> 00:50:32,530
A single list with
five elements.

952
00:50:32,530 --> 00:50:36,710
Square bracket, a, comma, b,
comma, c, comma, d, comma, e,

953
00:50:36,710 --> 00:50:38,990
square bracket, right?

954
00:50:38,990 --> 00:50:42,383
What is the list represented
by that one?

955
00:50:42,383 --> 00:50:45,329
AUDIENCE: Not a list.

956
00:50:45,329 --> 00:50:47,300
PROFESSOR: Agh!

957
00:50:47,300 --> 00:50:49,660
It's not a list!

958
00:50:49,660 --> 00:50:50,670
What is it?

959
00:50:50,670 --> 00:50:52,826
Who knows?

960
00:50:52,826 --> 00:50:53,710
AUDIENCE: Looking
at the variable

961
00:50:53,710 --> 00:50:55,286
names, it defines them.

962
00:50:55,286 --> 00:50:56,270
You have variables.

963
00:50:56,270 --> 00:50:58,074
You have a variable a, that
defines a list that contains

964
00:50:58,074 --> 00:51:00,370
b, and the variable, c, that
defines another list that

965
00:51:00,370 --> 00:51:01,682
contains d.

966
00:51:01,682 --> 00:51:05,140
PROFESSOR: So we could
make that a variable.

967
00:51:05,140 --> 00:51:09,080
If we said a is a variable that
comprises b and c, then

968
00:51:09,080 --> 00:51:11,560
we have the problem of how
we're going to associate

969
00:51:11,560 --> 00:51:17,020
variables and elements into
this list, right?

970
00:51:17,020 --> 00:51:19,760
So the weird thing about
this one and, let's

971
00:51:19,760 --> 00:51:20,980
see, that one's weird.

972
00:51:20,980 --> 00:51:22,290
This one's also kind of weird.

973
00:51:22,290 --> 00:51:27,470
This one's weird because we're
giving names to lists in a

974
00:51:27,470 --> 00:51:31,940
fashion that's not showed
up here, right?

975
00:51:31,940 --> 00:51:34,060
That's not to say you couldn't
invent a meaning.

976
00:51:34,060 --> 00:51:36,800
It's just that it doesn't
map very well to that

977
00:51:36,800 --> 00:51:38,960
representation.

978
00:51:38,960 --> 00:51:43,360
Similarly over here, we seem to
be giving the name b to the

979
00:51:43,360 --> 00:51:46,920
element a, and then the name
c to the element b.

980
00:51:46,920 --> 00:51:47,800
What on earth are you
talking about?

981
00:51:47,800 --> 00:51:50,690
It's not clear what we're
doing their either.

982
00:51:50,690 --> 00:51:54,020
So the point is to get you
thinking about the abstract

983
00:51:54,020 --> 00:51:57,200
representation of lists and how
that maps into a complex

984
00:51:57,200 --> 00:51:58,030
data structure.

985
00:51:58,030 --> 00:52:00,360
That was the whole point.

986
00:52:00,360 --> 00:52:05,920
OK, so we've talked about,
then, four things so far.

987
00:52:05,920 --> 00:52:08,770
How do you think about
operations in a

988
00:52:08,770 --> 00:52:10,880
hierarchical fashion.

989
00:52:10,880 --> 00:52:13,210
And the idea was composition.

990
00:52:13,210 --> 00:52:18,230
We think about composing simple
operations to make

991
00:52:18,230 --> 00:52:21,270
bigger, compound operations.

992
00:52:21,270 --> 00:52:24,840
That's a way of saying, there's
this set of operations

993
00:52:24,840 --> 00:52:27,170
that I want to call foo.

994
00:52:27,170 --> 00:52:29,510
So every time I do this
complicated thing that has

995
00:52:29,510 --> 00:52:33,830
three pages of code,
that's one foo.

996
00:52:33,830 --> 00:52:37,950
And that's a way that we can
then combined foos in some

997
00:52:37,950 --> 00:52:42,810
other horribly complicated
way to make big foos.

998
00:52:42,810 --> 00:52:44,500
So the idea is composition.

999
00:52:44,500 --> 00:52:45,580
That's the first idea.

1000
00:52:45,580 --> 00:52:51,030
The second is associating a name
with that composition.

1001
00:52:51,030 --> 00:52:54,210
That's what "def" does--
define name, name of a

1002
00:52:54,210 --> 00:52:55,780
sub-routine.

1003
00:52:55,780 --> 00:52:58,030
So we thought about composing
operations,

1004
00:52:58,030 --> 00:52:59,990
associating names with them.

1005
00:52:59,990 --> 00:53:03,710
We composed data in terms of
lists, and we associated names

1006
00:53:03,710 --> 00:53:06,040
with those lists in terms
of variables.

1007
00:53:06,040 --> 00:53:09,030
The next thing we want to think
about is a higher order

1008
00:53:09,030 --> 00:53:13,400
construct where we would like to
conglomerate into one data

1009
00:53:13,400 --> 00:53:18,550
structure both data
and procedures.

1010
00:53:18,550 --> 00:53:23,250
Python has a concept called a
class that lets us do that.

1011
00:53:23,250 --> 00:53:27,020
In Python, you make a new class
by saying to the Python

1012
00:53:27,020 --> 00:53:31,200
prompt, I want a new class
called Student.

1013
00:53:31,200 --> 00:53:35,940
And then, under Student, there
is this thing which we will

1014
00:53:35,940 --> 00:53:37,660
call an attribute.

1015
00:53:37,660 --> 00:53:42,600
An attribute to a class is
simply a data item associated

1016
00:53:42,600 --> 00:53:44,460
with the class.

1017
00:53:44,460 --> 00:53:46,380
And a method--

1018
00:53:46,380 --> 00:53:50,760
a method is just a
procedure that is

1019
00:53:50,760 --> 00:53:52,450
associated with the class.

1020
00:53:52,450 --> 00:53:58,540
So there's this single item
class called Student that has

1021
00:53:58,540 --> 00:54:04,860
one piece of data, its
attribute, school, and one

1022
00:54:04,860 --> 00:54:10,230
procedure, which is the method
calculateFinalGrade.

1023
00:54:10,230 --> 00:54:12,370
So then, this is the kind of
data structure you might

1024
00:54:12,370 --> 00:54:15,230
imagine that a registrar
would have.

1025
00:54:15,230 --> 00:54:18,120
It's a way to associate.

1026
00:54:18,120 --> 00:54:22,130
So the idea here is that
everybody here is a student.

1027
00:54:22,130 --> 00:54:24,740
They all have a school.

1028
00:54:24,740 --> 00:54:28,390
And they all have a way of
calculating their final grade.

1029
00:54:28,390 --> 00:54:32,810
That's a very narrow view that
maybe a registrar would have.

1030
00:54:32,810 --> 00:54:38,610
So classes, having defined
them, we can then use the

1031
00:54:38,610 --> 00:54:42,570
class to define an instance.

1032
00:54:42,570 --> 00:54:50,430
So an instance is a data
structure that inherits all of

1033
00:54:50,430 --> 00:54:54,660
the structure from the class but
also provides a mechanism

1034
00:54:54,660 --> 00:54:58,950
for having specific data
associated with the instance.

1035
00:54:58,950 --> 00:55:02,930
So in Python, I say
Mary is a student.

1036
00:55:02,930 --> 00:55:05,480
By mentioning the name of the
class and putting parenthesis

1037
00:55:05,480 --> 00:55:10,510
on it, I say, give me an
instance of the student.

1038
00:55:10,510 --> 00:55:15,860
So now, Mary is a name
associated with an instance of

1039
00:55:15,860 --> 00:55:18,410
the class, Student.

1040
00:55:18,410 --> 00:55:23,760
John is similarly an instance
of the class, Student.

1041
00:55:23,760 --> 00:55:27,570
So both Mary and John
have schools.

1042
00:55:27,570 --> 00:55:29,430
In fact, they're
both the same.

1043
00:55:29,430 --> 00:55:34,160
The school of Mary and the
school of John are both MIT.

1044
00:55:34,160 --> 00:55:42,200
But I can extend the instance
of Mary to include a new

1045
00:55:42,200 --> 00:55:48,495
attribute, the section number,
so that Mary's section number

1046
00:55:48,495 --> 00:55:50,910
is 3 and John's section
number is 4.

1047
00:55:50,910 --> 00:55:52,880
So this provides a way--

1048
00:55:52,880 --> 00:55:55,080
it's a higher-order concept.

1049
00:55:55,080 --> 00:55:57,940
We thought of a way to aggregate
operations into

1050
00:55:57,940 --> 00:56:01,140
complicated operation, data
into complicated data.

1051
00:56:01,140 --> 00:56:06,230
Classes aggregate data
and operations.

1052
00:56:06,230 --> 00:56:09,250
Classes allow us to create
a structure and

1053
00:56:09,250 --> 00:56:10,520
then generate instances.

1054
00:56:10,520 --> 00:56:15,780
And then the instances have
access to those features that

1055
00:56:15,780 --> 00:56:18,480
were defined in the class, but
also have the ability to

1056
00:56:18,480 --> 00:56:23,800
define their own unique
attributes and methods.

1057
00:56:23,800 --> 00:56:27,820
You can also use a class
to define a subclass.

1058
00:56:27,820 --> 00:56:31,950
So here, I'm defining the
subclass, Student601.

1059
00:56:31,950 --> 00:56:35,770
All Student601s are members
of the class, Student.

1060
00:56:35,770 --> 00:56:38,240
The reverse is not true.

1061
00:56:38,240 --> 00:56:42,930
So all Student601 entities
inherit everything that a

1062
00:56:42,930 --> 00:56:44,400
Student has.

1063
00:56:44,400 --> 00:56:48,930
But all 601 students share
some other things.

1064
00:56:48,930 --> 00:56:52,170
Besides having a school which
all students have, 601

1065
00:56:52,170 --> 00:56:54,560
students also have a lecture
day, a lecture time, and a

1066
00:56:54,560 --> 00:56:56,130
method for calculating
tutor scores.

1067
00:56:56,130 --> 00:56:59,350

1068
00:56:59,350 --> 00:57:03,290
Not all students have a method
for calculating tutor scores.

1069
00:57:03,290 --> 00:57:06,590
But members of the class
Student601 do.

1070
00:57:06,590 --> 00:57:09,390

1071
00:57:09,390 --> 00:57:14,470
So this, again, represents a
way of organizing data and

1072
00:57:14,470 --> 00:57:20,010
operations in a way that makes
it easier to compose higher,

1073
00:57:20,010 --> 00:57:21,260
bigger, more complex
structures.

1074
00:57:21,260 --> 00:57:24,240

1075
00:57:24,240 --> 00:57:27,230
The final thing that I want
to talk about today is the

1076
00:57:27,230 --> 00:57:33,900
specific, gory details for how
Python manages the association

1077
00:57:33,900 --> 00:57:38,370
between names and entities.

1078
00:57:38,370 --> 00:57:40,840
We've already seen
two of those.

1079
00:57:40,840 --> 00:57:45,660
Naming operations is via "def."
And it gives rise to

1080
00:57:45,660 --> 00:57:48,270
the name of a procedure.

1081
00:57:48,270 --> 00:57:52,640
Variables are ways of naming
data structures.

1082
00:57:52,640 --> 00:57:59,000
Now, we've seen a way
of naming classes.

1083
00:57:59,000 --> 00:58:01,640
And in fact, it's helpful
if you understand.

1084
00:58:01,640 --> 00:58:07,680
So Python associates names and
entities in a very simple,

1085
00:58:07,680 --> 00:58:08,870
straightforward fashion.

1086
00:58:08,870 --> 00:58:11,080
And if you know the ground
rules, it makes it very easy

1087
00:58:11,080 --> 00:58:11,600
to deal with.

1088
00:58:11,600 --> 00:58:13,310
And if you don't know the ground
rules, it makes it very

1089
00:58:13,310 --> 00:58:14,440
hard to deal with.

1090
00:58:14,440 --> 00:58:15,670
So what's the ground rules?

1091
00:58:15,670 --> 00:58:17,810
Here's the gory details.

1092
00:58:17,810 --> 00:58:22,730
So Python associates names with
values in what Python

1093
00:58:22,730 --> 00:58:26,920
calls a binding environment.

1094
00:58:26,920 --> 00:58:30,470
An environment is just a
list that associates

1095
00:58:30,470 --> 00:58:33,120
a name and an entity.

1096
00:58:33,120 --> 00:58:35,860
So if you were to type b
equals 3 what Python is

1097
00:58:35,860 --> 00:58:41,270
actually doing is it's building
this environment.

1098
00:58:41,270 --> 00:58:46,357
When you type b equals 3, it
adds to the environment a

1099
00:58:46,357 --> 00:58:54,620
name, b, and associates that
name with the integer, 3.

1100
00:58:54,620 --> 00:59:01,840
When you type x equals 2.2, it
adds a name, x, and associates

1101
00:59:01,840 --> 00:59:04,550
it with the float, 2.2.

1102
00:59:04,550 --> 00:59:09,530
When you say foo is minus 506
times 2, it makes the name,

1103
00:59:09,530 --> 00:59:16,762
foo, and associates it with
an int, minus 1012.

1104
00:59:16,762 --> 00:59:22,940
Then, if you ask Python about
b, the rule is look it up in

1105
00:59:22,940 --> 00:59:29,250
the environment and type the
thing that b refers to.

1106
00:59:29,250 --> 00:59:31,940
So when you type "b," what
Python really does is it goes

1107
00:59:31,940 --> 00:59:32,890
to the environment.

1108
00:59:32,890 --> 00:59:36,570
It says, do I have some entity
called "b?" Well, yes I do.

1109
00:59:36,570 --> 00:59:38,230
It happens to be an int, 3.

1110
00:59:38,230 --> 00:59:39,480
So it prints 3.

1111
00:59:39,480 --> 00:59:43,170

1112
00:59:43,170 --> 00:59:48,080
If you ask, what is "a?"
Python says, OK, in my

1113
00:59:48,080 --> 00:59:55,290
environment, do I have some
name, "a?" It doesn't find it.

1114
00:59:55,290 --> 00:59:59,240
So it prints out this cryptic
message that basically says,

1115
00:59:59,240 --> 01:00:03,160
sorry, guys, I can't find
something called "a" in the

1116
01:00:03,160 --> 01:00:05,750
current environment.

1117
01:00:05,750 --> 01:00:11,300
That's the key to the way Python
does all name bindings.

1118
01:00:11,300 --> 01:00:16,390
So in general, there's
a global environment.

1119
01:00:16,390 --> 01:00:18,850
You start typing to Python.

1120
01:00:18,850 --> 01:00:23,800
It just starts adding and
modifying the bindings in the

1121
01:00:23,800 --> 01:00:25,520
binding environment.

1122
01:00:25,520 --> 01:00:29,970
So if you type a equals 3 and
then type "a," it'll find 3.

1123
01:00:29,970 --> 01:00:36,250
If you then type "b=a+2," it
evaluates the right-hand side

1124
01:00:36,250 --> 01:00:39,870
relative to the current
environment.

1125
01:00:39,870 --> 01:00:41,890
So it first looks here.

1126
01:00:41,890 --> 01:00:47,060
And it says, do I have something
called "a?" Ah, yes.

1127
01:00:47,060 --> 01:00:49,070
It's an integer, 3.

1128
01:00:49,070 --> 01:00:51,280
Substitute that.

1129
01:00:51,280 --> 01:00:52,310
Do I know what 2 is?

1130
01:00:52,310 --> 01:00:53,100
Oh yeah, that's just an int.

1131
01:00:53,100 --> 01:00:54,190
Do I know what plus is?

1132
01:00:54,190 --> 01:00:56,560
Oh yeah, that's the thing
that combines two ints.

1133
01:00:56,560 --> 01:00:59,800
So it decides that a plus 2--

1134
01:00:59,800 --> 01:01:01,790
it evaluates a plus 2 in the
current environment.

1135
01:01:01,790 --> 01:01:03,370
It gets 5.

1136
01:01:03,370 --> 01:01:06,830
And it says, oh, I'm trying
to do a new equals, a new

1137
01:01:06,830 --> 01:01:08,960
association, a new variable.

1138
01:01:08,960 --> 01:01:15,210
Make the name, b, points to this
evaluated in the current

1139
01:01:15,210 --> 01:01:16,150
environment.

1140
01:01:16,150 --> 01:01:18,240
So b gets associated
with int 5.

1141
01:01:18,240 --> 01:01:20,960

1142
01:01:20,960 --> 01:01:25,670
Then, if I do this line, it
evaluates b plus 1 in the

1143
01:01:25,670 --> 01:01:26,920
current environment.

1144
01:01:26,920 --> 01:01:29,430

1145
01:01:29,430 --> 01:01:31,760
b is 5 in the current
environment.

1146
01:01:31,760 --> 01:01:32,390
It adds 1.

1147
01:01:32,390 --> 01:01:34,300
It gets 6.

1148
01:01:34,300 --> 01:01:40,210
And then, it says, associate
this thing, 6, with b.

1149
01:01:40,210 --> 01:01:45,850
So it overwrites the b, which
had been bound to 5, and b is

1150
01:01:45,850 --> 01:01:48,050
now bound to 6.

1151
01:01:48,050 --> 01:01:48,670
OK?

1152
01:01:48,670 --> 01:01:54,210
So the whole thing, the way it
treats variables, the way

1153
01:01:54,210 --> 01:01:57,490
Python associates a name with
a value in a variable, is

1154
01:01:57,490 --> 01:01:59,930
evaluate the right-hand side
according to the current

1155
01:01:59,930 --> 01:02:01,190
environment.

1156
01:02:01,190 --> 01:02:03,630
Then, change the current
environment to

1157
01:02:03,630 --> 01:02:07,410
reflect the new binding.

1158
01:02:07,410 --> 01:02:09,850
What it does in the case of
sub-routines is very similar.

1159
01:02:09,850 --> 01:02:13,140

1160
01:02:13,140 --> 01:02:17,510
So here's an illustration of the
local environment that is

1161
01:02:17,510 --> 01:02:19,810
generated by this
piece of code.

1162
01:02:19,810 --> 01:02:22,760
When I say a equals 2, it
generates a name in the local

1163
01:02:22,760 --> 01:02:25,090
environment, a.

1164
01:02:25,090 --> 01:02:28,850
It evaluates the right-hand
side and finds 2.

1165
01:02:28,850 --> 01:02:32,080
So it makes a binding in the
local environment where the

1166
01:02:32,080 --> 01:02:36,140
name, a, is associated
with the integer, 2.

1167
01:02:36,140 --> 01:02:39,770
Then, I say define square of
x to be return x squared.

1168
01:02:39,770 --> 01:02:42,980

1169
01:02:42,980 --> 01:02:45,180
That's more complicated.

1170
01:02:45,180 --> 01:02:48,740
Python says, oh, I'm defining
a new operation.

1171
01:02:48,740 --> 01:02:52,840

1172
01:02:52,840 --> 01:02:55,150
It's a procedure.

1173
01:02:55,150 --> 01:03:00,450
The procedure has a formal
argument, x.

1174
01:03:00,450 --> 01:03:05,170
It has a body, return
x times x.

1175
01:03:05,170 --> 01:03:07,060
I'm going to have to remember
all of that stuff.

1176
01:03:07,060 --> 01:03:09,590

1177
01:03:09,590 --> 01:03:13,950
So I'm trying to define a new
procedure called square.

1178
01:03:13,950 --> 01:03:17,300
It's going to make a
binding for square.

1179
01:03:17,300 --> 01:03:20,830
So in the future, if somebody
says the word square, it'll

1180
01:03:20,830 --> 01:03:23,210
find out, oh, square I
remember that one.

1181
01:03:23,210 --> 01:03:25,860
square, it's a procedure.

1182
01:03:25,860 --> 01:03:28,380

1183
01:03:28,380 --> 01:03:32,930
Just like the binding for a
variable might be an int, the

1184
01:03:32,930 --> 01:03:39,880
binding for a procedure is the
name of the procedure.

1185
01:03:39,880 --> 01:03:43,580
Then, in the procedure, which
is some other data structure

1186
01:03:43,580 --> 01:03:47,140
outside the environment, it's
got to remember the formal

1187
01:03:47,140 --> 01:03:48,110
parameters--

1188
01:03:48,110 --> 01:03:50,540
in this case, x--

1189
01:03:50,540 --> 01:03:51,790
and the body.

1190
01:03:51,790 --> 01:03:54,000

1191
01:03:54,000 --> 01:03:57,560
And for the purpose of
resolving what do the

1192
01:03:57,560 --> 01:04:02,100
variables mean, it needs to
remember what was the binding

1193
01:04:02,100 --> 01:04:07,000
environment in which this
sub-routine was defined.

1194
01:04:07,000 --> 01:04:09,470
So that's this arrow.

1195
01:04:09,470 --> 01:04:14,140
So this sequence says, make a
new binding square, points to

1196
01:04:14,140 --> 01:04:14,790
a procedure.

1197
01:04:14,790 --> 01:04:18,930
The procedure has the
formal argument, x.

1198
01:04:18,930 --> 01:04:23,030
It has the body return
x times x.

1199
01:04:23,030 --> 01:04:25,180
And it has the binding.

1200
01:04:25,180 --> 01:04:31,430
It came from the environment,
E1, the current environment.

1201
01:04:31,430 --> 01:04:32,650
OK, is everybody clear?

1202
01:04:32,650 --> 01:04:36,320
So the idea is that the
environment associates names

1203
01:04:36,320 --> 01:04:37,220
with things.

1204
01:04:37,220 --> 01:04:39,250
The thing could be
a data item, or

1205
01:04:39,250 --> 01:04:40,500
it could be a procedure.

1206
01:04:40,500 --> 01:04:43,540

1207
01:04:43,540 --> 01:04:48,280
Then, when you call a procedure,
it makes a new

1208
01:04:48,280 --> 01:04:50,270
environment.

1209
01:04:50,270 --> 01:04:54,830
So what happens, then, when I
try to evaluate a form, square

1210
01:04:54,830 --> 01:04:58,260
of a plus 2?

1211
01:04:58,260 --> 01:05:01,780
What Python does is it says,
OK, I need to figure

1212
01:05:01,780 --> 01:05:04,460
out what square is.

1213
01:05:04,460 --> 01:05:06,930
So it looks it up in the
environment, and it finds out

1214
01:05:06,930 --> 01:05:09,160
that square is a procedure.

1215
01:05:09,160 --> 01:05:12,640
Fine, I know how to deal
with procedures.

1216
01:05:12,640 --> 01:05:16,290
So then, it figures out this
procedure has a formal

1217
01:05:16,290 --> 01:05:17,910
argument, x.

1218
01:05:17,910 --> 01:05:20,100
Oh, OK, if I'm going to run this
procedure, I'm going to

1219
01:05:20,100 --> 01:05:23,110
have to know what x means.

1220
01:05:23,110 --> 01:05:25,110
So Python makes a new
environment--

1221
01:05:25,110 --> 01:05:28,760
here, it's labelled E2, separate
from the global

1222
01:05:28,760 --> 01:05:30,760
environment, E1.

1223
01:05:30,760 --> 01:05:33,010
It makes a new environment
that will

1224
01:05:33,010 --> 01:05:35,630
associate x with something.

1225
01:05:35,630 --> 01:05:39,390
Doesn't know what it is yet, it
just knows that this square

1226
01:05:39,390 --> 01:05:43,540
is a procedure that takes
a formal argument, x.

1227
01:05:43,540 --> 01:05:46,180
So Python makes a new
environment, E2, with x

1228
01:05:46,180 --> 01:05:47,990
pointing to something.

1229
01:05:47,990 --> 01:05:52,240
Then, Python evaluates the
argument a plus 2 in the

1230
01:05:52,240 --> 01:05:53,490
environment E1.

1231
01:05:53,490 --> 01:05:56,200

1232
01:05:56,200 --> 01:05:59,660
You called square of a plus 2
in the environment of E1.

1233
01:05:59,660 --> 01:06:05,250
So it figures out what did
you mean by a plus 3.

1234
01:06:05,250 --> 01:06:08,380
Well, you were in the
environment E1.

1235
01:06:08,380 --> 01:06:12,570
So it means whatever a plus 3
would have meant if he had

1236
01:06:12,570 --> 01:06:15,570
just typed a plus 3 in
that environment.

1237
01:06:15,570 --> 01:06:18,940
So you evaluate a plus
3 in the environment

1238
01:06:18,940 --> 01:06:20,290
E1, and you get 5.

1239
01:06:20,290 --> 01:06:22,980

1240
01:06:22,980 --> 01:06:27,110
So then, this new environment,
E2, that is set up for this

1241
01:06:27,110 --> 01:06:30,610
procedure, square, associates
5 with x.

1242
01:06:30,610 --> 01:06:33,220

1243
01:06:33,220 --> 01:06:36,180
Now it's ready to
run the body.

1244
01:06:36,180 --> 01:06:41,440
So now, it runs this procedure,
return x times x.

1245
01:06:41,440 --> 01:06:45,080
But now, what it's trying to
resolve its variables, it

1246
01:06:45,080 --> 01:06:48,710
looks it up in E2.

1247
01:06:48,710 --> 01:06:52,170
So it says, I want to do
the procedure, the

1248
01:06:52,170 --> 01:06:53,790
body, x times x.

1249
01:06:53,790 --> 01:06:56,960
I need to know what x is, and
I need to know it twice.

1250
01:06:56,960 --> 01:07:00,570
Look up what x means, but I
will look it up in my E2

1251
01:07:00,570 --> 01:07:01,740
environment that was built

1252
01:07:01,740 --> 01:07:03,830
specifically for this procedure.

1253
01:07:03,830 --> 01:07:06,880
And fortunately, there's
an x there.

1254
01:07:06,880 --> 01:07:08,800
So it finds out that x is 5.

1255
01:07:08,800 --> 01:07:10,400
It multiplies 5 times 5.

1256
01:07:10,400 --> 01:07:11,660
It gets the answer is 25.

1257
01:07:11,660 --> 01:07:13,350
It returns 25.

1258
01:07:13,350 --> 01:07:16,740
And then, it destroys this
environment, E2, because it

1259
01:07:16,740 --> 01:07:20,100
was only necessary for the time
when it was running the

1260
01:07:20,100 --> 01:07:21,870
procedure body.

1261
01:07:21,870 --> 01:07:23,120
Is that clear?

1262
01:07:23,120 --> 01:07:28,520

1263
01:07:28,520 --> 01:07:33,820
OK, so a slightly more difficult
example illustrates

1264
01:07:33,820 --> 01:07:37,180
what happens whenever everything
is not defined in

1265
01:07:37,180 --> 01:07:39,920
the current local environment.

1266
01:07:39,920 --> 01:07:43,950
What if I type define
biz of a?

1267
01:07:43,950 --> 01:07:50,070
Well, I create a new name in
the local environment that

1268
01:07:50,070 --> 01:07:51,790
points to a procedure.

1269
01:07:51,790 --> 01:07:55,720
The procedure has a formal
parameter, a, and a body that

1270
01:07:55,720 --> 01:07:58,120
returns a plus b.

1271
01:07:58,120 --> 01:08:02,470
The procedure also was defined
within the environment E1,

1272
01:08:02,470 --> 01:08:04,150
which I'll keep track of.

1273
01:08:04,150 --> 01:08:07,430

1274
01:08:07,430 --> 01:08:11,070
Then, if I say b equals 6, that
makes a new binding in

1275
01:08:11,070 --> 01:08:16,430
the global environment,
b equals 6.

1276
01:08:16,430 --> 01:08:23,250
Then, if I try to run biz
of 2, look up biz.

1277
01:08:23,250 --> 01:08:25,220
Oh, that's a procedure,
formal parameter, a.

1278
01:08:25,220 --> 01:08:27,140
Make an environment,
has an a in it.

1279
01:08:27,140 --> 01:08:28,500
What should I put in a?

1280
01:08:28,500 --> 01:08:30,399
Evaluate the argument, 2.

1281
01:08:30,399 --> 01:08:31,290
OK, a is 2.

1282
01:08:31,290 --> 01:08:34,529
Put two here.

1283
01:08:34,529 --> 01:08:37,770
Now, I'm ready to
run the body.

1284
01:08:37,770 --> 01:08:41,100
Run the body in the
environment, E2.

1285
01:08:41,100 --> 01:08:46,319
When I run return a plus
b in E2, I have to

1286
01:08:46,319 --> 01:08:48,760
first figure out a.

1287
01:08:48,760 --> 01:08:52,000
Well, that's easy. a is 2.

1288
01:08:52,000 --> 01:08:53,319
Then, I have to figure out b.

1289
01:08:53,319 --> 01:08:54,569
What's b?

1290
01:08:54,569 --> 01:08:58,510

1291
01:08:58,510 --> 01:08:58,989
AUDIENCE: 6?

1292
01:08:58,989 --> 01:08:59,468
PROFESSOR: 6.

1293
01:08:59,468 --> 01:09:00,905
So how did you get 6?

1294
01:09:00,905 --> 01:09:03,300
AUDIENCE: [INAUDIBLE].

1295
01:09:03,300 --> 01:09:06,479
PROFESSOR: So this local
environment that was created

1296
01:09:06,479 --> 01:09:12,330
for the formal parameter has,
as its parent, E1 because

1297
01:09:12,330 --> 01:09:13,819
that's where the procedure
was defined.

1298
01:09:13,819 --> 01:09:17,069

1299
01:09:17,069 --> 01:09:22,340
So it doesn't find b in this
local environment.

1300
01:09:22,340 --> 01:09:23,970
So it goes to the parent.

1301
01:09:23,970 --> 01:09:28,140
Do you have a "b?" And it could,
in principal, propagate

1302
01:09:28,140 --> 01:09:29,970
up a chain of environments.

1303
01:09:29,970 --> 01:09:32,350
So you could construct
this hierarchically.

1304
01:09:32,350 --> 01:09:37,290
So it will resolve bindings in
the most recent environment

1305
01:09:37,290 --> 01:09:39,950
that has that binding.

1306
01:09:39,950 --> 01:09:45,490
So the answer, then, is that
when you run biz of 2, this b

1307
01:09:45,490 --> 01:09:51,290
gets associated with
that b, OK?

1308
01:09:51,290 --> 01:09:55,840
So that's how the environments
work for simple procedures and

1309
01:09:55,840 --> 01:09:57,870
simple data structures.

1310
01:09:57,870 --> 01:10:01,800
It's very similar for the way
it works with classes.

1311
01:10:01,800 --> 01:10:05,180
So imagine that I had this
data, and I wanted to

1312
01:10:05,180 --> 01:10:07,110
represent that in Python.

1313
01:10:07,110 --> 01:10:10,330
What I might do is look at
the common features.

1314
01:10:10,330 --> 01:10:11,650
The courses are all the same.

1315
01:10:11,650 --> 01:10:12,750
The rooms are all the same.

1316
01:10:12,750 --> 01:10:13,800
The buildings are
all the same.

1317
01:10:13,800 --> 01:10:16,690
The ages are highly variable.

1318
01:10:16,690 --> 01:10:19,400
So I might want to create
a class that

1319
01:10:19,400 --> 01:10:21,860
has the common data.

1320
01:10:21,860 --> 01:10:23,920
So I might do this--

1321
01:10:23,920 --> 01:10:26,230
class Staff601.

1322
01:10:26,230 --> 01:10:27,480
The course is 601.

1323
01:10:27,480 --> 01:10:28,280
The building's 34.

1324
01:10:28,280 --> 01:10:30,390
The room is this.

1325
01:10:30,390 --> 01:10:38,570
The way Python implements a
class is as an environment.

1326
01:10:38,570 --> 01:10:43,160
Executing this set of statements
builds the class

1327
01:10:43,160 --> 01:10:44,050
environment.

1328
01:10:44,050 --> 01:10:45,810
This is it.

1329
01:10:45,810 --> 01:10:48,010
It's a list of bindings.

1330
01:10:48,010 --> 01:10:50,430
Here, I'm binding the
name, course, to the

1331
01:10:50,430 --> 01:10:53,270
string, 601, et cetera.

1332
01:10:53,270 --> 01:10:55,250
If there were a method, I
would do the same thing,

1333
01:10:55,250 --> 01:10:59,070
except it would look like
a procedure then.

1334
01:10:59,070 --> 01:11:06,330
So this creates the Staff601
environment.

1335
01:11:06,330 --> 01:11:12,300
Staff601, because I executed
this class statement, that

1336
01:11:12,300 --> 01:11:18,710
creates a binding in the local
environment, Staff601, which

1337
01:11:18,710 --> 01:11:22,650
points to the new environment.

1338
01:11:22,650 --> 01:11:26,320
So now, in the future, when
Python encounters the name

1339
01:11:26,320 --> 01:11:33,430
Staff601, it will discover that
that's an environment.

1340
01:11:33,430 --> 01:11:39,330
Python implements classes
as environments.

1341
01:11:39,330 --> 01:11:46,600
So now, when I want to access
elements within a class, I use

1342
01:11:46,600 --> 01:11:47,710
a special notation.

1343
01:11:47,710 --> 01:11:49,870
It's a dot notation.

1344
01:11:49,870 --> 01:11:56,480
Python regards dots as ways of
navigating an environment.

1345
01:11:56,480 --> 01:12:02,310
When Python parses staff.room,
it looks up Staff601 in the

1346
01:12:02,310 --> 01:12:04,200
current environment.

1347
01:12:04,200 --> 01:12:08,540
If it finds an environment, it
then says, oh, I know about

1348
01:12:08,540 --> 01:12:09,640
this .room thing.

1349
01:12:09,640 --> 01:12:14,470
All I do is I look up
the room name in

1350
01:12:14,470 --> 01:12:18,670
the environment Staff601.

1351
01:12:18,670 --> 01:12:21,100
And when it does that, it
gets the answer 501.

1352
01:12:21,100 --> 01:12:23,890
And the same sort of
thing happens here.

1353
01:12:23,890 --> 01:12:25,450
It looks up Staff601.

1354
01:12:25,450 --> 01:12:26,970
It finds an environment.

1355
01:12:26,970 --> 01:12:28,010
It looks up coolness.

1356
01:12:28,010 --> 01:12:29,530
It finds out there
is no such thing.

1357
01:12:29,530 --> 01:12:32,700
Well, no, that's not true.

1358
01:12:32,700 --> 01:12:40,250
So it creates coolness within
601 and assigns an

1359
01:12:40,250 --> 01:12:43,890
integer, 11, to it.

1360
01:12:43,890 --> 01:12:51,660
So then, the way Python treats
methods is completely

1361
01:12:51,660 --> 01:12:54,530
analogous--

1362
01:12:54,530 --> 01:12:56,280
oh, excuse me, instances.

1363
01:12:56,280 --> 01:12:58,060
I'm doing instances first.

1364
01:12:58,060 --> 01:13:04,490
If I make pat be an instance
of Staff601, pat is an

1365
01:13:04,490 --> 01:13:08,320
instance of the class
Staff601.

1366
01:13:08,320 --> 01:13:14,590
pat is implemented as
an environment.

1367
01:13:14,590 --> 01:13:19,100
So when I make pat, pat points
to a new environment--

1368
01:13:19,100 --> 01:13:20,340
here, E3.

1369
01:13:20,340 --> 01:13:24,320
The parent of E3 is the class
that pat belongs to,

1370
01:13:24,320 --> 01:13:25,570
which is, here, E2.

1371
01:13:25,570 --> 01:13:27,860

1372
01:13:27,860 --> 01:13:31,120
And when I make the instance,
it's empty.

1373
01:13:31,120 --> 01:13:36,150
But now, if I ask what is
pat.course, well, pat points

1374
01:13:36,150 --> 01:13:37,050
to this environment.

1375
01:13:37,050 --> 01:13:39,120
Does this environment have
something called a course?

1376
01:13:39,120 --> 01:13:39,950
No.

1377
01:13:39,950 --> 01:13:40,780
Does the parent?

1378
01:13:40,780 --> 01:13:42,030
Yes.

1379
01:13:42,030 --> 01:13:43,670

1380
01:13:43,670 --> 01:13:45,770
Course is bound to
the string 601.

1381
01:13:45,770 --> 01:13:50,220
So pat.course is 601
just the same as

1382
01:13:50,220 --> 01:13:53,570
Staff601.course had been 601.

1383
01:13:53,570 --> 01:13:56,640
pat is an instance.

1384
01:13:56,640 --> 01:14:00,530
It's a new environment
with the class

1385
01:14:00,530 --> 01:14:02,405
environment as its parent.

1386
01:14:02,405 --> 01:14:06,830

1387
01:14:06,830 --> 01:14:12,980
You can add attributes
to instances.

1388
01:14:12,980 --> 01:14:17,930
And all that does is populate
the environment associated

1389
01:14:17,930 --> 01:14:21,220
with the instance.

1390
01:14:21,220 --> 01:14:26,140
You can add methods
to classes.

1391
01:14:26,140 --> 01:14:28,650
And that does the same thing.

1392
01:14:28,650 --> 01:14:32,310
So here, I've got the class,
Staff601, which has a method,

1393
01:14:32,310 --> 01:14:35,930
salutation, instance
variables, course,

1394
01:14:35,930 --> 01:14:38,410
building, and room.

1395
01:14:38,410 --> 01:14:42,300
So when I build that structure,
Staff601 points to

1396
01:14:42,300 --> 01:14:45,470
an environment that contains
salutation, which is a

1397
01:14:45,470 --> 01:14:50,450
procedure, in addition to a
bunch of instance variables.

1398
01:14:50,450 --> 01:14:53,880

1399
01:14:53,880 --> 01:14:56,480
So now, all of the rules that
we've talked about with regard

1400
01:14:56,480 --> 01:15:00,910
to environments apply
now to this class.

1401
01:15:00,910 --> 01:15:07,580
So in particular, I can say
Staff601 salutation of pat.

1402
01:15:07,580 --> 01:15:12,436
When Python parses Staff601,
it finds an environment.

1403
01:15:12,436 --> 01:15:15,710

1404
01:15:15,710 --> 01:15:17,060
It says dot salutation.

1405
01:15:17,060 --> 01:15:19,550
Oh, I know how to do that.

1406
01:15:19,550 --> 01:15:25,440
Within the environment,
Staff601, look for a binding

1407
01:15:25,440 --> 01:15:28,800
for the name salutation.

1408
01:15:28,800 --> 01:15:29,800
Do I find one?

1409
01:15:29,800 --> 01:15:31,110
Well, yeah, there it is.

1410
01:15:31,110 --> 01:15:32,430
It points to a procedure.

1411
01:15:32,430 --> 01:15:35,560
So staff dot salutation
is a procedure.

1412
01:15:35,560 --> 01:15:38,590
Do just the same things that
we would have done with a

1413
01:15:38,590 --> 01:15:39,500
simple procedure.

1414
01:15:39,500 --> 01:15:41,230
The only difference
here is that the

1415
01:15:41,230 --> 01:15:42,535
procedure came from a class.

1416
01:15:42,535 --> 01:15:45,200

1417
01:15:45,200 --> 01:15:54,040
In this particular case, the
sub-routine that I define has

1418
01:15:54,040 --> 01:15:57,760
a formal parameter, self.

1419
01:15:57,760 --> 01:16:01,060
So then, that's going to have
to build when I try to

1420
01:16:01,060 --> 01:16:01,780
evaluate it.

1421
01:16:01,780 --> 01:16:10,560
That has to build a binding for
self, which is set to pat.

1422
01:16:10,560 --> 01:16:12,660
pat was an environment.

1423
01:16:12,660 --> 01:16:16,130
So self gets pointed to pat.

1424
01:16:16,130 --> 01:16:21,250
So now, when I run
Staff601.salutation on pat, it

1425
01:16:21,250 --> 01:16:25,350
behaves as though that generic
method was applied to the

1426
01:16:25,350 --> 01:16:26,600
instance pat.

1427
01:16:26,600 --> 01:16:29,330

1428
01:16:29,330 --> 01:16:30,460
We'll do that a lot.

1429
01:16:30,460 --> 01:16:32,410
It's a little bit
of redundancy.

1430
01:16:32,410 --> 01:16:38,110
We know that pat is a
member of Staff601.

1431
01:16:38,110 --> 01:16:41,010
So we will define a special
form-- or I should say, Python

1432
01:16:41,010 --> 01:16:44,610
defines a special form-- that
makes that easy to say.

1433
01:16:44,610 --> 01:16:49,270
This is the way we will usually
say, the instance pat

1434
01:16:49,270 --> 01:16:56,790
should run the class method
salutation on itself.

1435
01:16:56,790 --> 01:17:00,020
This is simply a simplified
notation that means

1436
01:17:00,020 --> 01:17:06,520
precisely that, OK?

1437
01:17:06,520 --> 01:17:10,960
So what we covered today, then,
was supposed to be the

1438
01:17:10,960 --> 01:17:15,410
most elementary ideas in how
you construct modular

1439
01:17:15,410 --> 01:17:20,500
programs, Modularity
at the small scale.

1440
01:17:20,500 --> 01:17:24,110
How do you make operations that
are hierarchical, data

1441
01:17:24,110 --> 01:17:26,270
structures, and classes?

1442
01:17:26,270 --> 01:17:30,020
What we will do for the rest of
the week is practice those

1443
01:17:30,020 --> 01:17:31,270
activities.

1444
01:17:31,270 --> 01:17:34,657