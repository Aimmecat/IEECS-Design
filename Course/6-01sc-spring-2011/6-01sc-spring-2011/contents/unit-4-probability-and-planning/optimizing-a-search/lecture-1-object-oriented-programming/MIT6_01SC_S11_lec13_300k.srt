1
00:00:00,000 --> 00:00:00,530

2
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

3
00:00:02,960 --> 00:00:04,370
Commons license.

4
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

5
00:00:07,410 --> 00:00:11,060
offer high quality educational
resources for free.

6
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

7
00:00:13,960 --> 00:00:18,940
hundreds of MIT courses, visit
MIT OpenCourseWare at

8
00:00:18,940 --> 00:00:20,190
ocw.mit.edu.

9
00:00:20,190 --> 00:00:24,368

10
00:00:24,368 --> 00:00:25,620
PROFESSOR: So hello.

11
00:00:25,620 --> 00:00:28,500

12
00:00:28,500 --> 00:00:31,380
Today I want to talk about, and
I want to finish talking

13
00:00:31,380 --> 00:00:32,914
about, search algorithms.

14
00:00:32,914 --> 00:00:35,530

15
00:00:35,530 --> 00:00:38,710
So last time we started to think
about a framework within

16
00:00:38,710 --> 00:00:42,030
which to think about search and
the important thing was to

17
00:00:42,030 --> 00:00:45,350
figure out a way to be
systematic about it.

18
00:00:45,350 --> 00:00:48,280
So we figured out a way to
organize the way we think

19
00:00:48,280 --> 00:00:51,400
about searching by
way of a tree.

20
00:00:51,400 --> 00:00:54,270
Put all the possible places
where we could be in the

21
00:00:54,270 --> 00:00:58,380
search, consider all the
possible actions that we could

22
00:00:58,380 --> 00:01:00,970
take, so if we started it at
A, there are two different

23
00:01:00,970 --> 00:01:03,980
actions we could've taken, we
could have gone to B or D

24
00:01:03,980 --> 00:01:08,750
Think of the actions as the
edges of the graph and then

25
00:01:08,750 --> 00:01:12,100
think about where we land.

26
00:01:12,100 --> 00:01:16,510
Then, by way of that graph,
think about the shortest path

27
00:01:16,510 --> 00:01:17,990
to the goal.

28
00:01:17,990 --> 00:01:23,690
So that was the idea and the big
outcome was order matters.

29
00:01:23,690 --> 00:01:29,030
So if we were to construct an
agenda, which is the list of

30
00:01:29,030 --> 00:01:33,270
nodes that we are currently
considering, if we started at

31
00:01:33,270 --> 00:01:37,660
A, we would start by putting
A on the agenda.

32
00:01:37,660 --> 00:01:41,350
Then we would pop A out of the
agenda and replace it with its

33
00:01:41,350 --> 00:01:45,240
children, its children
are AB and AD.

34
00:01:45,240 --> 00:01:48,820
If the algorithm was replaced,
the first node in the agenda

35
00:01:48,820 --> 00:01:51,620
by the children, the
first node is AB.

36
00:01:51,620 --> 00:01:55,760
So then we would pop AB and
replace it with its children,

37
00:01:55,760 --> 00:01:57,490
AB has children ACE, etc.

38
00:01:57,490 --> 00:02:02,110

39
00:02:02,110 --> 00:02:04,350
And the result would be
something that we call a depth

40
00:02:04,350 --> 00:02:07,890
first search, because what's
happening is we're following

41
00:02:07,890 --> 00:02:14,400
line lines deeply before
we look crosswise.

42
00:02:14,400 --> 00:02:16,610
And there's a million varieties
of this that you

43
00:02:16,610 --> 00:02:17,730
could think of.

44
00:02:17,730 --> 00:02:20,010
You would get the same kind of
algorithm if you replaced the

45
00:02:20,010 --> 00:02:22,900
last node by its children.

46
00:02:22,900 --> 00:02:26,210
Then you would start with A,
replace it by its children,

47
00:02:26,210 --> 00:02:27,870
which is still B,D --

48
00:02:27,870 --> 00:02:32,900
but now expand D in terms
of its children.

49
00:02:32,900 --> 00:02:37,510
Then you'd take the last trial,
expand it and we would

50
00:02:37,510 --> 00:02:39,300
get another depth search.

51
00:02:39,300 --> 00:02:43,960
So the idea is whatever order
you choose affects the

52
00:02:43,960 --> 00:02:46,210
solution that you find.

53
00:02:46,210 --> 00:02:49,470
Generally, we're interested in
finding a search that locates

54
00:02:49,470 --> 00:02:56,820
the best, shortest path, and so
a good method is to remove

55
00:02:56,820 --> 00:02:59,250
the first node from the
agenda and add the

56
00:02:59,250 --> 00:03:01,730
children to the end.

57
00:03:01,730 --> 00:03:07,890
That's a cube-based ordering
where the first out

58
00:03:07,890 --> 00:03:10,370
is the first in.

59
00:03:10,370 --> 00:03:13,600
Then if you imagine starting
at A, replacing it by its

60
00:03:13,600 --> 00:03:18,680
children, B,D, take the first
guy out-- that's AB--

61
00:03:18,680 --> 00:03:22,730
consider its children and put
them at the end of the list.

62
00:03:22,730 --> 00:03:26,930
Then we go back and expand AD
before we think about the

63
00:03:26,930 --> 00:03:31,500
children of AB and so the
result-- if you just follow

64
00:03:31,500 --> 00:03:32,930
the red up here--

65
00:03:32,930 --> 00:03:36,850
the result of that search is
what we call breadth first.

66
00:03:36,850 --> 00:03:39,960
So we systematically propagate
down the search tree looking

67
00:03:39,960 --> 00:03:42,290
at short paths first.

68
00:03:42,290 --> 00:03:45,460
So that's the idea, the idea
is search is easy, you

69
00:03:45,460 --> 00:03:51,130
organize it around one of
these graphs and just

70
00:03:51,130 --> 00:03:53,980
systematically run through the
search by keeping track of

71
00:03:53,980 --> 00:03:57,290
what we call the agenda, the
nodes under consideration, and

72
00:03:57,290 --> 00:04:01,140
the only trick is that
order matters.

73
00:04:01,140 --> 00:04:06,270
We found two useful orders last
time, first in, first out

74
00:04:06,270 --> 00:04:10,180
and last in, first out, one of
those giving depth first,

75
00:04:10,180 --> 00:04:11,750
which is generally
not a good idea.

76
00:04:11,750 --> 00:04:13,450
The other giving breadth first,
which is generally a

77
00:04:13,450 --> 00:04:14,770
much better idea.

78
00:04:14,770 --> 00:04:17,959
Today what I want to do is
generalize that structure to

79
00:04:17,959 --> 00:04:22,400
take into account a much more
flexible group of problems.

80
00:04:22,400 --> 00:04:26,930
That'll give rise to something
we call uniform cost search

81
00:04:26,930 --> 00:04:28,420
and the other thing that
I want to think about

82
00:04:28,420 --> 00:04:31,170
is, again, the order.

83
00:04:31,170 --> 00:04:34,120
By thinking about the order, we
can drastically improve the

84
00:04:34,120 --> 00:04:38,610
efficiency of a search and
that idea gives rise to

85
00:04:38,610 --> 00:04:42,100
something that we'll
call heuristics.

86
00:04:42,100 --> 00:04:48,740
So the idea then that I want to
look at first in terms of

87
00:04:48,740 --> 00:04:53,270
uniform cost search is the idea
that so far, we've only

88
00:04:53,270 --> 00:04:56,580
looked at problems where
the cost of each

89
00:04:56,580 --> 00:05:00,810
child is the same.

90
00:05:00,810 --> 00:05:06,280
We were only looking at how many
children in total, how

91
00:05:06,280 --> 00:05:10,740
many generations did we have to
go through to get from the

92
00:05:10,740 --> 00:05:13,650
starting point to the goal.

93
00:05:13,650 --> 00:05:16,330
That's an important class of
problems, but it's by no means

94
00:05:16,330 --> 00:05:19,180
the only important class of
problems and in fact, the most

95
00:05:19,180 --> 00:05:21,590
trivial problems you can think
of don't fall into that class.

96
00:05:21,590 --> 00:05:25,170
So for example, imagine that
what we were doing, so I

97
00:05:25,170 --> 00:05:28,300
motivated the entire problem
last time in terms of

98
00:05:28,300 --> 00:05:31,320
searching for a path on
a Manhattan Grid.

99
00:05:31,320 --> 00:05:36,240
So if I wanted to go from A to
I, where all the distances are

100
00:05:36,240 --> 00:05:40,410
equal, then minimizing the
number of generations,

101
00:05:40,410 --> 00:05:42,420
minimizing the number of
intersections that I go

102
00:05:42,420 --> 00:05:44,480
through, will give rise
to the best search.

103
00:05:44,480 --> 00:05:48,570
However, imagine that
one particular node

104
00:05:48,570 --> 00:05:52,060
is way off the map.

105
00:05:52,060 --> 00:05:55,000
Then the number of generations
that I go through is obviously

106
00:05:55,000 --> 00:05:58,670
not the right answer because
there's a penalty for taking a

107
00:05:58,670 --> 00:06:02,060
path that goes through C because
the distance between B

108
00:06:02,060 --> 00:06:04,540
and C is so much bigger than
the distance, for example,

109
00:06:04,540 --> 00:06:08,050
from D to G.

110
00:06:08,050 --> 00:06:10,400
So the first thing that I want
to look at is how do we

111
00:06:10,400 --> 00:06:12,610
incorporate that kind
of new information

112
00:06:12,610 --> 00:06:15,190
into the search algorithm?

113
00:06:15,190 --> 00:06:19,780
So before I do that,
think about how the

114
00:06:19,780 --> 00:06:21,210
breadth-first search--

115
00:06:21,210 --> 00:06:23,270
the thing we found last time
that was the best--

116
00:06:23,270 --> 00:06:25,650
breadth-first search with
dynamic programming --

117
00:06:25,650 --> 00:06:28,930
think about how it would
approach the problem and think

118
00:06:28,930 --> 00:06:33,020
about as we go through step by
step, what is it doing wrong?

119
00:06:33,020 --> 00:06:33,300
OK?

120
00:06:33,300 --> 00:06:35,410
So I'm going to go through
an algorithm that is

121
00:06:35,410 --> 00:06:37,850
known not to work --

122
00:06:37,850 --> 00:06:40,660
with the idea that you're
supposed to identify as I'm

123
00:06:40,660 --> 00:06:44,770
doing that what step
was wrong.

124
00:06:44,770 --> 00:06:48,970
So imagine that I'm doing this
and then I'm going to compare

125
00:06:48,970 --> 00:06:51,130
it in a moment to C
being off the map.

126
00:06:51,130 --> 00:06:53,860

127
00:06:53,860 --> 00:06:58,490
So if I do this problem with
dynamic programming, I have to

128
00:06:58,490 --> 00:07:02,710
keep track of how many nodes I
already visited and I have to

129
00:07:02,710 --> 00:07:05,270
keep track of all the nodes
under consideration.

130
00:07:05,270 --> 00:07:08,030
The nodes under consideration is
what we call the agenda and

131
00:07:08,030 --> 00:07:11,730
I will call the list of nodes
that we're keeping track of

132
00:07:11,730 --> 00:07:14,020
for dynamic programming, I'll
call that the visited list

133
00:07:14,020 --> 00:07:17,240
because we'll add nodes
to the list.

134
00:07:17,240 --> 00:07:21,200
We'll add states to the
list as we visit them.

135
00:07:21,200 --> 00:07:24,820
So we start out the algorithm
with node A being on the

136
00:07:24,820 --> 00:07:30,470
agenda, we're trying to go to
node I. And by the time I've

137
00:07:30,470 --> 00:07:34,070
started, I've already visited
A. So the starting point is

138
00:07:34,070 --> 00:07:36,980
that the visited list has one
element in at A, the agenda

139
00:07:36,980 --> 00:07:42,240
has one element in it, A. So the
algorithm is going to be

140
00:07:42,240 --> 00:07:46,070
pop the first guy out of the
agenda and add the children to

141
00:07:46,070 --> 00:07:50,520
the end, paying attention
to the visited list.

142
00:07:50,520 --> 00:07:55,970
So pop A out of the agenda, the
children of A are B and D.

143
00:07:55,970 --> 00:07:59,530
As I visit them, they get added
to visited list, B and

144
00:07:59,530 --> 00:08:07,460
D. So I pop the first person
out, that's AB.

145
00:08:07,460 --> 00:08:11,080
Then I want to think about the
children of AB, that's ACE.

146
00:08:11,080 --> 00:08:16,310
A is already visited, so I don't
need to add that again,

147
00:08:16,310 --> 00:08:19,410
but C and E are not, so I add
them and add them to the

148
00:08:19,410 --> 00:08:20,660
visited last.

149
00:08:20,660 --> 00:08:23,250

150
00:08:23,250 --> 00:08:29,230
Then I pop AD out, well
the children are AEG.

151
00:08:29,230 --> 00:08:32,950
A and E are in the list already,
G is not, so I end up

152
00:08:32,950 --> 00:08:35,100
adding G to the list.

153
00:08:35,100 --> 00:08:38,580

154
00:08:38,580 --> 00:08:43,460
Next is to pop out C. The
children of C are B and F. B

155
00:08:43,460 --> 00:08:46,010
was in the list, F was not
so I add the trial that

156
00:08:46,010 --> 00:08:47,260
has F at the end.

157
00:08:47,260 --> 00:08:51,000

158
00:08:51,000 --> 00:08:56,070
Then the next one is E.
E has children BDFH.

159
00:08:56,070 --> 00:09:05,930
B,D,F, the only new one is H,
then G. Take G out, the

160
00:09:05,930 --> 00:09:08,230
children of G are D and H but
they're already in a visited

161
00:09:08,230 --> 00:09:09,700
list, so I don't need
to worry about them.

162
00:09:09,700 --> 00:09:13,130

163
00:09:13,130 --> 00:09:20,850
Then A,B,C,F, so F is this guy,
C,E,I. CE I is not in the

164
00:09:20,850 --> 00:09:23,920
list, and that's my answer.

165
00:09:23,920 --> 00:09:26,842

166
00:09:26,842 --> 00:09:27,816
Yes?

167
00:09:27,816 --> 00:09:32,686
AUDIENCE: [UNINTELLIGIBLE]
once more, then you get

168
00:09:32,686 --> 00:09:34,634
another path that's
equally short.

169
00:09:34,634 --> 00:09:36,095
So why is that not the
correct answer?

170
00:09:36,095 --> 00:09:39,010

171
00:09:39,010 --> 00:09:40,100
PROFESSOR: A slightly different
algorithm might give

172
00:09:40,100 --> 00:09:41,350
me that solution.

173
00:09:41,350 --> 00:09:43,350

174
00:09:43,350 --> 00:09:47,080
All that I'm tracing here, I'm
trying to be consistent with

175
00:09:47,080 --> 00:09:49,980
the algorithm that we
discussed last time.

176
00:09:49,980 --> 00:09:52,350
But that's a very good point.

177
00:09:52,350 --> 00:09:56,750
So the breadth-first search with
dynamic programming is

178
00:09:56,750 --> 00:09:59,510
guaranteed to give
you a solution

179
00:09:59,510 --> 00:10:02,450
that has minimum length.

180
00:10:02,450 --> 00:10:07,040
It's not guaranteed to give you
a particular solution of

181
00:10:07,040 --> 00:10:07,620
minimum length.

182
00:10:07,620 --> 00:10:10,450
So when there exists multiple
solutions with the same

183
00:10:10,450 --> 00:10:14,230
length, this search algorithm
might to give you any of them,

184
00:10:14,230 --> 00:10:15,780
and that's an important
thing to keep in mind.

185
00:10:15,780 --> 00:10:20,130

186
00:10:20,130 --> 00:10:23,170
So with regard to the problem,
I'm trying to think ahead.

187
00:10:23,170 --> 00:10:25,900
I'm trying to think ahead to
where this C is off the map,

188
00:10:25,900 --> 00:10:27,150
it's over here someplace.

189
00:10:27,150 --> 00:10:29,550

190
00:10:29,550 --> 00:10:33,730
So what I want to do is stop
thinking about how many hops

191
00:10:33,730 --> 00:10:36,460
there were and start
thinking about how

192
00:10:36,460 --> 00:10:39,330
many miles there are.

193
00:10:39,330 --> 00:10:43,670
The first thing I want you to
notice is that this search

194
00:10:43,670 --> 00:10:49,500
pattern that we did created
a visitation list.

195
00:10:49,500 --> 00:10:51,940
We visited the states
in the order of

196
00:10:51,940 --> 00:10:55,400
increasing number of hops.

197
00:10:55,400 --> 00:10:58,230
That's obviously a good thing.

198
00:10:58,230 --> 00:11:01,890
If we can always keep in the
agenda the smallest number of

199
00:11:01,890 --> 00:11:07,570
hops to the next place, and if
we faithfully visit states

200
00:11:07,570 --> 00:11:10,600
starting at the minimum number
and proceeding up, so we

201
00:11:10,600 --> 00:11:13,440
started with A, there's
no hops in getting to

202
00:11:13,440 --> 00:11:15,510
A, so that's 0.

203
00:11:15,510 --> 00:11:18,930
In going from A to
B, there's 1 hop.

204
00:11:18,930 --> 00:11:20,850
In going from A to
D there's 1 hop.

205
00:11:20,850 --> 00:11:24,445
In going from A to B to C,
ABC, there's 2 hops.

206
00:11:24,445 --> 00:11:27,050

207
00:11:27,050 --> 00:11:31,050
So what the algorithm that
we described last time--

208
00:11:31,050 --> 00:11:33,250
breadth-first with than dynamic
programming does--

209
00:11:33,250 --> 00:11:37,150
is it visits the states
in the order of

210
00:11:37,150 --> 00:11:38,450
increasing number of hops.

211
00:11:38,450 --> 00:11:41,990
That's obviously a good thing.

212
00:11:41,990 --> 00:11:44,890
OK so what's my next slide?

213
00:11:44,890 --> 00:11:49,350
I want to think about
C being off the map.

214
00:11:49,350 --> 00:11:53,930
So what I'd like to do is think
about what order would

215
00:11:53,930 --> 00:11:58,853
this algorithm visit
number of miles?

216
00:11:58,853 --> 00:12:03,580
So If I think about replacing
the metric in the bottom with

217
00:12:03,580 --> 00:12:07,710
the number of miles, whenever
the different actions that can

218
00:12:07,710 --> 00:12:12,150
occur incur different costs.

219
00:12:12,150 --> 00:12:13,190
Think about what I'm saying.

220
00:12:13,190 --> 00:12:15,530
So I'm saying that if I were
at B and I think about my

221
00:12:15,530 --> 00:12:23,280
children ACE, which action I
take, go from B to A or go

222
00:12:23,280 --> 00:12:27,760
from B to C are go from B to A,
which action I take incurs

223
00:12:27,760 --> 00:12:31,010
different cost.

224
00:12:31,010 --> 00:12:35,320
So what I want to do now is
think about, change the focus

225
00:12:35,320 --> 00:12:38,070
from thinking about how many
hops is it to thinking about

226
00:12:38,070 --> 00:12:41,350
how many miles is it.

227
00:12:41,350 --> 00:12:43,930
So now, if I replace
the metric--

228
00:12:43,930 --> 00:12:47,610
so over here, the metric was
how many hops, replace how

229
00:12:47,610 --> 00:12:51,050
many hops with how
many miles--

230
00:12:51,050 --> 00:12:55,330
and what you see is that the
algorithm is not picking up.

231
00:12:55,330 --> 00:12:59,930
It's not visiting the
states in order of

232
00:12:59,930 --> 00:13:02,410
increasing path length.

233
00:13:02,410 --> 00:13:04,130
That's what's wrong.

234
00:13:04,130 --> 00:13:09,890
So what we'd like to do is
modify the algorithm somehow

235
00:13:09,890 --> 00:13:16,640
so that it proceeds through the
paths shortest to longest.

236
00:13:16,640 --> 00:13:19,390
So that's the goal.

237
00:13:19,390 --> 00:13:21,600
And that's pretty easy to do.

238
00:13:21,600 --> 00:13:25,970
The first thing we have to do
is put that new information

239
00:13:25,970 --> 00:13:30,290
somewhere, and I've already
alluded to the fact that the

240
00:13:30,290 --> 00:13:32,440
way to think about the new
information is that it's

241
00:13:32,440 --> 00:13:35,120
associated with actions.

242
00:13:35,120 --> 00:13:37,530
It's not associated
with states.

243
00:13:37,530 --> 00:13:45,250
States are where we go to in the
diagram, like state E. The

244
00:13:45,250 --> 00:13:49,040
extra cost is not summarized in
the state, the extra cost

245
00:13:49,040 --> 00:13:53,880
is summarized in the exact
path that we took.

246
00:13:53,880 --> 00:13:56,900
And the way we'll think about
that is incrementally.

247
00:13:56,900 --> 00:14:01,750
So we create the past by doing
actions and each action has a

248
00:14:01,750 --> 00:14:02,670
different cost.

249
00:14:02,670 --> 00:14:06,060
So the first thing we do is
associate this additional cost

250
00:14:06,060 --> 00:14:08,880
with the actions.

251
00:14:08,880 --> 00:14:14,110
Then we are looking for a search
procedure that will

252
00:14:14,110 --> 00:14:17,780
enumerate the paths in the
order of path cost.

253
00:14:17,780 --> 00:14:21,400
And the way to do that is to
think about the basic ordering

254
00:14:21,400 --> 00:14:27,340
schemes that we had before,
which were the stack, last in,

255
00:14:27,340 --> 00:14:32,390
first out versus the queue,
first in, first out.

256
00:14:32,390 --> 00:14:34,550
What we'll do is we'll make a
trivial modification to the

257
00:14:34,550 --> 00:14:38,580
idea of a queue and we'll call
it a priority queue.

258
00:14:38,580 --> 00:14:43,580
So a priority queue is basically
like a queue, except

259
00:14:43,580 --> 00:14:47,360
the things that are queued
have priorities.

260
00:14:47,360 --> 00:14:53,250
So the idea will be that when
you push at possible action,

261
00:14:53,250 --> 00:14:56,350
say I had actions A,B, or C --

262
00:14:56,350 --> 00:14:59,510
in addition to pushing them onto
the queue, which is how

263
00:14:59,510 --> 00:15:03,750
we would have done breadth-first
search, in

264
00:15:03,750 --> 00:15:06,460
addition to pushing them on the
queue, I'll also associate

265
00:15:06,460 --> 00:15:09,190
with them a cost.

266
00:15:09,190 --> 00:15:13,650
So when I push A on the queue,
the priority queue, I'll

267
00:15:13,650 --> 00:15:16,070
associate with that a cost,
which I've arbitrarily said

268
00:15:16,070 --> 00:15:19,960
here, the cost is 3.

269
00:15:19,960 --> 00:15:22,620
When I push B, I'll associate
a cost 6.

270
00:15:22,620 --> 00:15:26,090
When I push C, I'll associate a
cost 1 so that when I do the

271
00:15:26,090 --> 00:15:29,990
first pop, what will come out
will be the element that I

272
00:15:29,990 --> 00:15:35,540
pushed that has the smallest
associated cost.

273
00:15:35,540 --> 00:15:39,600
That'll be a way that I can
order then my search through

274
00:15:39,600 --> 00:15:43,350
the search tree in terms
of the minimum costs.

275
00:15:43,350 --> 00:15:46,170
Is that clear?

276
00:15:46,170 --> 00:15:49,120
So the first time I do a pop,
the element that pops out is

277
00:15:49,120 --> 00:15:51,723
the one with the least cost,
which is this one, so I get C.

278
00:15:51,723 --> 00:15:58,000
C is then removed from the list
and the second time I do

279
00:15:58,000 --> 00:16:01,810
it, when I do a pop, I pick out
the one with the cost 3

280
00:16:01,810 --> 00:16:07,880
which is A. That's an easy
modification to the schemes

281
00:16:07,880 --> 00:16:08,740
that we used before.

282
00:16:08,740 --> 00:16:11,300
Just like before, we can
implement a priority queue

283
00:16:11,300 --> 00:16:13,320
with a list.

284
00:16:13,320 --> 00:16:18,020
Here we've put all the
complication into popping.

285
00:16:18,020 --> 00:16:22,540
So we just push like we did
before, just jam it in.

286
00:16:22,540 --> 00:16:24,750
So just add it to the
end of the list.

287
00:16:24,750 --> 00:16:28,830
And we put the complication into
pop, pop looks through

288
00:16:28,830 --> 00:16:31,500
the list and finds the
one that has the

289
00:16:31,500 --> 00:16:34,120
biggest negative cost.

290
00:16:34,120 --> 00:16:36,880
That's just because we've got a
utility routine that gave us

291
00:16:36,880 --> 00:16:38,130
the biggest.

292
00:16:38,130 --> 00:16:39,990
We want the smallest.

293
00:16:39,990 --> 00:16:45,780
We know that the costs are
non-negative, so we implement

294
00:16:45,780 --> 00:16:48,310
the find the smallest by calling
the routine find the

295
00:16:48,310 --> 00:16:50,695
biggest with a negative cost.

296
00:16:50,695 --> 00:16:53,440

297
00:16:53,440 --> 00:16:57,110
So notice that all the new
complication is in this pop

298
00:16:57,110 --> 00:16:59,460
routine, and if you think
about it, pop is doing

299
00:16:59,460 --> 00:17:02,510
far too much work.

300
00:17:02,510 --> 00:17:06,609
The way this routine works,
every time you do a pop, it

301
00:17:06,609 --> 00:17:08,349
goes through the whole
list looking for

302
00:17:08,349 --> 00:17:10,660
something that is small.

303
00:17:10,660 --> 00:17:13,970
Obviously it ought to be able to
keep track of progress that

304
00:17:13,970 --> 00:17:16,339
it's made in that previously.

305
00:17:16,339 --> 00:17:18,520
There are much better
algorithms, but for the

306
00:17:18,520 --> 00:17:21,660
purpose of this illustration,
we didn't bother with it.

307
00:17:21,660 --> 00:17:26,319
So this is not a very clever
implementation.

308
00:17:26,319 --> 00:17:27,970
We're not trying to be clever,
we're trying to

309
00:17:27,970 --> 00:17:30,450
illustrate the point.

310
00:17:30,450 --> 00:17:33,780
So if you were seriously try to
do a big search, if you're

311
00:17:33,780 --> 00:17:37,950
writing code for Google, you
would never do it this way.

312
00:17:37,950 --> 00:17:40,650
But the idea again is
in abstraction.

313
00:17:40,650 --> 00:17:44,195
We're going to bury those
details in the way the queue

314
00:17:44,195 --> 00:17:47,210
is implemented and then at the
next higher level, we don't

315
00:17:47,210 --> 00:17:48,670
need to worry about
those details.

316
00:17:48,670 --> 00:17:50,305
We'll abstract them away.

317
00:17:50,305 --> 00:17:53,680
Is that all clear?

318
00:17:53,680 --> 00:17:53,990
OK.

319
00:17:53,990 --> 00:17:57,560
So this then is the way we
end up doing the search.

320
00:17:57,560 --> 00:18:03,340
So when we do the search, when
we create a new node, the idea

321
00:18:03,340 --> 00:18:06,430
is going to be that we
can generate a cost.

322
00:18:06,430 --> 00:18:11,470
Remember, nodes in the search
tree summarize paths.

323
00:18:11,470 --> 00:18:13,300
Nodes are different from
states, right?

324
00:18:13,300 --> 00:18:18,980
States are places that we can
visit, nodes are paths.

325
00:18:18,980 --> 00:18:23,290
So the thing that we need to
keep track of now in addition

326
00:18:23,290 --> 00:18:27,620
to what we did before, before we
had the idea that nodes had

327
00:18:27,620 --> 00:18:30,470
states, they have a place
where you are

328
00:18:30,470 --> 00:18:32,640
currently in the search.

329
00:18:32,640 --> 00:18:36,480
They have actions, which is
which direction do you go next

330
00:18:36,480 --> 00:18:40,740
and they have parents and that
was enough information to

331
00:18:40,740 --> 00:18:45,460
create and maintain
a search tree.

332
00:18:45,460 --> 00:18:48,670
Now what we need to do is
also keep track of cost.

333
00:18:48,670 --> 00:18:51,970
So we do that by adding
instantiation time.

334
00:18:51,970 --> 00:18:55,210
When we create a new node, we
have to also pass it what is

335
00:18:55,210 --> 00:18:57,470
the action cost.

336
00:18:57,470 --> 00:19:00,470
So in the previous example, the
action cost would be the

337
00:19:00,470 --> 00:19:05,060
distance from B to C, for
example, being 5, which is

338
00:19:05,060 --> 00:19:09,250
different from the distance
between B to E, which is 1.

339
00:19:09,250 --> 00:19:13,330
So we have to associate at the
time we create a node, what is

340
00:19:13,330 --> 00:19:16,620
the action cost associated
with this new node.

341
00:19:16,620 --> 00:19:21,740
And then the node keeps track
of the total path cost, so

342
00:19:21,740 --> 00:19:23,240
that's what the red
stuff is doing.

343
00:19:23,240 --> 00:19:27,410
So it's a very small change to
the code that we used for

344
00:19:27,410 --> 00:19:33,330
creating nodes in the previous
two searches, and then we have

345
00:19:33,330 --> 00:19:37,040
to also change the way we do
the basic search algorithm.

346
00:19:37,040 --> 00:19:40,120
And here too, the idea
is pretty simple.

347
00:19:40,120 --> 00:19:43,310
It's almost exactly the same
thing that we did before, with

348
00:19:43,310 --> 00:19:46,550
the idea that we substitute keep
track of the agenda with

349
00:19:46,550 --> 00:19:51,800
a priority queue rather than
with a queue or a stack.

350
00:19:51,800 --> 00:19:58,480
There's one more complication,
and that is that in the past,

351
00:19:58,480 --> 00:20:03,360
we knew that all children
added the same penalty.

352
00:20:03,360 --> 00:20:09,310
Because we only keeping track
all of how many generations,

353
00:20:09,310 --> 00:20:15,140
how many hops are there to the
current node, all children

354
00:20:15,140 --> 00:20:19,170
were in some sense created equal
because we knew they all

355
00:20:19,170 --> 00:20:23,310
incurred one more hop.

356
00:20:23,310 --> 00:20:29,590
Here, because the children can
have different associated

357
00:20:29,590 --> 00:20:36,850
action costs, we don't know at
the time we've picked up the

358
00:20:36,850 --> 00:20:40,120
parent, we don't know at that
time which child is going to

359
00:20:40,120 --> 00:20:42,930
end up being the shortest one.

360
00:20:42,930 --> 00:20:46,910
So previously, the goal test
was performed when the

361
00:20:46,910 --> 00:20:49,360
children were pushed
onto the agenda.

362
00:20:49,360 --> 00:20:55,220
Here we have to wait until we
look at all of the children

363
00:20:55,220 --> 00:20:59,130
before we will know which child
has the shortest length.

364
00:20:59,130 --> 00:21:02,050
And that just means that we take
the goal test, which had

365
00:21:02,050 --> 00:21:06,260
been inside the 'for
a in actions' loop.

366
00:21:06,260 --> 00:21:11,490
We have to factor that out and
defer until the next time.

367
00:21:11,490 --> 00:21:13,330
So that's the only change
to the algorithm

368
00:21:13,330 --> 00:21:16,680
that we need to make.

369
00:21:16,680 --> 00:21:17,880
So is that clear?

370
00:21:17,880 --> 00:21:21,980
So the idea is it's a pretty
simple modification of the

371
00:21:21,980 --> 00:21:26,850
algorithm that we have so far,
but it gives rise to a much

372
00:21:26,850 --> 00:21:28,340
more versatile kind of search.

373
00:21:28,340 --> 00:21:32,950

374
00:21:32,950 --> 00:21:35,410
So last time we saw that there
was really no good point for

375
00:21:35,410 --> 00:21:38,710
not doing the search, the
breadth-first search with

376
00:21:38,710 --> 00:21:41,640
dynamic programming, we have
the same thing here.

377
00:21:41,640 --> 00:21:47,270
So when you're doing the uniform
costs search, there's

378
00:21:47,270 --> 00:21:50,150
no real good reason for not
implementing that with dynamic

379
00:21:50,150 --> 00:21:52,590
programming, so we also want
to think about the dynamic

380
00:21:52,590 --> 00:21:55,090
programming algorithm.

381
00:21:55,090 --> 00:21:57,440
So you remember in breadth-first
search and in

382
00:21:57,440 --> 00:22:00,670
depth-first search, dynamic
programming referred to the

383
00:22:00,670 --> 00:22:07,810
principle that the shortest path
from X to Z through Y, so

384
00:22:07,810 --> 00:22:09,780
if you have a path from X to Z
and you know it goes through

385
00:22:09,780 --> 00:22:13,210
Y, the shortest way you can get
from X to Z through Y is

386
00:22:13,210 --> 00:22:16,200
to add the shortest path from
X to Y to the shortest path

387
00:22:16,200 --> 00:22:18,030
from Y to Z.

388
00:22:18,030 --> 00:22:21,210
Sounds trivial, but it has a
tremendous impact on the

389
00:22:21,210 --> 00:22:25,370
number of states that can be
omitted from the search.

390
00:22:25,370 --> 00:22:28,470
Here, when we do the uniform
cost search, we can do the

391
00:22:28,470 --> 00:22:31,540
same sort of thing but except
that we run into the same sort

392
00:22:31,540 --> 00:22:36,600
of problem with not all
paths from X to

393
00:22:36,600 --> 00:22:40,690
Y are created equally.

394
00:22:40,690 --> 00:22:43,820
We don't want to remember any
random path from X to Y, we

395
00:22:43,820 --> 00:22:48,560
want to remember the best one,
which means that in general,

396
00:22:48,560 --> 00:22:54,460
we're going to have to expand
all of the children before

397
00:22:54,460 --> 00:23:00,210
we'll know which child gives
the minimum length path.

398
00:23:00,210 --> 00:23:03,120
So that means that the dynamic
programming principle that

399
00:23:03,120 --> 00:23:09,870
we'll use is to remember the
state when it gets expanded,

400
00:23:09,870 --> 00:23:12,980
because it only gets expanded
after its already being

401
00:23:12,980 --> 00:23:16,590
compared to its siblings.

402
00:23:16,590 --> 00:23:22,420
So wait until a state, wait
until a path has been compared

403
00:23:22,420 --> 00:23:26,920
to all the siblings of that
particular path before you

404
00:23:26,920 --> 00:23:28,950
consider it for dynamic
programming.

405
00:23:28,950 --> 00:23:32,040
So we'll do that by not keeping
track of states as

406
00:23:32,040 --> 00:23:35,520
they are visited, but instead
keeping track of states as

407
00:23:35,520 --> 00:23:36,450
they are expanded.

408
00:23:36,450 --> 00:23:39,150
That's the same idea that we
had to do when we had to

409
00:23:39,150 --> 00:23:41,770
reorder goal test.

410
00:23:41,770 --> 00:23:45,360
Defer the goal task until
after you think

411
00:23:45,360 --> 00:23:47,800
about all the children.

412
00:23:47,800 --> 00:23:53,010
Defer putting it in the dynamic
programming list until

413
00:23:53,010 --> 00:23:55,690
after you've looked at all the
children and so that means

414
00:23:55,690 --> 00:23:59,910
that we think about expansions
instead of visits.

415
00:23:59,910 --> 00:24:01,080
And so that looks like this.

416
00:24:01,080 --> 00:24:09,540
So just like we took the goal
test outside the action list,

417
00:24:09,540 --> 00:24:13,130
in the previous breadth-first
search we did the test goal

418
00:24:13,130 --> 00:24:17,360
state in this loop, here we
defer it until we've looked at

419
00:24:17,360 --> 00:24:21,600
all the children and
fetched the parent.

420
00:24:21,600 --> 00:24:24,360
So we defer it into the higher
loop, we take it out of this

421
00:24:24,360 --> 00:24:28,080
moving into this and similarly,
we take the dynamic

422
00:24:28,080 --> 00:24:30,490
programming memory.

423
00:24:30,490 --> 00:24:34,230
We now call it expanded to
remind ourselves that what

424
00:24:34,230 --> 00:24:38,130
we're doing is keeping track
of states after they were

425
00:24:38,130 --> 00:24:42,280
expanded, not after
they were visited.

426
00:24:42,280 --> 00:24:47,760
And updating it again, not when
we look at the individual

427
00:24:47,760 --> 00:24:51,160
actions, but only after
we've decided which

428
00:24:51,160 --> 00:24:55,330
trial is the winner.

429
00:24:55,330 --> 00:24:56,670
OK?

430
00:24:56,670 --> 00:24:57,990
That's probably confusing.

431
00:24:57,990 --> 00:25:01,080
That's not important at this
point, because I've written an

432
00:25:01,080 --> 00:25:04,780
example and hopefully by
thinking through the example,

433
00:25:04,780 --> 00:25:07,470
you'll be able to see what the
code is supposed to be doing.

434
00:25:07,470 --> 00:25:10,860
And then a good exercise is to
go through the example, which

435
00:25:10,860 --> 00:25:14,420
will be posted on the web with
all the gory details, and make

436
00:25:14,420 --> 00:25:19,940
sure that you can match
up the search--

437
00:25:19,940 --> 00:25:21,880
the partial results of the
search-- to the way the

438
00:25:21,880 --> 00:25:24,080
algorithm is written.

439
00:25:24,080 --> 00:25:26,680
OK?

440
00:25:26,680 --> 00:25:28,980
So now I want to do the
problem of interest.

441
00:25:28,980 --> 00:25:33,660
Think about what if one of
these nodes, one of the

442
00:25:33,660 --> 00:25:37,270
states, state C,
is very distant

443
00:25:37,270 --> 00:25:39,270
relative to all the rest.

444
00:25:39,270 --> 00:25:43,720
How will the new search, the
uniform cost search, work with

445
00:25:43,720 --> 00:25:44,760
this problem?

446
00:25:44,760 --> 00:25:49,520
So we do the same sort of
thing we did before.

447
00:25:49,520 --> 00:25:52,450
Now we have an agenda to keep
track of the nodes under

448
00:25:52,450 --> 00:25:54,960
consideration.

449
00:25:54,960 --> 00:25:57,240
We have a dynamic programming
list that is going to be

450
00:25:57,240 --> 00:26:00,670
called expanded because we
don't add to it until we

451
00:26:00,670 --> 00:26:03,480
expand states.

452
00:26:03,480 --> 00:26:06,100
It had previously been
called visited.

453
00:26:06,100 --> 00:26:09,540
And we also keep track
of the metric,

454
00:26:09,540 --> 00:26:12,000
which is the path costs.

455
00:26:12,000 --> 00:26:17,800
So if we start by putting node A
on the agenda, its path cost

456
00:26:17,800 --> 00:26:20,070
is 0, because it doesn't cost
anything to get there because

457
00:26:20,070 --> 00:26:22,350
that's where we started.

458
00:26:22,350 --> 00:26:25,670
And we haven't expanded
anybody yet.

459
00:26:25,670 --> 00:26:27,490
So notice that the starting
state is a little bit

460
00:26:27,490 --> 00:26:31,050
different here because we're
keeping track of expanded.

461
00:26:31,050 --> 00:26:34,670
The expanded list started out
with 0 elements in it.

462
00:26:34,670 --> 00:26:36,820
Previously where we were keeping
track of visits, it

463
00:26:36,820 --> 00:26:41,590
started out knowing already
what was going on with A.

464
00:26:41,590 --> 00:26:47,790
So now we expand A, think about
A's children, B and D,

465
00:26:47,790 --> 00:26:52,870
put them on the agenda, and add
A to the expanded list.

466
00:26:52,870 --> 00:26:55,520
We expanded A so it's time
to add it to the dynamic

467
00:26:55,520 --> 00:26:58,570
programming list.

468
00:26:58,570 --> 00:27:04,340
Then also keep track of the
costs of these paths.

469
00:27:04,340 --> 00:27:10,330
AB costs 1, AD costs 1.

470
00:27:10,330 --> 00:27:12,470
That's the end of
the first pass.

471
00:27:12,470 --> 00:27:16,030
Now pop the first guy
off the queue.

472
00:27:16,030 --> 00:27:19,190
Expand it, that means we're
expanding the B state.

473
00:27:19,190 --> 00:27:22,390
We go from A to B, so we're
going to expand B. B Has

474
00:27:22,390 --> 00:27:27,320
children A, C and E. A has
already been expanded so we

475
00:27:27,320 --> 00:27:28,875
don't need to think
about A anymore.

476
00:27:28,875 --> 00:27:31,620

477
00:27:31,620 --> 00:27:35,700
C and E, so it was A, C and
E, C and E have not been

478
00:27:35,700 --> 00:27:41,790
expanded, so I expand B to get
these two and I associate

479
00:27:41,790 --> 00:27:45,890
their total path costs.

480
00:27:45,890 --> 00:27:52,600
So the path ABC, ABC has
length 6 and the path

481
00:27:52,600 --> 00:27:54,225
ABE has length 2.

482
00:27:54,225 --> 00:27:59,670

483
00:27:59,670 --> 00:28:05,100
Then I take the first one off
the agenda again, that's AD.

484
00:28:05,100 --> 00:28:09,310
I expand AD, which is expanding
D. Put that on the

485
00:28:09,310 --> 00:28:12,700
expanded list, on the dynamic
programming was list.

486
00:28:12,700 --> 00:28:18,710
D has children A, E, G. A is
already on the expanded list,

487
00:28:18,710 --> 00:28:25,470
so that means I have to worry
about E and G. Those paths

488
00:28:25,470 --> 00:28:28,030
have length 2 and 2.

489
00:28:28,030 --> 00:28:32,470
That was the same so far
as the previous search.

490
00:28:32,470 --> 00:28:35,410
Now I see something different.

491
00:28:35,410 --> 00:28:40,420
Because I'm using a priority
queue, I skip ABC because

492
00:28:40,420 --> 00:28:44,610
that's just not the right
one to do next.

493
00:28:44,610 --> 00:28:48,650
So ABC, I'm keeping track of
with the priority queue.

494
00:28:48,650 --> 00:28:53,300
I know that that path
is already length 6.

495
00:28:53,300 --> 00:28:58,110
It could end up being the
optimum path, but at this

496
00:28:58,110 --> 00:28:59,890
phase of the search,
it's not the one I

497
00:28:59,890 --> 00:29:01,730
should think of next.

498
00:29:01,730 --> 00:29:04,600
The one I should think of next
is the shortest path.

499
00:29:04,600 --> 00:29:08,430
So what I'm trying to do is
search the search tree in

500
00:29:08,430 --> 00:29:10,620
order of shortest path.

501
00:29:10,620 --> 00:29:16,380
So I skip the ABC because its
path is long and the minimum

502
00:29:16,380 --> 00:29:19,370
length, so back up one.

503
00:29:19,370 --> 00:29:22,680
So in the priority queue idea,
I want to extract from the

504
00:29:22,680 --> 00:29:27,430
queue the first item with the
minimum length, so that's ABE.

505
00:29:27,430 --> 00:29:30,240

506
00:29:30,240 --> 00:29:32,070
Everyone's with that?

507
00:29:32,070 --> 00:29:40,420
So then I want to expand E. E
has children B, D, F, H. So B

508
00:29:40,420 --> 00:29:44,650
and D are here, F and
H are not, so I add

509
00:29:44,650 --> 00:29:49,380
ABEFH to the agenda.

510
00:29:49,380 --> 00:29:50,830
Each of those have length 3.

511
00:29:50,830 --> 00:29:53,400

512
00:29:53,400 --> 00:29:58,195
So what's the next guy
out of the agenda?

513
00:29:58,195 --> 00:30:00,690
AUDIENCE: A and E.

514
00:30:00,690 --> 00:30:05,470
PROFESSOR: I need the first one
with the smallest path,

515
00:30:05,470 --> 00:30:07,610
the smallest cost possible.

516
00:30:07,610 --> 00:30:11,910
The smallest cost possible is
2, so ADE is the next guy.

517
00:30:11,910 --> 00:30:15,870
So I expand ADE, but I've
already expanded E. I Don't

518
00:30:15,870 --> 00:30:18,950
need to do anything.

519
00:30:18,950 --> 00:30:19,430
OK?

520
00:30:19,430 --> 00:30:23,950
The dynamic expansion list is
keeping track of the nodes

521
00:30:23,950 --> 00:30:25,130
I've already expanded.

522
00:30:25,130 --> 00:30:29,730
I already did E, there's nothing
new to be learned.

523
00:30:29,730 --> 00:30:32,130
So that doesn't do anything.

524
00:30:32,130 --> 00:30:36,900
So the next one is G. Well I
didn't do G yet, so add it to

525
00:30:36,900 --> 00:30:38,200
the expanded list.

526
00:30:38,200 --> 00:30:42,510
G is shorter than D and H. D was
already there, H was not,

527
00:30:42,510 --> 00:30:48,990
so add H.

528
00:30:48,990 --> 00:30:55,420
The next one is F. I haven't
expanded F yet, so let's do F.

529
00:30:55,420 --> 00:31:04,090
So F's children are C, E, I. C
is not there, E is there, I is

530
00:31:04,090 --> 00:31:05,570
not there, so I add those.

531
00:31:05,570 --> 00:31:09,980

532
00:31:09,980 --> 00:31:16,060
So next is this guy, H. H
wasn't expended, so I

533
00:31:16,060 --> 00:31:17,830
add H to the list.

534
00:31:17,830 --> 00:31:24,570
H's children are E, G, I. EG are
already there, I is not,

535
00:31:24,570 --> 00:31:25,820
so I add that.

536
00:31:25,820 --> 00:31:28,180

537
00:31:28,180 --> 00:31:31,720
Try expanding H, but already
did expand H so

538
00:31:31,720 --> 00:31:32,970
that doesn't count.

539
00:31:32,970 --> 00:31:35,440

540
00:31:35,440 --> 00:31:38,460
Try expanding C, that's fine.

541
00:31:38,460 --> 00:31:42,090
Expand C, I haven't expanded C
before, add it to the list.

542
00:31:42,090 --> 00:31:45,930
C's children are B and F. B and
F are both there, didn't

543
00:31:45,930 --> 00:31:47,310
add any new children.

544
00:31:47,310 --> 00:31:50,551
AUDIENCE: Why'd you expand
that C, why not H?

545
00:31:50,551 --> 00:31:53,330

546
00:31:53,330 --> 00:31:55,040
PROFESSOR: Oh look at
that, you're right.

547
00:31:55,040 --> 00:31:56,510
Oh, thank you very much.

548
00:31:56,510 --> 00:31:56,840
My slide is wrong.

549
00:31:56,840 --> 00:32:00,720
Ignore that, you're absolutely
correct, thank you.

550
00:32:00,720 --> 00:32:03,760
So let's say I guess this
proves that 200 people

551
00:32:03,760 --> 00:32:08,095
watching the lecturer have
greater insight--

552
00:32:08,095 --> 00:32:08,550
well anyway.

553
00:32:08,550 --> 00:32:09,790
Yes, that's wrong.

554
00:32:09,790 --> 00:32:12,410
Don't bother with that because
it's got the wrong priority.

555
00:32:12,410 --> 00:32:15,110
Jump straight to that.

556
00:32:15,110 --> 00:32:17,480
I'll fix the slide on the web.

557
00:32:17,480 --> 00:32:18,520
You're absolutely right.

558
00:32:18,520 --> 00:32:21,450
I should have gone straight to
there and when I tried to

559
00:32:21,450 --> 00:32:28,530
expand I, I realize that that's
my answer, so I'm done.

560
00:32:28,530 --> 00:32:30,900
OK?

561
00:32:30,900 --> 00:32:32,900
Questions?

562
00:32:32,900 --> 00:32:34,170
OK it's a little tedious.

563
00:32:34,170 --> 00:32:39,550
The point is that it really
wasn't very much different

564
00:32:39,550 --> 00:32:42,860
from doing breadth-first
search.

565
00:32:42,860 --> 00:32:45,130
The same ideas still work.

566
00:32:45,130 --> 00:32:50,350
The same idea of organizing the
search on a tree, looking

567
00:32:50,350 --> 00:32:53,360
for the minimum cost
answer on a tree,

568
00:32:53,360 --> 00:32:54,330
that's the big picture.

569
00:32:54,330 --> 00:32:57,680
That's what we want
you to know about.

570
00:32:57,680 --> 00:33:00,355
I mean, we may ask you a quiz
question about breadth-first

571
00:33:00,355 --> 00:33:02,930
search or depth-first search
or dynamic programming or

572
00:33:02,930 --> 00:33:05,410
whatever, but the big picture,
the thing we really want you

573
00:33:05,410 --> 00:33:09,730
to know is how to think
about a search.

574
00:33:09,730 --> 00:33:14,850
The way to think about a search
is a sequence of states

575
00:33:14,850 --> 00:33:19,230
organized in a tree
that you can then

576
00:33:19,230 --> 00:33:20,350
systematically search.

577
00:33:20,350 --> 00:33:23,870
That's the idea, and the point
of going through the uniform

578
00:33:23,870 --> 00:33:30,540
cost search is to see first and
foremost, that it fits the

579
00:33:30,540 --> 00:33:34,630
same structure, it's the
same kind of problem.

580
00:33:34,630 --> 00:33:38,020
Secondly, there are very tiny
details and so I've tried go

581
00:33:38,020 --> 00:33:38,900
over those details.

582
00:33:38,900 --> 00:33:41,860
The details have to do with
keeping track of the action

583
00:33:41,860 --> 00:33:47,020
cost and keeping track of which
one to do next by way of

584
00:33:47,020 --> 00:33:48,010
a priority queue.

585
00:33:48,010 --> 00:33:50,960
But the big picture is
the same idea works.

586
00:33:50,960 --> 00:33:56,220
States, nodes, trees,
search, cues.

587
00:33:56,220 --> 00:33:56,660
Questions?

588
00:33:56,660 --> 00:33:57,910
Comments?

589
00:33:57,910 --> 00:34:00,300

590
00:34:00,300 --> 00:34:01,550
OK.

591
00:34:01,550 --> 00:34:05,260

592
00:34:05,260 --> 00:34:08,570
The other important thing that
I want to talk about today is

593
00:34:08,570 --> 00:34:12,139
again, this idea of trying
to minimize the

594
00:34:12,139 --> 00:34:14,400
length of your search.

595
00:34:14,400 --> 00:34:16,750
The other point that you're
supposed to get from these two

596
00:34:16,750 --> 00:34:20,560
lectures is depending on exactly
how you set up the

597
00:34:20,560 --> 00:34:26,280
search, you can do a lot
of work or less work.

598
00:34:26,280 --> 00:34:31,659
And we're always interested to
do less, especially because if

599
00:34:31,659 --> 00:34:36,610
you can do a lot less, you can
do a lot harder problem.

600
00:34:36,610 --> 00:34:45,360
So the other thing I want to
talk about next is the idea

601
00:34:45,360 --> 00:34:53,130
that our searches so far have
been starting state centric.

602
00:34:53,130 --> 00:34:54,540
What do I mean by that?

603
00:34:54,540 --> 00:34:59,330
Every search has a starting
state and a goal, and the

604
00:34:59,330 --> 00:35:03,170
ordering of our searches so
far have been go to the

605
00:35:03,170 --> 00:35:06,360
starting state, think of all
the steps you can make from

606
00:35:06,360 --> 00:35:11,965
the starting state and just
keep widening your search

607
00:35:11,965 --> 00:35:14,300
wider and wider and
wider until you

608
00:35:14,300 --> 00:35:15,550
stumble onto the goal.

609
00:35:15,550 --> 00:35:18,740

610
00:35:18,740 --> 00:35:20,810
OK, can you all see that that's
what we've been doing?

611
00:35:20,810 --> 00:35:29,310
So nowhere in our code was the
code aware of the goal other

612
00:35:29,310 --> 00:35:31,780
than am I there yet?

613
00:35:31,780 --> 00:35:34,400

614
00:35:34,400 --> 00:35:37,900
So the search algorithm so
far has been start at the

615
00:35:37,900 --> 00:35:43,100
beginning state, ask if I'm
there yet, try the closest

616
00:35:43,100 --> 00:35:45,560
place I can go, am
I there yet?

617
00:35:45,560 --> 00:35:46,570
Am I at the goal yet?

618
00:35:46,570 --> 00:35:50,920
Try the next closest place I can
go from the start, am I at

619
00:35:50,920 --> 00:35:51,680
the goal yet?

620
00:35:51,680 --> 00:35:53,930
Try the next closest
place I can start

621
00:35:53,930 --> 00:35:56,880
from, am I there yet?

622
00:35:56,880 --> 00:36:02,300
Everything has been starting
state centric.

623
00:36:02,300 --> 00:36:05,530
Obviously, that's wrong.

624
00:36:05,530 --> 00:36:12,260
Somehow, when you do a search,
if you were asked to find the

625
00:36:12,260 --> 00:36:17,640
shortest route through the
interstate highway system from

626
00:36:17,640 --> 00:36:22,910
Kansas to Boston, there's a good
chance you wouldn't be

627
00:36:22,910 --> 00:36:25,770
looking at Wyoming.

628
00:36:25,770 --> 00:36:26,980
Everybody knows enough
geography to

629
00:36:26,980 --> 00:36:29,050
do that one, right?

630
00:36:29,050 --> 00:36:32,840
So the idea is that in the
searches we've done so far,

631
00:36:32,840 --> 00:36:35,010
you would look at Wyoming
before you'd look at

632
00:36:35,010 --> 00:36:36,420
Massachusetts.

633
00:36:36,420 --> 00:36:36,830
OK?

634
00:36:36,830 --> 00:36:38,610
That's stupid, right?

635
00:36:38,610 --> 00:36:40,810
Everybody sort of see that?

636
00:36:40,810 --> 00:36:44,160
So the searches we've done
so far have been

637
00:36:44,160 --> 00:36:47,270
starting state centric.

638
00:36:47,270 --> 00:36:49,350
So what I'd like to
do is think about

639
00:36:49,350 --> 00:36:51,510
a way to undo that.

640
00:36:51,510 --> 00:36:53,850
But again, to set things
up, let's think about

641
00:36:53,850 --> 00:36:55,160
what I mean by that.

642
00:36:55,160 --> 00:36:59,720
Let's imagine a search very much
like what we did before,

643
00:36:59,720 --> 00:37:05,060
except let's go from E to I,
from Kansas to Boston, and I

644
00:37:05,060 --> 00:37:07,270
guess it's Kansas
to Tallahassee,

645
00:37:07,270 --> 00:37:08,560
but you get the idea.

646
00:37:08,560 --> 00:37:11,900
So we start at E and
let's think about

647
00:37:11,900 --> 00:37:13,530
how our search proceeds.

648
00:37:13,530 --> 00:37:19,560
So if you start at E, think
about if we push E in the

649
00:37:19,560 --> 00:37:24,290
agenda, so I'm doing the uniform
cost search with

650
00:37:24,290 --> 00:37:27,300
dynamic programing.

651
00:37:27,300 --> 00:37:30,640
I'm keeping track of the
expanded state as my dynamic

652
00:37:30,640 --> 00:37:31,660
programming state.

653
00:37:31,660 --> 00:37:36,630
I'm starting at E. The cost of
being at E is 0 because that's

654
00:37:36,630 --> 00:37:38,070
where I started.

655
00:37:38,070 --> 00:37:41,530
And now, I think about expanding
E. So E goes on the

656
00:37:41,530 --> 00:37:42,780
expanded list.

657
00:37:42,780 --> 00:37:44,910

658
00:37:44,910 --> 00:37:47,920
I think about all the children
of E, the children are

659
00:37:47,920 --> 00:37:57,420
B,D,F,H. All of those children
have distance 1, so when I

660
00:37:57,420 --> 00:38:00,590
look among them to figure out
the next one that I should do,

661
00:38:00,590 --> 00:38:04,215
I do the first guy, EB.

662
00:38:04,215 --> 00:38:09,680
B's children are A and C, so I
take off EB from the beginning

663
00:38:09,680 --> 00:38:10,930
of the agenda.

664
00:38:10,930 --> 00:38:15,650

665
00:38:15,650 --> 00:38:18,620
Start again, B. B's children
are A, C, E.

666
00:38:18,620 --> 00:38:20,670
E is already expanded.

667
00:38:20,670 --> 00:38:29,746
Push A and C. Pop D, D's
children are A, E, G push A

668
00:38:29,746 --> 00:38:31,480
and G because E's
already there.

669
00:38:31,480 --> 00:38:34,120

670
00:38:34,120 --> 00:38:39,710
Expand F. F's children
are C, E, I. E is

671
00:38:39,710 --> 00:38:42,860
already there, push CI.

672
00:38:42,860 --> 00:38:49,190
Expand H. H's children are G,
I, E, G, I. E is already

673
00:38:49,190 --> 00:38:51,820
there, push GI.

674
00:38:51,820 --> 00:38:56,470
Expand A. A's children are B and
D. They're already there,

675
00:38:56,470 --> 00:38:58,900
don't need to do anything.

676
00:38:58,900 --> 00:39:02,126
Expand C. C's children are BF.

677
00:39:02,126 --> 00:39:04,730
BF are there, I don't
need to do anything.

678
00:39:04,730 --> 00:39:07,510
Expand A. BD are already
there, I

679
00:39:07,510 --> 00:39:08,760
don't need to do anything.

680
00:39:08,760 --> 00:39:13,460
Expand G. G's children are DH,
DH are both there, I don't

681
00:39:13,460 --> 00:39:14,450
need to do anything.

682
00:39:14,450 --> 00:39:17,890
Expand C. BF, BF nothing.

683
00:39:17,890 --> 00:39:20,300
Expand I, I'm there.

684
00:39:20,300 --> 00:39:20,680
Yes?

685
00:39:20,680 --> 00:39:24,552
AUDIENCE: Were you supposed
adding ACE?

686
00:39:24,552 --> 00:39:27,940
PROFESSOR: Was I supposed
to be adding AC?

687
00:39:27,940 --> 00:39:30,410
You add A when you expand it.

688
00:39:30,410 --> 00:39:32,470
Ah, yes, yes, yes.

689
00:39:32,470 --> 00:39:33,620
Thank you.

690
00:39:33,620 --> 00:39:35,800
I'll fix this one, too.

691
00:39:35,800 --> 00:39:40,070
So the question was when I
expanded A, when I did this

692
00:39:40,070 --> 00:39:45,120
one for example, when I tried
to expand A, I should have

693
00:39:45,120 --> 00:39:48,930
added it to the list here so
I don't try to do it again.

694
00:39:48,930 --> 00:39:52,265
It wouldn't have affected the
outcome, but I should have

695
00:39:52,265 --> 00:39:53,280
added it to that list.

696
00:39:53,280 --> 00:39:54,530
Thank you.

697
00:39:54,530 --> 00:39:56,270

698
00:39:56,270 --> 00:39:56,700
Class --

699
00:39:56,700 --> 00:39:58,430
2 Freeman --

700
00:39:58,430 --> 00:39:58,710
0.

701
00:39:58,710 --> 00:39:59,250
Yes?

702
00:39:59,250 --> 00:40:05,510
AUDIENCE: What if you
didn't expand it?

703
00:40:05,510 --> 00:40:08,135
I mean, do you consider it
[UNINTELLIGIBLE] you

704
00:40:08,135 --> 00:40:09,385
should expand it?

705
00:40:09,385 --> 00:40:11,510

706
00:40:11,510 --> 00:40:13,510
PROFESSOR: I'm sorry, I didn't
hear the question.

707
00:40:13,510 --> 00:40:14,510
AUDIENCE: We didn't actually
expand it.

708
00:40:14,510 --> 00:40:17,510
We considered expanding it,
but then we noticed that.

709
00:40:17,510 --> 00:40:17,654
PROFESSOR: Correct, correct.

710
00:40:17,654 --> 00:40:19,640
So what I really should do is go
back and read the code and

711
00:40:19,640 --> 00:40:22,950
figure out what I should do.

712
00:40:22,950 --> 00:40:26,370
What I'm trying to do
is emulate the code.

713
00:40:26,370 --> 00:40:29,320
So your point is, it's a
technical definition about

714
00:40:29,320 --> 00:40:31,040
whether I want to think about
whether I actually

715
00:40:31,040 --> 00:40:32,910
expanded it or not.

716
00:40:32,910 --> 00:40:36,580
If I don't add any children,
was it a real expansion?

717
00:40:36,580 --> 00:40:39,480
And that's a question that is
determined by where was the if

718
00:40:39,480 --> 00:40:43,445
statement in the code, and
frankly I don't remember.

719
00:40:43,445 --> 00:40:46,630

720
00:40:46,630 --> 00:40:48,700
It does not expand it, ah
I have the right answer.

721
00:40:48,700 --> 00:40:50,080
AUDIENCE: It does expand it.

722
00:40:50,080 --> 00:40:51,055
PROFESSOR: It does expand it.

723
00:40:51,055 --> 00:40:52,090
So I have the wrong answer.

724
00:40:52,090 --> 00:40:52,520
Class --

725
00:40:52,520 --> 00:40:55,100
2 and a 1/2.

726
00:40:55,100 --> 00:41:04,360
OK so the point of this is that
the search was symmetric

727
00:41:04,360 --> 00:41:07,350
around E, even though
the goal is not.

728
00:41:07,350 --> 00:41:11,140

729
00:41:11,140 --> 00:41:11,990
OK?

730
00:41:11,990 --> 00:41:16,390
And the question is, how could
we fix it so the search is not

731
00:41:16,390 --> 00:41:20,190
symmetric around E --
the starting point.

732
00:41:20,190 --> 00:41:24,670
How do I fix it so the search is
biased toward going toward

733
00:41:24,670 --> 00:41:25,920
the answer?

734
00:41:25,920 --> 00:41:28,930

735
00:41:28,930 --> 00:41:31,920
And so the way we think about
this is with something we

736
00:41:31,920 --> 00:41:34,650
called heuristics.

737
00:41:34,650 --> 00:41:39,370
So if you think about the
searches we've been doing,

738
00:41:39,370 --> 00:41:42,170
either breadth-first or
depth-first from last time

739
00:41:42,170 --> 00:41:49,720
where we counted the number of
hops or today where we counted

740
00:41:49,720 --> 00:41:55,850
the lengths of paths, each of
those considered what thing to

741
00:41:55,850 --> 00:42:01,620
do next based on the path from
the starting point to the

742
00:42:01,620 --> 00:42:03,800
point under consideration.

743
00:42:03,800 --> 00:42:10,150
The idea of a heuristic is to
add something that informs the

744
00:42:10,150 --> 00:42:15,730
search about how distance, how
much distance we're expecting

745
00:42:15,730 --> 00:42:20,940
to add from the point under
consideration to the goal.

746
00:42:20,940 --> 00:42:25,670
So the idea of the heuristic is
to put in the second part

747
00:42:25,670 --> 00:42:26,920
of the path.

748
00:42:26,920 --> 00:42:28,270

749
00:42:28,270 --> 00:42:32,710
The problem with a heuristic
is that finding the second

750
00:42:32,710 --> 00:42:38,090
part of the path is just as hard
as finding the first part

751
00:42:38,090 --> 00:42:45,240
of the path, and it would be a
terrible idea to -- for every

752
00:42:45,240 --> 00:42:52,460
point in the search tree run a
new search to find the best

753
00:42:52,460 --> 00:42:58,020
answer from that point
to the goal --

754
00:42:58,020 --> 00:43:02,090
because that would increase the
length of the search time

755
00:43:02,090 --> 00:43:04,500
enormously.

756
00:43:04,500 --> 00:43:05,820
So it's a bad idea.

757
00:43:05,820 --> 00:43:09,790
So the problems are of equal
complexity, the problem of

758
00:43:09,790 --> 00:43:14,350
getting from the start point to
the place of interest and

759
00:43:14,350 --> 00:43:17,020
the problem of going from the
place of interest to the goal

760
00:43:17,020 --> 00:43:19,500
are problems of equal
complexity.

761
00:43:19,500 --> 00:43:23,220
We don't want to try to solve
the problem of making the

762
00:43:23,220 --> 00:43:28,210
search better informed by
increasing the complexity of

763
00:43:28,210 --> 00:43:30,900
the search drastically.

764
00:43:30,900 --> 00:43:32,280
So that's the issue.

765
00:43:32,280 --> 00:43:36,380
So a heuristic is going to be
a way of approximating the

766
00:43:36,380 --> 00:43:40,780
amount of work we have to do
yet, where what we would like

767
00:43:40,780 --> 00:43:45,380
it to be is not all that
terribly difficult to compute.

768
00:43:45,380 --> 00:43:48,900
So one way we could think
about that would be to

769
00:43:48,900 --> 00:43:52,960
consider as an approximation
to how much work we have to

770
00:43:52,960 --> 00:43:58,760
do, the Manhattan distance for
example, to complete the path.

771
00:43:58,760 --> 00:44:04,670
The Manhattan distance is the
sum of the x and y distance.

772
00:44:04,670 --> 00:44:07,700
Generally speaking, Manhattan
distance is not a good idea

773
00:44:07,700 --> 00:44:11,680
for map-like problems because
generally you can cut across

774
00:44:11,680 --> 00:44:14,440
corners in such searches.

775
00:44:14,440 --> 00:44:17,620
In this particular search, since
I've excluded cutting

776
00:44:17,620 --> 00:44:23,370
across diagonals, since the
search space is already

777
00:44:23,370 --> 00:44:26,750
Manhattan, thinking about a
heuristic that's based on

778
00:44:26,750 --> 00:44:29,232
Manhattan distance
is probably OK.

779
00:44:29,232 --> 00:44:32,280

780
00:44:32,280 --> 00:44:37,120
So the idea is to develop a
heuristic and he what I'm

781
00:44:37,120 --> 00:44:41,980
going to think about is, what
if I complete the path by

782
00:44:41,980 --> 00:44:46,100
adding the Manhattan distance
from the point under

783
00:44:46,100 --> 00:44:48,150
consideration to the goal.

784
00:44:48,150 --> 00:44:53,000
OK, so now if I started at E
like before and I'm going

785
00:44:53,000 --> 00:44:58,560
toward I like before, then I
start with the agenda having

786
00:44:58,560 --> 00:45:01,350
just E and having expanded
nothing.

787
00:45:01,350 --> 00:45:04,890

788
00:45:04,890 --> 00:45:11,160
However, the cost associated
with E is no longer 0.

789
00:45:11,160 --> 00:45:15,510
The cost of going from E, the
starting point to E, the point

790
00:45:15,510 --> 00:45:20,410
under consideration is still 0,
but I'm estimating the cost

791
00:45:20,410 --> 00:45:24,685
of going from E to I by the
Manhattan distance between E

792
00:45:24,685 --> 00:45:27,410
and I, which is 2.

793
00:45:27,410 --> 00:45:30,120
The Manhattan distance between
E and I is you have to

794
00:45:30,120 --> 00:45:34,370
increment x by 1 and you have
to document y by 1.

795
00:45:34,370 --> 00:45:40,560
So instead of saying that the
cost of state E is 0, I'm

796
00:45:40,560 --> 00:45:42,273
saying that it's 2.

797
00:45:42,273 --> 00:45:45,980
Is that clear why
I'm doing that?

798
00:45:45,980 --> 00:45:51,140
So now I expand E, I think about
the children B,D,F,H --

799
00:45:51,140 --> 00:45:57,790
BDFH, and those children now
are not the same cost.

800
00:45:57,790 --> 00:46:01,410
Even though it costs the same
amount to go from E to each of

801
00:46:01,410 --> 00:46:06,580
its children, going from its
children to the goal, going

802
00:46:06,580 --> 00:46:10,990
from each child to the goal does
not cost the same amount.

803
00:46:10,990 --> 00:46:16,610
If I were to go from E to
B, that's a cost of 1.

804
00:46:16,610 --> 00:46:22,090
But the Manhattan distance
from B to I is 3.

805
00:46:22,090 --> 00:46:25,360
So I'm estimating, then, that
the cost of making the

806
00:46:25,360 --> 00:46:31,030
decision go from E to B is 4.

807
00:46:31,030 --> 00:46:36,330
The real cost of going from E
to B plus the estimated cost

808
00:46:36,330 --> 00:46:42,350
of going from B to I. Similarly,
if I go from E to

809
00:46:42,350 --> 00:46:47,370
D, the Manhattan distance is
3, so that's a length 4.

810
00:46:47,370 --> 00:46:50,730
If I go from E to F, Manhattan
distance from F to I is just

811
00:46:50,730 --> 00:46:54,910
1, so the total cost
is just 2.

812
00:46:54,910 --> 00:47:00,250
So now rather than circling out
from the starting point,

813
00:47:00,250 --> 00:47:04,890
my next step is biased
toward the goal.

814
00:47:04,890 --> 00:47:09,700
So my next step is biased toward
so the remaining items,

815
00:47:09,700 --> 00:47:13,400
the smallest cost is 2,
so the next place

816
00:47:13,400 --> 00:47:17,430
that I expand is EF.

817
00:47:17,430 --> 00:47:22,880
F's children are C, E, I.
E is already here, so I

818
00:47:22,880 --> 00:47:24,960
only think of CI.

819
00:47:24,960 --> 00:47:32,070
C and I also have different
costs, So the cost of going

820
00:47:32,070 --> 00:47:39,630
EFC, EFC, the direct cost is 2
and the estimated distance,

821
00:47:39,630 --> 00:47:42,400
the Manhattan distance between C
and I is also 2, so that's a

822
00:47:42,400 --> 00:47:48,530
cost 4 whereas the cost of EFI,
EFI has a direct cost of

823
00:47:48,530 --> 00:47:54,300
2 and the Manhattan distance
from I to I is 0.

824
00:47:54,300 --> 00:47:59,730
So now I look for the minimum
distance that's remaining, so

825
00:47:59,730 --> 00:48:07,180
that's going to be H. I expand
H, the children are E, G, I.

826
00:48:07,180 --> 00:48:08,560
So E is already here.

827
00:48:08,560 --> 00:48:10,000
I think about GI.

828
00:48:10,000 --> 00:48:12,286
Same sort of deal, some of them
are short, some of them

829
00:48:12,286 --> 00:48:16,930
are long and as I proceed to
the search, I very quickly

830
00:48:16,930 --> 00:48:22,810
find I without having ever
looked in the wrong direction,

831
00:48:22,810 --> 00:48:25,180
or at least having
looked minimally

832
00:48:25,180 --> 00:48:25,880
in the wrong direction.

833
00:48:25,880 --> 00:48:27,570
Is that clear?

834
00:48:27,570 --> 00:48:35,940
So the idea in a heuristic is to
add an estimate of how much

835
00:48:35,940 --> 00:48:41,280
it will cost to complete the
path so that you bias the

836
00:48:41,280 --> 00:48:44,040
search toward the goal.

837
00:48:44,040 --> 00:48:46,860
Rather than making circles
that spiral out from the

838
00:48:46,860 --> 00:48:49,030
starting point, make
the spirals

839
00:48:49,030 --> 00:48:52,090
biased toward the goal.

840
00:48:52,090 --> 00:48:53,450
And here's the way
you do that.

841
00:48:53,450 --> 00:48:54,920
It's very easy.

842
00:48:54,920 --> 00:48:57,590
All you do is every place we
would have looked at cost

843
00:48:57,590 --> 00:49:00,910
before, add the heuristic
function.

844
00:49:00,910 --> 00:49:04,170
So you have to add a heuristic
function, that's the part

845
00:49:04,170 --> 00:49:05,240
that's hard.

846
00:49:05,240 --> 00:49:08,780
The code, given the heuristic
function, is easy.

847
00:49:08,780 --> 00:49:11,050
The really hard part is actually
figuring out what a

848
00:49:11,050 --> 00:49:13,090
reasonable heuristic is.

849
00:49:13,090 --> 00:49:18,130
The reason that's hard is that
you have to be careful not to

850
00:49:18,130 --> 00:49:21,050
miss the solution.

851
00:49:21,050 --> 00:49:25,700
So the heuristic function
can't be bigger than the

852
00:49:25,700 --> 00:49:27,100
actual distance.

853
00:49:27,100 --> 00:49:28,260
OK, why is that?

854
00:49:28,260 --> 00:49:31,590
The agenda is trying to keep
track of all the possible

855
00:49:31,590 --> 00:49:35,050
places that you could
look next.

856
00:49:35,050 --> 00:49:40,230
If your heuristic function makes
the next step look too

857
00:49:40,230 --> 00:49:46,160
big, it'll be taken out of the
agenda and never appear again,

858
00:49:46,160 --> 00:49:49,540
and you'll never
find that path.

859
00:49:49,540 --> 00:49:51,930
So when you're making a
heuristic function, you have

860
00:49:51,930 --> 00:49:57,300
to be very careful not to ever
overestimate the distance from

861
00:49:57,300 --> 00:50:00,930
where you are to the goal.

862
00:50:00,930 --> 00:50:04,920
If you ever overestimate it,
then you can exclude forever

863
00:50:04,920 --> 00:50:10,090
more, so think about the agenda
as a pruning operation.

864
00:50:10,090 --> 00:50:11,410
We did this starting
last time.

865
00:50:11,410 --> 00:50:13,480
When we think about pruning,
we pop off

866
00:50:13,480 --> 00:50:14,430
things from the agenda.

867
00:50:14,430 --> 00:50:15,130
We say --

868
00:50:15,130 --> 00:50:17,050
don't ever need to look there,
don't need to look there.

869
00:50:17,050 --> 00:50:18,300
We pruned it.

870
00:50:18,300 --> 00:50:21,660

871
00:50:21,660 --> 00:50:24,980
If you have a heuristic that it
is too big you can prune a

872
00:50:24,980 --> 00:50:28,970
path that was the answer.

873
00:50:28,970 --> 00:50:31,200
So you have to be careful
never to do that.

874
00:50:31,200 --> 00:50:32,350
So it's asymmetrical.

875
00:50:32,350 --> 00:50:38,300
If you were to put in a
heuristic that is too small,

876
00:50:38,300 --> 00:50:41,720
that causes you to underestimate
the penalty of

877
00:50:41,720 --> 00:50:45,110
going in the wrong direction.

878
00:50:45,110 --> 00:50:49,750
So if you said, I'm trying to
go from Kansas to Boston and

879
00:50:49,750 --> 00:50:52,740
you inadvertently said that
Wyoming really didn't cost

880
00:50:52,740 --> 00:50:58,830
anything, then you would not
necessarily exclude the

881
00:50:58,830 --> 00:51:03,590
correct answer, but you would
include and cause the search

882
00:51:03,590 --> 00:51:07,140
to consider a necessary path.

883
00:51:07,140 --> 00:51:11,150
So the idea is that you would
like the heuristic to be the

884
00:51:11,150 --> 00:51:16,300
same as the real cost
or smaller.

885
00:51:16,300 --> 00:51:19,810
You don't want to end up solving
another search problem

886
00:51:19,810 --> 00:51:22,680
in order to calculate it,
because that will increase the

887
00:51:22,680 --> 00:51:25,000
cost of doing the
search too much.

888
00:51:25,000 --> 00:51:30,280
So you would like some number
that's easy to calculate that

889
00:51:30,280 --> 00:51:33,320
has the guarantee that it will
always be less than or equal

890
00:51:33,320 --> 00:51:38,200
to the actual cost, and that's
the art of doing a heuristic.

891
00:51:38,200 --> 00:51:41,610
If you satisfy those, then that
previous algorithm that

892
00:51:41,610 --> 00:51:42,610
we looked at, which is --

893
00:51:42,610 --> 00:51:44,920
in the literature it's call
the A-Star Algorithm for

894
00:51:44,920 --> 00:51:46,710
historical reasons.

895
00:51:46,710 --> 00:51:50,640
That algorithm, if you obey
these rules for finding

896
00:51:50,640 --> 00:51:54,010
admission an admissible
heuristic, if you find an

897
00:51:54,010 --> 00:51:57,590
admissible heuristic, then the
A-Star search will be a lot

898
00:51:57,590 --> 00:52:02,980
faster and still find a solution
with the same length.

899
00:52:02,980 --> 00:52:05,920

900
00:52:05,920 --> 00:52:08,920
OK, so now just to see if you're
following what I'm

901
00:52:08,920 --> 00:52:12,160
saying, here's a question
to ask yourself.

902
00:52:12,160 --> 00:52:13,380
Remember the tiles problem?

903
00:52:13,380 --> 00:52:17,110
The tiles problem is the first
problem that I did last time.

904
00:52:17,110 --> 00:52:19,840
The idea was, imagine
starting in this

905
00:52:19,840 --> 00:52:22,890
configuration 12345678.

906
00:52:22,890 --> 00:52:26,880
Move one tile at a time by
moving the tile into the free

907
00:52:26,880 --> 00:52:30,740
spot, so I could move 8 to
the right or 6 down.

908
00:52:30,740 --> 00:52:33,960
Keep doing that until you
perturb this configuration

909
00:52:33,960 --> 00:52:35,210
into this configuration.

910
00:52:35,210 --> 00:52:38,350

911
00:52:38,350 --> 00:52:42,230
We saw last time that there are
a large number of states--

912
00:52:42,230 --> 00:52:44,390
there's a third of a
million states--

913
00:52:44,390 --> 00:52:46,830
so this is a big search problem,
even though it's

914
00:52:46,830 --> 00:52:48,170
something you've almost
certainly

915
00:52:48,170 --> 00:52:49,625
also solved as a child.

916
00:52:49,625 --> 00:52:52,450
And in fact, my version, it
was the same as yours, I'm

917
00:52:52,450 --> 00:52:54,420
sure, was a 4-by-4.

918
00:52:54,420 --> 00:52:57,170
I did the 15 puzzle, not
the eight puzzle, but

919
00:52:57,170 --> 00:52:59,430
it's the same idea.

920
00:52:59,430 --> 00:53:04,340
So what I want to do is
consider heuristics.

921
00:53:04,340 --> 00:53:05,910
Consider three heuristics.

922
00:53:05,910 --> 00:53:08,730
Heuristic A is 0.

923
00:53:08,730 --> 00:53:10,850
It always returns 0.

924
00:53:10,850 --> 00:53:14,530
That's an easy heuristic
to calculate, right?

925
00:53:14,530 --> 00:53:18,000
Heuristic B is sum the number
of tiles that are

926
00:53:18,000 --> 00:53:21,220
in the wrong position.

927
00:53:21,220 --> 00:53:23,960
What is heuristic B
for this state?

928
00:53:23,960 --> 00:53:25,210
AUDIENCE: 8?

929
00:53:25,210 --> 00:53:28,820

930
00:53:28,820 --> 00:53:30,910
PROFESSOR: 8 -- there's 8 tiles

931
00:53:30,910 --> 00:53:33,950
that are out of position.

932
00:53:33,950 --> 00:53:40,360
So heuristic C is the sum of
the Manhattan Distances

933
00:53:40,360 --> 00:53:51,040
required to move each title to
their respective locations and

934
00:53:51,040 --> 00:53:54,190
then calculate two
partial sums.

935
00:53:54,190 --> 00:53:57,480
Consider MI to be the number of
moves and the best solution

936
00:53:57,480 --> 00:54:00,800
if you use heuristic I and EI
is the number of states that

937
00:54:00,800 --> 00:54:04,410
are expanded while you're
doing the search.

938
00:54:04,410 --> 00:54:08,150
If you use heuristic I,
which of the following

939
00:54:08,150 --> 00:54:10,890
statements are true?

940
00:54:10,890 --> 00:54:15,090
OK, take a minute, talk to your
neighbor, figure it out

941
00:54:15,090 --> 00:54:17,196
which of these are true.

942
00:54:17,196 --> 00:57:32,480
[CLASS TALKING]

943
00:57:32,480 --> 00:57:34,860
PROFESSOR: OK so what's
the smallest

944
00:57:34,860 --> 00:57:38,090
numbered correct answer?

945
00:57:38,090 --> 00:57:43,608

946
00:57:43,608 --> 00:57:46,584
The smallest numbered
correct answer.

947
00:57:46,584 --> 00:57:48,072
Oh, come on.

948
00:57:48,072 --> 00:57:49,064
Volunteer.

949
00:57:49,064 --> 00:57:50,056
Explain it with your neighbor.

950
00:57:50,056 --> 00:57:51,550
OK, very good.

951
00:57:51,550 --> 00:57:54,540
The smallest numbered correct
answer is (1).

952
00:57:54,540 --> 00:57:56,700
MA equals MB equals MC.

953
00:57:56,700 --> 00:57:59,545
Why is that?

954
00:57:59,545 --> 00:58:04,515
How can I prove that MA
equals MB equals MC.

955
00:58:04,515 --> 00:58:07,497
What do I have to do?

956
00:58:07,497 --> 00:58:07,994
Yes?

957
00:58:07,994 --> 00:58:10,976
AUDIENCE: You'll have
to reach the

958
00:58:10,976 --> 00:58:12,467
shortest possible solution.

959
00:58:12,467 --> 00:58:14,810
PROFESSOR: So under what
conditions will they all reach

960
00:58:14,810 --> 00:58:16,443
the same length solution?

961
00:58:16,443 --> 00:58:19,425
AUDIENCE: They're all
doing backflips.

962
00:58:19,425 --> 00:58:21,413
PROFESSOR: They're all
doing backflips.

963
00:58:21,413 --> 00:58:23,401
There's another condition.

964
00:58:23,401 --> 00:58:24,395
Yes?

965
00:58:24,395 --> 00:58:27,430
AUDIENCE: That they're all
either exactly [INAUDIBLE].

966
00:58:27,430 --> 00:58:32,460
PROFESSOR: So the heuristics,
all three heuristics have to

967
00:58:32,460 --> 00:58:37,630
be admissible, which means
that they have to be

968
00:58:37,630 --> 00:58:39,830
non-negative numbers.

969
00:58:39,830 --> 00:58:43,520
To be admissible, a heuristic
has to be non-negative.

970
00:58:43,520 --> 00:58:46,580
And it has to generate an answer
that's smaller than the

971
00:58:46,580 --> 00:58:50,310
actual number of moves
necessary to

972
00:58:50,310 --> 00:58:52,270
complete the path.

973
00:58:52,270 --> 00:58:54,950
So we have to prove that these
are all admissible.

974
00:58:54,950 --> 00:58:58,400

975
00:58:58,400 --> 00:59:00,830
So, are they all non-negative?

976
00:59:00,830 --> 00:59:02,220
Yes.

977
00:59:02,220 --> 00:59:06,900
Are they all less than or
equal to the number?

978
00:59:06,900 --> 00:59:08,880
So let's do that.

979
00:59:08,880 --> 00:59:10,170
Let's first of all
get an answer.

980
00:59:10,170 --> 00:59:12,080
So we'll do that after we
do the second part.

981
00:59:12,080 --> 00:59:14,650
What's the second smallest
correct statement?

982
00:59:14,650 --> 00:59:18,514

983
00:59:18,514 --> 00:59:22,378
Let me see if I can
answer it, yes?

984
00:59:22,378 --> 00:59:24,690
OK, the answer is 4.

985
00:59:24,690 --> 00:59:26,110
So, how do you know that
EA is bigger than EB

986
00:59:26,110 --> 00:59:27,360
is bigger than EC?

987
00:59:27,360 --> 00:59:30,090

988
00:59:30,090 --> 00:59:32,850
So the number of states expanded
has to do with the

989
00:59:32,850 --> 00:59:35,800
size of the heuristic.

990
00:59:35,800 --> 00:59:39,150
If the size of the heuristic is
0, that's the same as not

991
00:59:39,150 --> 00:59:39,840
using a heuristic.

992
00:59:39,840 --> 00:59:43,120
That will search all possible
states in a breadth-first

993
00:59:43,120 --> 00:59:44,880
search fashion.

994
00:59:44,880 --> 00:59:49,630
If the heuristic is anything
that's bigger, the number of

995
00:59:49,630 --> 00:59:52,240
searches will go down.

996
00:59:52,240 --> 00:59:55,570
What's the greater than or equal
to thing doing here?

997
00:59:55,570 --> 00:59:56,067
Yes?

998
00:59:56,067 --> 00:59:58,055
AUDIENCE: Number (3) is
technically also true, because

999
00:59:58,055 --> 01:00:00,540
if (1) is true, then
(3) has to be true.

1000
01:00:00,540 --> 01:00:03,025
PROFESSOR: If the number
(3) is technically

1001
01:00:03,025 --> 01:00:10,500
the number M. [LAUGHTER]

1002
01:00:10,500 --> 01:00:12,246
OK, OK, OK.

1003
01:00:12,246 --> 01:00:15,210
[APPLAUSE]

1004
01:00:15,210 --> 01:00:19,070
OK, class, three plus.

1005
01:00:19,070 --> 01:00:24,240
Freeman, oh well.

1006
01:00:24,240 --> 01:00:25,080
Yes, you're right.

1007
01:00:25,080 --> 01:00:26,810
Yes, I agree.

1008
01:00:26,810 --> 01:00:28,060
Did you raise your
hand for (3)?

1009
01:00:28,060 --> 01:00:31,120

1010
01:00:31,120 --> 01:00:35,380
So (3) is technically the
second, yes that's right,

1011
01:00:35,380 --> 01:00:36,990
that's right.

1012
01:00:36,990 --> 01:00:40,920
OK so moving on.

1013
01:00:40,920 --> 01:00:42,150
Number (5) --

1014
01:00:42,150 --> 01:00:44,570
the same best solution
will result for all

1015
01:00:44,570 --> 01:00:45,310
the heuristics --

1016
01:00:45,310 --> 01:00:46,560
true or false?

1017
01:00:46,560 --> 01:00:56,100

1018
01:00:56,100 --> 01:00:59,170
Come on, things can only
go downhill for me.

1019
01:00:59,170 --> 01:01:04,290
So the same best solution will
result for all of the

1020
01:01:04,290 --> 01:01:05,540
heuristics?

1021
01:01:05,540 --> 01:01:08,790

1022
01:01:08,790 --> 01:01:11,260
How could it possibly
be false?

1023
01:01:11,260 --> 01:01:11,570
Right?

1024
01:01:11,570 --> 01:01:14,562
Didn't we already said MA was
equal to MB equals MC.

1025
01:01:14,562 --> 01:01:22,434

1026
01:01:22,434 --> 01:01:23,910
Yeah?

1027
01:01:23,910 --> 01:01:24,852
AUDIENCE: It's the same amount
of moves, but maybe not

1028
01:01:24,852 --> 01:01:25,300
exactly the same solutions.

1029
01:01:25,300 --> 01:01:31,340
So if there are multiple
solutions of the same length,

1030
01:01:31,340 --> 01:01:33,930
the difference heuristics don't
have to give you the

1031
01:01:33,930 --> 01:01:36,580
same solution exactly.

1032
01:01:36,580 --> 01:01:38,420
They have to give you solutions

1033
01:01:38,420 --> 01:01:39,670
with the same length.

1034
01:01:39,670 --> 01:01:42,180

1035
01:01:42,180 --> 01:01:45,490
So what happens with the
heuristics is you perturb the

1036
01:01:45,490 --> 01:01:47,560
order of search.

1037
01:01:47,560 --> 01:01:50,480
If you perturb the order of
search, the only thing that is

1038
01:01:50,480 --> 01:01:54,260
proved is that you get a minimum
length solution, not

1039
01:01:54,260 --> 01:01:56,560
the same minimum length
solution.

1040
01:01:56,560 --> 01:01:58,890
This particular problem has lots
of solutions and so you

1041
01:01:58,890 --> 01:02:01,330
don't necessarily get the same
solution when you use

1042
01:02:01,330 --> 01:02:05,870
different heuristics, OK?

1043
01:02:05,870 --> 01:02:11,620
So the final point is that the
addition of the heuristics can

1044
01:02:11,620 --> 01:02:13,830
be extremely effective.

1045
01:02:13,830 --> 01:02:20,760
If you run this problem with
our search algorithm, you

1046
01:02:20,760 --> 01:02:24,750
always get solutions with
22 moves in them.

1047
01:02:24,750 --> 01:02:27,770
That's good because all the
heuristics were admissible so

1048
01:02:27,770 --> 01:02:33,390
you always get a right answer
-- a shortest answer.

1049
01:02:33,390 --> 01:02:36,640
But the number of visited and
expanded are drastically

1050
01:02:36,640 --> 01:02:41,200
different when you add
the heuristics.

1051
01:02:41,200 --> 01:02:47,150
So if you use here heuristic A,
which is equivalent to no

1052
01:02:47,150 --> 01:02:53,800
heuristic, you end up visiting
170,000 states to find this

1053
01:02:53,800 --> 01:02:57,020
answer, where if you used the
Manhattan distance to the

1054
01:02:57,020 --> 01:03:01,190
goal, the sum of the Manhattan
distances, you do a very small

1055
01:03:01,190 --> 01:03:02,300
fraction of that.

1056
01:03:02,300 --> 01:03:05,650
So the point is that this stuff
matters, especially when

1057
01:03:05,650 --> 01:03:08,860
you do a higher-dimension
search, which is all of the

1058
01:03:08,860 --> 01:03:11,290
searches that we'll will
be interested in.

1059
01:03:11,290 --> 01:03:15,970
So the idea is that the order
really does matter and with

1060
01:03:15,970 --> 01:03:20,750
that, I'll conclude with a
reminder that tomorrow evening

1061
01:03:20,750 --> 01:03:23,830
is the makeup/retake day
for Nano Quizzes.

1062
01:03:23,830 --> 01:03:25,760
Please come to the lab if
you'd like to make up or

1063
01:03:25,760 --> 01:03:27,010
retake the Nano Quiz.

1064
01:03:27,010 --> 01:03:34,228